
* Symbolic execution introduction

This note document the 'pathsymb' strategy from Talos.  Recall that a
strategy takes a slice and constructs a set of models for that slice,
where a model is represented by a SelectedPath --- essentially a
grammar where all choices (byte values, alternation) have been
replaced by concrete values.  This strategy uses an SMT solver to
determine these choices.

We will initially discuss the strategy mostly ignoring looping
constructs, and then discuss loops and sequences.

The strategy is implemented in two phases: (1) the slice is converted
into a _parametric SelectedPath_ along with supporting SMT context;
and (2) the SMT solver is repeatedly queried to build up a set of
SelectedPaths which are returned to the rest of Talos.

* Phase 1: Context building

The pathsymb strategy constructs, for a given slice,

1. A parametric SelectedPath which represents a family of 
   SelectedPaths indexed by the SMT variables in the context;
2. A SMT context, consisting of a set of SMT variables representing
   the byte values and choices in the slice, along with a set of SMT
   assertions constraining these variables;
3. A semi-symbolic value representing the result of the slice, used
   when recursing into the slice.

We describe each of these constructs below.

* Parametric SelectedPath

SelectedPaths are a family of partial parse trees:
#+begin_src haskell
data SelectedPathF ch ca lp a =
    SelectedHole
  | SelectedBytes ProvenanceTag a
  | SelectedDo (SelectedPathF ch ca lp a) (SelectedPathF ch ca lp a)
  | SelectedChoice (ch (SelectedPathF ch ca lp a))
  | SelectedCall FInstId (SelectedPathF ch ca lp a)
  | SelectedCase (ca (SelectedPathF ch ca lp a))
  | SelectedLoop (lp (SelectedPathF ch ca lp a))

data PathIndex a  = PathIndex { pathIndex :: Int, pathIndexPath :: a }
type SelectedPath = SelectedPathF PathIndex Identity SelectedLoopF ByteString
#+end_src
They can be thought of as a path through a Slice, where all the
choices in the slice have been assigned a value.

During the first phase of pathsymb, these choices are left symbolic
(i.e., represented by a SMT variable) in the SelectedPath, and so all
paths are represented.  During the second phase (where a SMT model is
available), these choices are replaced by concrete values, and the
paths not taken are discarded.
#+begin_src haskell
  data PathChoiceBuilder a = SymbolicChoice PathVar [(Int, a)]
  data PathCaseBuilder a   =  SymbolicCase   SymbolicCaseTag GuardedSemiSExprs [(Pattern, a)]
  data SolverResult = ByteResult SMTVar | -- ...
  -- ...
  type PathBuilder = SelectedPathF PathChoiceBuilder PathCaseBuilder PathLoopBuilder SolverResult
#+end_src

* SMT Context

The SMT context contains a collection of side conditions for variables
generated during the first phase.  There are several classes of
variable generated by the pathsymb strategy, namely
- Byte variables;
- Choice variables; and
- Loop bound variables.

These correspond to Match statements, Choice statements, and Many
statements respectively.

During symbolic execution, assertions are generated to show that  
1. A (fresh) byte variable lies within the corresponding ByteSet;
2. A choice variable is bounded by the number of choices;
3. A loop variable lies within a particular range (e.g. from the
   arguments to Many)
4. Cases are well-formed (more below); and 
5. A fresh inverse variable is constrained by the inverse predicate.

The primary generator of SMT assertions are case statements (and loop
bounds, see the discussion on loops below).  Case statements are where
values are examined, and so we will discuss these statements after the
handling of values has been presented.

* Values

The implementation of values determines the implementation of the
symbolic simulator in general, including the representation of path
conditions.  A path condition names a path to a point in the grammar,
in particular recording which branches are taken from the root to the
program point.  For slices, these branches are choice points (i.e.,
grammar alternation) and case statements.

During symbolic simulation variables are assigned to semi-symbolic
values: these values contain a mix of concrete information, along with
references to solver variables.  Because we are simulating all paths,
symbolic values are _sets_ of values, where each value is guarded by a
predicate representing the path(s) that led to that value.

** Example

As an example, consider

#+begin_src daedalus

  def Ex1 = block
    v = ( {- c == 0 -} ^ 42
        | {- c == 1 -} ^ 10
        )
#+end_src

where the ghost variable 'c' represents the SMT variable assigned to
the choice in v.

In this example, the value assigned to v is
#+begin_example
v: { (c = 0) |= 42
   , (c = 1) |= 10
   }
#+end_example

If we were representing values purely symbolically, this would result
in a new SMT variable x, which is associated with the Daedalus
variable v, along with the side conditions
#+begin_example
(c = 0 --> x = 42) && (c = 1 --> x = 10)
#+end_example
(or some equivalent encoding).  With any representation of values, we
also have the side condition that c is 0 or 1.

Now, if we consider
#+begin_src daedalus

  def Ex2 = block
    v1 =  ( {- c1 == 0 -} ^ 1
	  | {- c1 == 1 -} ^ 2
	  )
    v2 =  ( {- c2 == 0 -} ^ 10
	  | {- c2 == 1 -} ^ 20
	  )
    v3 = ^ v1 + v2	
#+end_src

we have the variable assignments:
#+begin_example
v1: { (c1 = 0) |= 1
    , (c1 = 1) |= 2
    }
v2: { (c2 = 0) |= 10
    , (c2 = 1) |= 20
    }
v3: { (c1 = 0, c2 = 0) |= 11
    , (c1 = 1, c2 = 0) |= 12
    , (c1 = 0, c2 = 1) |= 21
    , (c1 = 1, c2 = 1) |= 22
    }
#+end_example

where there is a value in v3 for each possible path to v3 in the
variables used to calculate v3.

The tricky part is how to represent and operate over these values in
an efficient and comprehensible fashion.  There are a few key places
where the implementation of values impacts these areas
1. Values are joined at branching operations, namely choice and
   case. This join is essentially set union guarded by a per-branch
   predicate; and
2. Case operations are where the value is examined, and hence where
   the path condition associated with each value is used.

In the remainder of this section we will discuss the representation of
values, using a simplifed Core to focus the discussino on the main
issues.

** A simplified Core

Consider a simplified Core with only sums, products, recursion via
type names, and bitvec base types:

#+begin_src haskell

  data Type =
    BVTy Int
    | SumTy Type Type
    | ProdTy Type Type
    | NamedTy TName

  boolTy, unitTy :: Type
  unitTy = BVTy 0
  boolTy = SumTy unitTy unitTy
    
#+end_src

The corresponding concrete simulator value type would be:

#+begin_src haskell

  data Label = L | R
  data Value =
    BVV Int Integer
    | SumV Label Value
    | ProdV Value Value

#+end_src

and the definition of the simplified Core slice syntax

#+begin_src haskell

  data SimpleCore =
    Pure Expr
    | Do Name SimpleCore SimpleCore
    | Byte
    | Call FName [Name]
    | Choose SimpleCore SimpleCore
    -- Simplified to sum types (incl. our rep. of bools)
    | PartialCase Name Label SimpleCore
    | Hole

#+end_src

This is quite sparse, but we can, for example, implement (total) case
over a sum type as (abusing syntax)
#+begin_src
  (case n of L -> LHS | R -> RHS)
  =def=
  Choose (case n of L -> LHS)
         (case n of R -> RHS)
#+end_src

Below we sketch a general symbolic simulator for SimpleCore by
abstracting over the implementation of values.  The abstract value
class includes the notion of a PathConditionElement, a tag for a node
in the path.  We implement PathConditions as lists of these elements,
although in practice the PathCondition may be more complex.

This implementation allows for unreachable code which is discovered in
symbolically executing expressions, and in case statements (both in
the abstract value class).  The unreachability is handled in the cases
for choices, where unreachable subtrees are pruned.  Unreachability
can also be used to prune recursive calls at some depth, although we
leave out the details of function calls (which are otherwise
straightforward).

#+begin_src haskell
  -- * Assumed functions

  -- Unfolds the function defition and simulates the body under the
  -- environment extended by the arguments.
  unfoldFunctionAndRecurse :: SimValue a => 
			      PathCondition -> Env a ->
			      FName -> [Expr] -> M (PathBuilder, a)

  -- Unreachabe/unsatisfiable grammars.  These can happen when the
  -- grammar is empty, or in normal grammars when, for example,
  -- unfolding recursive calls beyond some depth implicit in the
  -- grammar.  We handle them like exceptions in this implementation.
  unreachable :: M a
  handleUnreachable :: M a -> M (Maybe a)

  type Env a = Map Name a

  -- * Abstract Value API
  class SimValue a where
    data PathConditionElement a
    -- Convert an a pure expression into a symbolic value.  May be
    -- unreachable if, e.g., we combine two mutually disjoint values.
    symExecExpr       :: Expr -> M a
    -- Create a fresh byte variable
    freshByte         :: M a
    -- Create a fresh SMT variable representing choices.
    freshSMTChoiceVar :: M (SMTVar, PathConditionElement a, PathConditionElement a)
    -- Merge two values from different paths into a single value.
    muxChoices :: PathCondition a ->
		  (PathConditionElement a, a) -> 
		  (PathConditionElement a, a) ->
		  M a
    -- Assert that the given value is the given label, returning the
    -- path context element.  May be unreachable if the value is the
    -- wrong shape.
    assertCase :: PathCondition a ->
		  a -> Label -> M (PathConditionElement a)

  type PathCondition a = [PathConditionElement a]

  -- * Helpers

  extendEnv :: Env a -> Name -> a -> Env a
  extendEnv = Map.insert 

  -- Assume a PathBuilder which may contain value-specific parts.
  simulate :: SimValue a => PathCondition a -> Env a ->
	      Slice -> M (PathBuilder a, a)
  simulate pc env s =
    case s of
      Pure e -> do
	e' <- symExecExpr e
	pure (SelectedHole, e')
      Do x l r -> do
	(lp, lv) <- simulate pc env l
	(rp, rv) <- simulate pc (extendEnv env x lv) r
	pure (SelectedDo lp rp, rv)
      Byte -> do
	v <- freshByte
	pure (SelectedBytes v, v)
      Call f args -> unfoldFunctionAndRecurse pc env f args
      Choose l r -> do
	(cv, lel, rel) <- freshSMTChoiceVar
	-- This is where we handle unreachable code
	m_l <- handleUnreachable (simulate (lel : pc) env l)
	m_r <- handleUnreachable (simulate (rel : pc) env r)
	-- If no branch is reachable, then the choice is unreachable; if
	-- one branch is unreachable, then we just use the remaining
	-- branch; if both are reachable, we mux the values.
	case (m_el, m_r) of
	  (Nothing, Nothing) -> unreachable -- propagate
	  (Just (p, v), Nothing) ->
	    pure (SelectedChoice (Concrete 0 p), v)
	  (Nothing, Just (p, v)) ->
	    pure (SelectedChoice (Concrete 1 p), v)
	  (Just (lp, lv), Nothing) -> do
	    (rp, rv) <- simulate (rel : pc) env r
	    v <- muxChoices pc (lel, lv) (rel, rv)
	    pure (SelectedChoice lp rp, v)
      PatialCase n l b -> do
	let nv = lookupEnv env n
	el <- assertCase nv l
	(p, v) <- simulate (el : pc) env b
	pure (SelectedPartialCase p, v)
#+end_src

We will use this implementation in the following to discuss the
tradeoffs for the various value representations.  Because the
PathBuilder is generated by common code, two implementations should
have isomorphic PathBuilders up to pruning of unreachable nodes.  In
the case of pruned nodes, the isomorphism will equate path variables
in one PathBuilder with the concrete index of the reachable branch in
the other.

** Symbolic values

As a point of comparison consider a purely symbolic implementation of
values: the value type is simply a SMT variable.  We can instantiate
the framework by 
#+begin_src haskell

  -- Assume some magic to turn [smt| ... |] into a sexpr
  instance SimValue SMTVar where
    data PathConditionElement SMTVar =
      ChoicePath SMTVar Int | CasePath SMTVar Label

    symExecExpr  e =
      case e of
	Add e1 e2 = [smt| (bvadd e1 e2) |]
	-- ...

    freshByte = freshSMTVar 

    freshSMTChoiceVar = do
      v <- freshSMTVar -- boolean
      pure (v, ChoicePath v true, ChoicePath v false)

    muxChoices pc (lel, lv) (rel, rv) = do
      v <- freshSMTVar
      -- Assume a magic quoter for readibility
      addSMTAssertion [smt| (pc && lel) --> v = lv |]
      addSMTAssertion [smt| (pc && rel) --> v = rv |]
      pure v

    -- Assert that the given value is the given label, returning the
    -- path context element.
    assertCase pc v l = do
      let el = CasePath v l
      addSMTAssertion [smt| pc --> isLabel l v |]
      pure el
#+end_src

** Semi-symbolic Values (SSVs)

The purely symbolic representation of values is problematic for the
following reasons:
1. SMT solver support for inductive data-types is experimental, and
   has caused issues in earlier versions of Talos.  Thus, these types
   are better represented inside Talos, using the solver for base
   types only; and
2. Supporting concrete values means that paths which are not feasible
   can by pruned before they are sent to the solver.  This is useful,
   for example, in the case of loops with an implicit bound (e.g. the
   IPV6 parser).

THe symbolic representation will serve as the definition of
correctness: a different representation of values will be considered
correct if the SMT contexts generated is equi-satisfiable to that for
symbolic representation, and the resulting SelectedPath is equal (or,
equivalently, the models are equivalent modulo the isomorphism between
PathBuilders).

The alternative is to use _semi-symbolic values_ (SSVs), namely values
where some of the structure is kept in the simulator, as opposed to in
the solver.  A major complication in using semi-symbolic values is
that values branch, and so need be represented as a set of
(PathCondition, Value) pairs.

*** A parametric value

Consider the generalised type of values
#+begin_src haskell

  data SemiValue f a =
    BaseSV a
    | SumSV Label f
    | ProsSV f f

  data BaseSemiValue = ConcreteBase Integer | SymbolicBase SMTVar
#+end_src

There are 3 representations of semi-symbolic values we will discuss,
differing in where path-branching occurs (i.e., how f and a are
instantiated in the above):
1. Top-level branching, where path conditions occur only at the top-level, not inside SemiValue;
2. Nested branching, allowing branching at recursion points inside SemiValue; and 
3. Leaf branching, where all branching occurs at the leaves of the SemiValue.

*** Top-level branching

Top-level branching instantiates as follows
#+begin_src haskell
  type TopLevelBranch = SemiValue TopLevelBranch BaseSemiValue
  type TopLevelValue  = [(PathCondition TopLevelValue, TopLevelBranch)]
#+end_src

This representation is inefficient: consider
#+begin_src haskell
  makeProduct g xs ys = [ (g `conj` gx `conj` gy, ProdSV x y)
			| (gx, x) <- xs, (gy, y) <- ys]
#+end_src

The result has size equal to the product of the size of the arguments,
and requires merging of path conditions for each combination of
argument values.

*** Nested branching

#+begin_src haskell
  type NestedBranch = SemiValue NestedValue BaseSemiValue
  type NestedValue  = [(PathCondition NestedValue, TopLevelBranch)]
#+end_src

where the arguments to recursive nodes can be value sets, rather than
just values.  This makes construction of products simple
#+begin_src haskell
  makeProduct g xs ys = [ (g, ProdSV xs ys) ]
#+end_src

** Phase 2: Model extraction

   
** Loops and sequences

TBD

* Notes


#+begin_src daedalus

  def Ex = block
    v1 = UInt8
    v2 = UInt8
    ( {- c == 0 -} ^ { x = v1 }
    | {- c == 1 -} ^ { x = v2 }
    )

#+end_src


In this case we will have 
