module Daedalus
 
--- Imports:
 
--- Type defs:
 
--- Rules:
 
Daedalus.joinWords ?a0 ?a1 ?a2 (?a0 + ?a1 = ?a2) (?a1 + ?a0 = ?a2) (_377 : bool) (a : uint ?a0) (b : uint ?a1) : uint ?a2 =
  if _377 then a # b else b # a
 
Daedalus.UInt16 (_378 : bool) : Grammar (uint 16) =
  do (_379 : uint 8) <- GetByte
     (_380 : uint 8) <- GetByte
     pure (Daedalus.joinWords 8 8 16 _378 _379 _380)
 
Daedalus.UInt32 (_381 : bool) : Grammar (uint 32) =
  do (_382 : uint 16) <- Daedalus.UInt16 _381
     (_383 : uint 16) <- Daedalus.UInt16 _381
     pure (Daedalus.joinWords 16 16 32 _381 _382 _383)
 
Daedalus.UInt64 (_384 : bool) : Grammar (uint 64) =
  do (_385 : uint 32) <- Daedalus.UInt32 _384
     (_386 : uint 32) <- Daedalus.UInt32 _384
     pure (Daedalus.joinWords 32 32 64 _384 _385 _386)
 
Daedalus.wordToHalfFloat (w : uint 16) : float =
  let sign = w >> 15 as uint 1 in
  let expo = w >> 10 as uint 5 in
  let mant = w as uint 10 in
  if (expo == 0) then let magic = 126 << 23 in
                      let num = (wordToFloat (magic + (0 # mant))) - (wordToFloat magic) in
                      if (sign == 1) then - num else num else let newExp = if (expo == 31) then 255 else (127 - 15) + (0 # expo) in
                                                              wordToFloat (((sign # newExp) # mant) # 0)
 
Daedalus.HalfFloat (_387 : bool) : Grammar float =
  do (_388 : uint 16) <- Daedalus.UInt16 _387
     pure (Daedalus.wordToHalfFloat _388)
 
Daedalus.Float (_389 : bool) : Grammar float =
  do (_390 : uint 32) <- Daedalus.UInt32 _389
     pure (wordToFloat _390)
 
Daedalus.Double (_391 : bool) : Grammar double =
  do (_392 : uint 64) <- Daedalus.UInt64 _391
     pure (wordToDouble _392)
 
Daedalus.BE16 : Grammar (uint 16) =
  do (_393 : bool) <- pure true
     ($$ : uint 16) <- Daedalus.UInt16 _393
     pure $$
 
Daedalus.BE32 : Grammar (uint 32) =
  do (_395 : bool) <- pure true
     ($$ : uint 32) <- Daedalus.UInt32 _395
     pure $$
 
Daedalus.BE64 : Grammar (uint 64) =
  do (_397 : bool) <- pure true
     ($$ : uint 64) <- Daedalus.UInt64 _397
     pure $$
 
Daedalus.BEHalfFloat : Grammar float =
  do (_399 : bool) <- pure true
     ($$ : float) <- Daedalus.HalfFloat _399
     pure $$
 
Daedalus.BEFloat : Grammar float =
  do (_401 : bool) <- pure true
     ($$ : float) <- Daedalus.Float _401
     pure $$
 
Daedalus.BEDouble : Grammar double =
  do (_403 : bool) <- pure true
     ($$ : double) <- Daedalus.Double _403
     pure $$
 
Daedalus.LE16 : Grammar (uint 16) =
  do (_405 : bool) <- pure false
     ($$ : uint 16) <- Daedalus.UInt16 _405
     pure $$
 
Daedalus.LE32 : Grammar (uint 32) =
  do (_407 : bool) <- pure false
     ($$ : uint 32) <- Daedalus.UInt32 _407
     pure $$
 
Daedalus.LE64 : Grammar (uint 64) =
  do (_409 : bool) <- pure false
     ($$ : uint 64) <- Daedalus.UInt64 _409
     pure $$
 
Daedalus.LEHalfFloat : Grammar float =
  do (_411 : bool) <- pure false
     ($$ : float) <- Daedalus.HalfFloat _411
     pure $$
 
Daedalus.LEFloat : Grammar float =
  do (_413 : bool) <- pure false
     ($$ : float) <- Daedalus.Float _413
     pure $$
 
Daedalus.LEDouble : Grammar double =
  do (_415 : bool) <- pure false
     ($$ : double) <- Daedalus.Double _415
     pure $$
 
Daedalus.Guard (b : bool) : Grammar {} =
  case b is
    { true -> pure {}
    }
 
Daedalus.Only ?a0 (P : Grammar ?a0) : Grammar ?a0 =
  do ($$ : ?a0) <- P
     END
     pure $$
 
Daedalus.SetStreamAt (n : uint 64) (s : Stream) : Grammar {} =
  do (_417 : Stream) <- StreamOff n s
     SetStream _417
 
Daedalus.Skip (n : uint 64) : Grammar {} =
  do (_418 : Stream) <- CurrentStream
     Daedalus.SetStreamAt n _418
 
Daedalus._SetStreamAt (n : uint 64) (s : Stream) : Grammar {} =
  do (_417 : Stream) <- StreamOff n s
     SetStream _417
 
Daedalus.Chunk ?a0 (n : uint 64) (P : Grammar ?a0) : Grammar ?a0 =
  do (s : Stream) <- CurrentStream
     do (_419 : Stream) <- StreamLen n s
        SetStream _419
     ($$ : ?a0) <- P
     Daedalus._SetStreamAt n s
     pure $$
 
Daedalus.Bytes (n : uint 64) : Grammar Stream =
  Daedalus.Chunk Stream n CurrentStream
 
Daedalus.LookAhead ?a0 (P : Grammar ?a0) : Grammar ?a0 =
  do (s : Stream) <- CurrentStream
     ($$ : ?a0) <- P
     SetStream s
     pure $$
 
Daedalus._UInt16 : Grammar {} =
  do @GetByte
     @GetByte
 
Daedalus._UInt32 : Grammar {} =
  do Daedalus._UInt16
     Daedalus._UInt16
 
Daedalus._UInt64 : Grammar {} =
  do Daedalus._UInt32
     Daedalus._UInt32
 
Daedalus._HalfFloat : Grammar {} =
  Daedalus._UInt16
 
Daedalus._Float : Grammar {} =
  Daedalus._UInt32
 
Daedalus._Double : Grammar {} =
  Daedalus._UInt64
 
Daedalus._BE16 : Grammar {} =
  Daedalus._UInt16
 
Daedalus._BE32 : Grammar {} =
  Daedalus._UInt32
 
Daedalus._BE64 : Grammar {} =
  Daedalus._UInt64
 
Daedalus._BEHalfFloat : Grammar {} =
  Daedalus._HalfFloat
 
Daedalus._BEFloat : Grammar {} =
  Daedalus._Float
 
Daedalus._BEDouble : Grammar {} =
  Daedalus._Double
 
Daedalus._LE16 : Grammar {} =
  Daedalus._UInt16
 
Daedalus._LE32 : Grammar {} =
  Daedalus._UInt32
 
Daedalus._LE64 : Grammar {} =
  Daedalus._UInt64
 
Daedalus._LEHalfFloat : Grammar {} =
  Daedalus._HalfFloat
 
Daedalus._LEFloat : Grammar {} =
  Daedalus._Float
 
Daedalus._LEDouble : Grammar {} =
  Daedalus._Double
 
Daedalus._Guard (b : bool) : Grammar {} =
  case b is
    { true -> pure {}
    }
 
Daedalus._Only ?a0 (_P : Grammar {}) : Grammar {} =
  do _P
     END
 
Daedalus._Skip (n : uint 64) : Grammar {} =
  do (_418 : Stream) <- CurrentStream
     Daedalus._SetStreamAt n _418
 
Daedalus._Chunk ?a0 (n : uint 64) (_P : Grammar {}) : Grammar {} =
  do (s : Stream) <- CurrentStream
     do (_419 : Stream) <- StreamLen n s
        SetStream _419
     _P
     Daedalus._SetStreamAt n s
 
Daedalus._Bytes (n : uint 64) : Grammar {} =
  Daedalus._Chunk Stream n (pure {})
 
Daedalus._LookAhead ?a0 (_P : Grammar {}) : Grammar {} =
  do (s : Stream) <- CurrentStream
     _P
     SetStream s
module ICC
 
--- Imports:
import Daedalus
 
--- Type defs:
type ICC.FunOp83 = { tag: [uint 8]
                   ; param: uint 32
                   }
 
type ICC.VersionField = { major: uint 8
                        ; minor: uint 4
                        ; bugfix: uint 4
                        }
 
type ICC.ProfileClass = Choose { multiplex_vis: {}
                               ; multiplex_link: {}
                               ; multiplex_id: {}
                               ; color_encoding_space: {}
                               ; named_color_profile: {}
                               ; abstract_profile: {}
                               ; color_space_profile: {}
                               ; device_link_profile: {}
                               ; output_device_profile: {}
                               ; display_device_profile: {}
                               ; input_device_profile: {}
                               }
 
type ICC.DataColorSpace = Choose { n_channel: uint 16
                                 ; none: {}
                                 ; fifteen_colour: {}
                                 ; fourteen_colour: {}
                                 ; thirteen_colour: {}
                                 ; twelve_colour: {}
                                 ; eleven_colour: {}
                                 ; ten_colour: {}
                                 ; nine_colour: {}
                                 ; eight_colour: {}
                                 ; seven_colour: {}
                                 ; six_colour: {}
                                 ; five_colour: {}
                                 ; four_colour: {}
                                 ; three_colour: {}
                                 ; two_colour: {}
                                 ; cmy: {}
                                 ; cmyk: {}
                                 ; hls: {}
                                 ; hsv: {}
                                 ; gray: {}
                                 ; rgb: {}
                                 ; lms: {}
                                 ; cieyxy: {}
                                 ; ycbcr: {}
                                 ; cieluv: {}
                                 ; cielab_or_pcslab: {}
                                 ; nciexyz_or_pcsxyz: {}
                                 }
 
type ICC.PrimaryPlatform = Choose { none: {}
                                  ; sun_microsystems: {}
                                  ; silicon_graphics_inc: {}
                                  ; microsoft_corporation: {}
                                  ; apple_computer_inc: {}
                                  }
 
type ICC.RenderingIntent = Choose { icc_absolute_colorimetric: {}
                                  ; saturation: {}
                                  ; media_relative_colorimetric: {}
                                  ; perceptual: {}
                                  }
 
type ICC.XYZNumber = { x: uint 32
                     ; y: uint 32
                     ; z: uint 32
                     }
 
type ICC.DateTimeNumber = { year: uint 16
                          ; month: uint 16
                          ; day: uint 16
                          ; hour: uint 16
                          ; minute: uint 16
                          ; second: uint 16
                          }
 
type ICC.ProfileHeader = { size: uint 32
                         ; preferred_cmm_type: [uint 8]
                         ; version: ICC.VersionField
                         ; devce_class: ICC.ProfileClass
                         ; color_space: ICC.DataColorSpace
                         ; pcs: ICC.DataColorSpace
                         ; creation_date_time: ICC.DateTimeNumber
                         ; primary_platform: ICC.PrimaryPlatform
                         ; profile_flags: uint 32
                         ; device_manufacturer: [uint 8]
                         ; device_model: [uint 8]
                         ; device_attributes: uint 64
                         ; rendering_intent: ICC.RenderingIntent
                         ; illuminant: ICC.XYZNumber
                         ; creator: [uint 8]
                         ; identifier: [uint 8]
                         ; reserved_data: [uint 8]
                         }
 
type ICC.LutAToBType = { number_of_input_channels: uint 8
                       ; number_of_output_channels: uint 8
                       ; offset_first_B_curve: uint 32
                       ; offset_to_matrix: uint 32
                       ; offset_to_first_M_curve: uint 32
                       ; offset_to_CLUT: uint 32
                       ; offset_to_first_A_curve: uint 32
                       ; data: Stream
                       }
 
type ICC.MPElementHead = { offset: Stream
                         ; tag: uint 32
                         ; inputs: uint 64
                         ; outputs: uint 64
                         }
 
type ICC.OpParams = { s: uint 64
                    ; t: uint 64
                    }
 
type ICC.FunOp = Choose { unknown: ICC.FunOp83
                        ; opDflt: uint 64
                        ; opCase: uint 64
                        ; opSel: {}
                        ; opElse: uint 64
                        ; opIf: uint 64
                        ; opTXYZ: uint 64
                        ; opTLab: uint 64
                        ; opVOr: uint 64
                        ; opVAnd: uint 64
                        ; opVMax: uint 64
                        ; opVMin: uint 64
                        ; opGT: uint 64
                        ; opGE: uint 64
                        ; opNer: uint 64
                        ; opEQ: uint 64
                        ; opLE: uint 64
                        ; opLT: uint 64
                        ; opRNum: uint 64
                        ; opPToc: uint 64
                        ; opCTop: uint 64
                        ; opATn2: uint 64
                        ; opATan: uint 64
                        ; opACos: uint 64
                        ; opASin: uint 64
                        ; opTan: uint 64
                        ; opCos: uint 64
                        ; opSin: uint 64
                        ; opLn: uint 64
                        ; opLog: uint 64
                        ; opExp: uint 64
                        ; opSign: uint 64
                        ; opTrnc: uint 64
                        ; opCeil: uint 64
                        ; opFlor: uint 64
                        ; opRond: uint 64
                        ; opNeg: uint 64
                        ; opAbs: uint 64
                        ; opCbrt: uint 64
                        ; opCb: uint 64
                        ; opSqrt: uint 64
                        ; opSq: uint 64
                        ; opSDiv: uint 64
                        ; opSMul: uint 64
                        ; opSSub: uint 64
                        ; opSAdd: uint 64
                        ; opGamma: uint 64
                        ; opPow: uint 64
                        ; opMod: uint 64
                        ; opDiv: uint 64
                        ; opMul: uint 64
                        ; opSub: uint 64
                        ; opAdd: uint 64
                        ; opNAN: uint 64
                        ; opNegInf: uint 64
                        ; opPosInf: uint 64
                        ; opPi: uint 64
                        ; or: uint 64
                        ; and: uint 64
                        ; max: uint 64
                        ; min: uint 64
                        ; prod: uint 64
                        ; sum: uint 64
                        ; tran: ICC.OpParams
                        ; solv: ICC.OpParams
                        ; pop: uint 64
                        ; flip: uint 64
                        ; posd: ICC.OpParams
                        ; rotr: ICC.OpParams
                        ; rotl: ICC.OpParams
                        ; copy: ICC.OpParams
                        ; elem: uint 32
                        ; tint: uint 32
                        ; calc: uint 32
                        ; clut: uint 32
                        ; mtx: uint 32
                        ; curv: uint 32
                        ; opEnv: uint 32
                        ; opTSave: ICC.OpParams
                        ; opTPut: ICC.OpParams
                        ; opTGet: ICC.OpParams
                        ; opOut: ICC.OpParams
                        ; opIn: ICC.OpParams
                        ; data: float
                        }
 
type ICC.SingleSampledCurve = { n: uint 32
                              ; f: uint 32
                              ; l: uint 32
                              ; e: uint 16
                              ; ty: uint 16
                              }
 
type ICC.FunParams_g_a_b_c = { g: float
                             ; a: float
                             ; b: float
                             ; c: float
                             }
 
type ICC.FunParams_g_a_b_c_d = { g: float
                               ; a: float
                               ; b: float
                               ; c: float
                               ; d: float
                               }
 
type ICC.FunParams_a_b_c_d_e = { a: float
                               ; b: float
                               ; c: float
                               ; d: float
                               ; e: float
                               }
 
type ICC.FormualCurveSegment = Choose { fun3: ICC.FunParams_g_a_b_c
                                      ; fun2: ICC.FunParams_a_b_c_d_e
                                      ; fun1: ICC.FunParams_g_a_b_c_d
                                      ; fun0: ICC.FunParams_g_a_b_c
                                      }
 
type ICC.CurveSegment = Choose { samf: [float]
                               ; parf: ICC.FormualCurveSegment
                               }
 
type ICC.SegmentedCurve = { breakPoints: [float]
                          ; segements: [ICC.CurveSegment]
                          }
 
type ICC.Curve = Choose { unknown: [uint 8]
                        ; curf: ICC.SegmentedCurve
                        ; sngf: ICC.SingleSampledCurve
                        }
 
type ICC.Matrix = { matrix: [[float]]
                  ; vector: [float]
                  }
 
rec
  type ICC.MPElement = { head: ICC.MPElementHead
                       ; body: ICC.MPElementBody
                       }
   
  type ICC.CalcElement = { inputs: uint 64
                         ; outputs: uint 64
                         ; main: [ICC.FunOp]
                         ; subElements: [ICC.MPElement]
                         }
   
  type ICC.MPElementBody = Choose { calc: ICC.CalcElement
                                  ; cvst: [ICC.Curve]
                                  ; matf: ICC.Matrix
                                  ; unknown: [uint 8]
                                  }
 
type ICC.MultiProcessElementsType = { number_of_input_channels: uint 16
                                    ; number_of_output_channels: uint 16
                                    ; number_of_processing_elements: uint 32
                                    ; elements: [ICC.MPElement]
                                    }
 
type ICC.LutAB_or_multi = Choose { lutAB: ICC.LutAToBType
                                 ; mpe: ICC.MultiProcessElementsType
                                 }
 
type ICC.LutBA_or_multi = Choose { lutBA: ICC.LutAToBType
                                 ; mpe: ICC.MultiProcessElementsType
                                 }
 
type ICC.UnicodeRecord = { language: [uint 8]
                         ; country: [uint 8]
                         ; data: [uint 8]
                         }
 
type ICC.SpectralViewingConditionsType = { colometric_observer: uint 32
                                         }
 
type ICC.Tag = Choose { unknown: [uint 8]
                      ; svcn: ICC.SpectralViewingConditionsType
                      ; s2sp: ICC.MultiProcessElementsType
                      ; c2sp: ICC.MultiProcessElementsType
                      ; cprt: [ICC.UnicodeRecord]
                      ; wtpt: [ICC.XYZNumber]
                      ; B2D3: ICC.MultiProcessElementsType
                      ; B2D2: ICC.MultiProcessElementsType
                      ; B2D1: ICC.MultiProcessElementsType
                      ; B2D0: ICC.MultiProcessElementsType
                      ; B2A3: ICC.LutBA_or_multi
                      ; B2A2: ICC.LutBA_or_multi
                      ; B2A1: ICC.LutBA_or_multi
                      ; B2A0: ICC.LutBA_or_multi
                      ; A2Mo: ICC.MultiProcessElementsType
                      ; A2B3: ICC.LutAB_or_multi
                      ; A2B2: ICC.LutAB_or_multi
                      ; A2B1: ICC.LutAB_or_multi
                      ; A2B0: ICC.LutAB_or_multi
                      ; desc: [ICC.UnicodeRecord]
                      }
 
type ICC.Main = { profileHeader: ICC.ProfileHeader
                ; tags: [ICC.Tag]
                }
 
type ICC.TagEntry = { tag_signature: uint 32
                    ; offset_to_data_element: uint 64
                    ; size_of_data_element: uint 64
                    }
 
type ICC.XYNumber = { x: uint 32
                    ; y: uint 32
                    }
 
type ICC.PositionNumber = { offset: uint 64
                          ; size: uint 64
                          }
 
type ICC.Response16Number = { device: uint 16
                            ; measurement: uint 32
                            }
 
type ICC.Lut8Type = { number_of_input_channels: uint 8
                    ; number_of_output_channels: uint 8
                    ; number_of_clut_grid_points: uint 8
                    ; encoded_e_parameters: [sint 32]
                    ; input_tables: Stream
                    ; clut_values: Stream
                    ; output_tables: Stream
                    }
 
type ICC.Lut16Type = { number_of_input_channels: uint 8
                     ; number_of_output_channels: uint 8
                     ; number_of_clut_grid_points: uint 8
                     ; encoded_e_parameters: [sint 32]
                     ; number_of_input_table_entries: uint 32
                     ; number_of_output_table_entries: uint 32
                     ; input_tables: Stream
                     ; clut_values: Stream
                     ; output_tables: Stream
                     }
 
type ICC.LutBToAType = { number_of_input_channels: uint 8
                       ; number_of_output_channels: uint 8
                       ; offset_first_B_curve: uint 32
                       ; offset_to_matrix: uint 32
                       ; offset_to_first_M_curve: uint 32
                       ; offset_to_CLUT: uint 32
                       ; offset_to_first_A_curve: uint 32
                       ; data: Stream
                       }
 
type ICC.Lut_8_16_AB_BA = Choose { lut16: ICC.Lut16Type
                                 ; lut8: ICC.Lut8Type
                                 ; lutAB: ICC.LutAToBType
                                 ; lutBA: ICC.LutBToAType
                                 }
 
type ICC.Lut_8_16_AB = Choose { lut16: ICC.Lut16Type
                              ; lut8: ICC.Lut8Type
                              ; lutAB: ICC.LutAToBType
                              }
 
type ICC.Lut_8_16_BA = Choose { lut16: ICC.Lut16Type
                              ; lut8: ICC.Lut8Type
                              ; lutBA: ICC.LutBToAType
                              }
 
type ICC.ParametricCurveType = { function: uint 16
                               ; parameters: [uint 32]
                               }
 
type ICC.SomeCurve = Choose { curve: [uint 16]
                            ; parametric_curve: ICC.ParametricCurveType
                            }
 
type ICC.ChromaticityType = { phosphor_or_colorant: uint 16
                            ; cie_coords: [ICC.XYNumber]
                            }
 
type ICC.Colorant = { name: [uint 7]
                    ; pcs: [uint 16]
                    }
 
type ICC.ResponseCurve = { measurement_unit: uint 32
                         ; pcxyzs: [ICC.XYNumber]
                         ; response_arrays: [[ICC.Response16Number]]
                         }
 
type ICC.MeasurementType = { standard_observer: uint 32
                           ; nCIEXYZ: ICC.XYZNumber
                           ; geometry: uint 32
                           ; flare: uint 32
                           ; illuminant: uint 32
                           }
 
type ICC.ColorName = { name_root: [uint 7]
                     ; pcs_coords: [uint 16]
                     ; device_coords: [uint 16]
                     }
 
type ICC.NamedColor2Type = { vendor_specific: uint 32
                           ; prefix: [uint 7]
                           ; suffix: [uint 7]
                           ; names: [ICC.ColorName]
                           }
 
type ICC.ViewConditionsType = { illuminantXYZ: ICC.XYZNumber
                              ; surroundXYZ: ICC.XYZNumber
                              ; illuminant: uint 32
                              }
 
type ICC.TagStructType = { struct_type_id: [uint 8]
                         }
 
type ICC.funOpChecker = { stack: uint 64
                        }
 
--- Rules:
 
ICC.VersionField : Grammar ICC.VersionField =
  do (major : uint 8) <- GetByte
     (min_bf : uint 8) <- GetByte
     (minor : uint 4) <- pure (min_bf >> 4 as uint 4)
     (bugfix : uint 4) <- pure (min_bf as uint 4)
     @MatchBytes [0,
                  0]
     pure {major = major,
           minor = minor,
           bugfix = bugfix}
 
ICC.ProfileClass : Grammar ICC.ProfileClass =
  do (_420 : uint 32) <- Daedalus.BE32
     case _420 is
       { 1935896178 -> pure {input_device_profile: {}}
       ; 1835955314 -> pure {display_device_profile: {}}
       ; 1886549106 -> pure {output_device_profile: {}}
       ; 1818848875 -> pure {device_link_profile: {}}
       ; 1936744803 -> pure {color_space_profile: {}}
       ; 1633842036 -> pure {abstract_profile: {}}
       ; 1852662636 -> pure {named_color_profile: {}}
       ; 1667591779 -> pure {color_encoding_space: {}}
       ; 1835623456 -> pure {multiplex_id: {}}
       ; 1835822699 -> pure {multiplex_link: {}}
       ; 1836476787 -> pure {multiplex_vis: {}}
       }
 
ICC.DataColorSpace : Grammar ICC.DataColorSpace =
  do (tag : uint 32) <- Daedalus.BE32
     ($$ : ICC.DataColorSpace) <- case tag is
                                    { 1482250784 -> pure {nciexyz_or_pcsxyz: {}}
                                    ; 1281450528 -> pure {cielab_or_pcslab: {}}
                                    ; 1282766368 -> pure {cieluv: {}}
                                    ; 1499685490 -> pure {ycbcr: {}}
                                    ; 1501067552 -> pure {cieyxy: {}}
                                    ; 1280135968 -> pure {lms: {}}
                                    ; 1380401696 -> pure {rgb: {}}
                                    ; 1196573017 -> pure {gray: {}}
                                    ; 1213421088 -> pure {hsv: {}}
                                    ; 1212961568 -> pure {hls: {}}
                                    ; 1129142603 -> pure {cmyk: {}}
                                    ; 1129142560 -> pure {cmy: {}}
                                    ; 843271250 -> pure {two_colour: {}}
                                    ; 860048466 -> pure {three_colour: {}}
                                    ; 876825682 -> pure {four_colour: {}}
                                    ; 893602898 -> pure {five_colour: {}}
                                    ; 910380114 -> pure {six_colour: {}}
                                    ; 927157330 -> pure {seven_colour: {}}
                                    ; 943934546 -> pure {eight_colour: {}}
                                    ; 960711762 -> pure {nine_colour: {}}
                                    ; 1094929490 -> pure {ten_colour: {}}
                                    ; 1111706706 -> pure {eleven_colour: {}}
                                    ; 1128483922 -> pure {twelve_colour: {}}
                                    ; 1145261138 -> pure {thirteen_colour: {}}
                                    ; 1162038354 -> pure {fourteen_colour: {}}
                                    ; 1178815570 -> pure {fifteen_colour: {}}
                                    ; 0 -> pure {none: {}}
                                    ; _ -> do Daedalus._Guard ((tag >> 16) == 28261)
                                              ($$ : ICC.DataColorSpace) <- pure {n_channel: (tag as uint 16)}
                                              pure $$
                                    }
     pure $$
 
ICC.PrimaryPlatform : Grammar ICC.PrimaryPlatform =
  do (_423 : uint 32) <- Daedalus.BE32
     case _423 is
       { 1095782476 -> pure {apple_computer_inc: {}}
       ; 1297303124 -> pure {microsoft_corporation: {}}
       ; 1397180704 -> pure {silicon_graphics_inc: {}}
       ; 1398099543 -> pure {sun_microsystems: {}}
       ; 0 -> pure {none: {}}
       }
 
ICC.RenderingIntent : Grammar ICC.RenderingIntent =
  do (_424 : uint 32) <- Daedalus.BE32
     case _424 is
       { 0 -> pure {perceptual: {}}
       ; 1 -> pure {media_relative_colorimetric: {}}
       ; 2 -> pure {saturation: {}}
       ; 3 -> pure {icc_absolute_colorimetric: {}}
       }
 
ICC.XYZNumber : Grammar ICC.XYZNumber =
  do (x : uint 32) <- Daedalus.BE32
     (y : uint 32) <- Daedalus.BE32
     (z : uint 32) <- Daedalus.BE32
     pure {x = x,
           y = y,
           z = z}
 
ICC.DateTimeNumber : Grammar ICC.DateTimeNumber =
  do (year : uint 16) <- Daedalus.BE16
     (month : uint 16) <- Daedalus.BE16
     (day : uint 16) <- Daedalus.BE16
     (hour : uint 16) <- Daedalus.BE16
     (minute : uint 16) <- Daedalus.BE16
     (second : uint 16) <- Daedalus.BE16
     pure {year = year,
           month = month,
           day = day,
           hour = hour,
           minute = minute,
           second = second}
 
ICC.ProfileHeader : Grammar ICC.ProfileHeader =
  do (size : uint 32) <- Daedalus.BE32
     (preferred_cmm_type : [uint 8]) <- Many[4] GetByte
     (version : ICC.VersionField) <- ICC.VersionField
     (devce_class : ICC.ProfileClass) <- ICC.ProfileClass
     (color_space : ICC.DataColorSpace) <- ICC.DataColorSpace
     (pcs : ICC.DataColorSpace) <- ICC.DataColorSpace
     (creation_date_time : ICC.DateTimeNumber) <- ICC.DateTimeNumber
     @MatchBytes "acsp"
     (primary_platform : ICC.PrimaryPlatform) <- ICC.PrimaryPlatform
     (profile_flags : uint 32) <- Daedalus.BE32
     (device_manufacturer : [uint 8]) <- Many[4] GetByte
     (device_model : [uint 8]) <- Many[4] GetByte
     (device_attributes : uint 64) <- Daedalus.BE64
     (rendering_intent : ICC.RenderingIntent) <- ICC.RenderingIntent
     (illuminant : ICC.XYZNumber) <- ICC.XYZNumber
     (creator : [uint 8]) <- Many[4] GetByte
     (identifier : [uint 8]) <- Many[16] GetByte
     (reserved_data : [uint 8]) <- Many[28] GetByte
     pure {size = size,
           preferred_cmm_type = preferred_cmm_type,
           version = version,
           devce_class = devce_class,
           color_space = color_space,
           pcs = pcs,
           creation_date_time = creation_date_time,
           primary_platform = primary_platform,
           profile_flags = profile_flags,
           device_manufacturer = device_manufacturer,
           device_model = device_model,
           device_attributes = device_attributes,
           rendering_intent = rendering_intent,
           illuminant = illuminant,
           creator = creator,
           identifier = identifier,
           reserved_data = reserved_data}
 
ICC.TagEntry : Grammar ICC.TagEntry =
  do (tag_signature : uint 32) <- Daedalus.BE32
     (offset_to_data_element : uint 64) <- do (_425 : uint 32) <- Daedalus.BE32
                                              pure (_425 as uint 64)
     (size_of_data_element : uint 64) <- do (_426 : uint 32) <- Daedalus.BE32
                                            pure (_426 as uint 64)
     pure {tag_signature = tag_signature,
           offset_to_data_element = offset_to_data_element,
           size_of_data_element = size_of_data_element}
 
ICC.TagTable : Grammar [ICC.TagEntry] =
  do (_428 : uint 64) <- do (_427 : uint 32) <- Daedalus.BE32
                            pure (_427 as uint 64)
     Many[_428] ICC.TagEntry
 
ICC._StartTag (x : [uint 8]) : Grammar {} =
  do @MatchBytes x
     @MatchBytes [0,
                  0,
                  0,
                  0]
 
ICC.LutAToBType : Grammar ICC.LutAToBType =
  do ICC._StartTag "mAB "
     (number_of_input_channels : uint 8) <- GetByte
     (number_of_output_channels : uint 8) <- GetByte
     @MatchBytes [0,
                  0]
     (offset_first_B_curve : uint 32) <- Daedalus.BE32
     (offset_to_matrix : uint 32) <- Daedalus.BE32
     (offset_to_first_M_curve : uint 32) <- Daedalus.BE32
     (offset_to_CLUT : uint 32) <- Daedalus.BE32
     (offset_to_first_A_curve : uint 32) <- Daedalus.BE32
     (data : Stream) <- CurrentStream
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           offset_first_B_curve = offset_first_B_curve,
           offset_to_matrix = offset_to_matrix,
           offset_to_first_M_curve = offset_to_first_M_curve,
           offset_to_CLUT = offset_to_CLUT,
           offset_to_first_A_curve = offset_to_first_A_curve,
           data = data}
 
ICC.MPElementHead : Grammar ICC.MPElementHead =
  do (offset : Stream) <- CurrentStream
     (tag : uint 32) <- Daedalus.BE32
     @MatchBytes [0,
                  0,
                  0,
                  0]
     (inputs : uint 64) <- do (_430 : uint 16) <- Daedalus.BE16
                              pure (_430 as uint 64)
     (outputs : uint 64) <- do (_431 : uint 16) <- Daedalus.BE16
                               pure (_431 as uint 64)
     pure {offset = offset,
           tag = tag,
           inputs = inputs,
           outputs = outputs}
 
ICC.Exactly ?a0 (x : ?a0) (P : Grammar ?a0) : Grammar {} =
  Choose biased
    { do (_433 : bool) <- do (_432 : ?a0) <- P
                             pure (_432 == x)
         Daedalus.Guard _433
    | Fail "Unexpected field value"
    }
 
ICC.NoParams : Grammar {} =
  ICC.Exactly (uint 32) 0 Daedalus.BE32
 
ICC._Exactly ?a0 (x : ?a0) (P : Grammar ?a0) : Grammar {} =
  Choose biased
    { do (_433 : bool) <- do (_432 : ?a0) <- P
                             pure (_432 == x)
         Daedalus._Guard _433
    | Fail "Unexpected field value"
    }
 
ICC.OpParam : Grammar (uint 64) =
  do ($$ : uint 64) <- do (_434 : uint 16) <- Daedalus.BE16
                          pure (_434 as uint 64)
     ICC._Exactly (uint 16) 0 Daedalus.BE16
     pure $$
 
ICC.OpParams : Grammar ICC.OpParams =
  do (s : uint 64) <- do (_435 : uint 16) <- Daedalus.BE16
                         pure (_435 as uint 64)
     (t : uint 64) <- do (_436 : uint 16) <- Daedalus.BE16
                         pure (_436 as uint 64)
     pure {s = s,
           t = t}
 
ICC.explode32 (sig : uint 32) : [uint 8] =
  [sig >> 24 as uint 8,
   sig >> 16 as uint 8,
   sig >> 8 as uint 8,
   sig as uint 8]
 
ICC.FunOp : Grammar ICC.FunOp =
  do (tag : uint 32) <- Daedalus.BE32
     ($$ : ICC.FunOp) <- case tag is
                           { 1684108385 -> do (_438 : float) <- Daedalus.BEFloat
                                              pure {data: _438}
                           ; 1768824864 -> do (_439 : ICC.OpParams) <- ICC.OpParams
                                              pure {opIn: _439}
                           ; 1869968416 -> do (_440 : ICC.OpParams) <- ICC.OpParams
                                              pure {opOut: _440}
                           ; 1952933236 -> do (_441 : ICC.OpParams) <- ICC.OpParams
                                              pure {opTGet: _441}
                           ; 1953527156 -> do (_442 : ICC.OpParams) <- ICC.OpParams
                                              pure {opTPut: _442}
                           ; 1953718646 -> do (_443 : ICC.OpParams) <- ICC.OpParams
                                              pure {opTSave: _443}
                           ; 1701738016 -> do (_444 : uint 32) <- Daedalus.BE32
                                              pure {opEnv: _444}
                           ; 1668641398 -> do (_445 : uint 32) <- Daedalus.BE32
                                              pure {curv: _445}
                           ; 1836349472 -> do (_446 : uint 32) <- Daedalus.BE32
                                              pure {mtx: _446}
                           ; 1668052340 -> do (_447 : uint 32) <- Daedalus.BE32
                                              pure {clut: _447}
                           ; 1667329123 -> do (_448 : uint 32) <- Daedalus.BE32
                                              pure {calc: _448}
                           ; 1953066612 -> do (_449 : uint 32) <- Daedalus.BE32
                                              pure {tint: _449}
                           ; 1701602669 -> do (_450 : uint 32) <- Daedalus.BE32
                                              pure {elem: _450}
                           ; 1668247673 -> do (_451 : ICC.OpParams) <- ICC.OpParams
                                              pure {copy: _451}
                           ; 1919906924 -> do (_452 : ICC.OpParams) <- ICC.OpParams
                                              pure {rotl: _452}
                           ; 1919906930 -> do (_453 : ICC.OpParams) <- ICC.OpParams
                                              pure {rotr: _453}
                           ; 1886352228 -> do (_454 : ICC.OpParams) <- ICC.OpParams
                                              pure {posd: _454}
                           ; 1718380912 -> do (_455 : uint 64) <- ICC.OpParam
                                              pure {flip: _455}
                           ; 1886351392 -> do (_456 : uint 64) <- ICC.OpParam
                                              pure {pop: _456}
                           ; 1936682102 -> do (_457 : ICC.OpParams) <- ICC.OpParams
                                              pure {solv: _457}
                           ; 1953653102 -> do (_458 : ICC.OpParams) <- ICC.OpParams
                                              pure {tran: _458}
                           ; 1937075488 -> do (_459 : uint 64) <- ICC.OpParam
                                              pure {sum: _459}
                           ; 1886547812 -> do (_460 : uint 64) <- ICC.OpParam
                                              pure {prod: _460}
                           ; 1835626016 -> do (_461 : uint 64) <- ICC.OpParam
                                              pure {min: _461}
                           ; 1835104288 -> do (_462 : uint 64) <- ICC.OpParam
                                              pure {max: _462}
                           ; 1634624544 -> do (_463 : uint 64) <- ICC.OpParam
                                              pure {and: _463}
                           ; 1869750304 -> do (_464 : uint 64) <- ICC.OpParam
                                              pure {or: _464}
                           ; 1885937696 -> do (_465 : uint 64) <- ICC.OpParam
                                              pure {opPi: _465}
                           ; 726224454 -> do (_466 : uint 64) <- ICC.OpParam
                                             pure {opPosInf: _466}
                           ; 759778886 -> do (_467 : uint 64) <- ICC.OpParam
                                             pure {opNegInf: _467}
                           ; 1312902688 -> do (_468 : uint 64) <- ICC.OpParam
                                              pure {opNAN: _468}
                           ; 1633969184 -> do (_469 : uint 64) <- ICC.OpParam
                                              pure {opAdd: _469}
                           ; 1937072672 -> do (_470 : uint 64) <- ICC.OpParam
                                              pure {opSub: _470}
                           ; 1836411936 -> do (_471 : uint 64) <- ICC.OpParam
                                              pure {opMul: _471}
                           ; 1684633120 -> do (_472 : uint 64) <- ICC.OpParam
                                              pure {opDiv: _472}
                           ; 1836016672 -> do (_473 : uint 64) <- ICC.OpParam
                                              pure {opMod: _473}
                           ; 1886353184 -> do (_474 : uint 64) <- ICC.OpParam
                                              pure {opPow: _474}
                           ; 1734438241 -> do (_475 : uint 64) <- ICC.OpParam
                                              pure {opGamma: _475}
                           ; 1935762532 -> do (_476 : uint 64) <- ICC.OpParam
                                              pure {opSAdd: _476}
                           ; 1936946530 -> do (_477 : uint 64) <- ICC.OpParam
                                              pure {opSSub: _477}
                           ; 1936553324 -> do (_478 : uint 64) <- ICC.OpParam
                                              pure {opSMul: _478}
                           ; 1935960438 -> do (_479 : uint 64) <- ICC.OpParam
                                              pure {opSDiv: _479}
                           ; 1936793632 -> do (_480 : uint 64) <- ICC.OpParam
                                              pure {opSq: _480}
                           ; 1936814708 -> do (_481 : uint 64) <- ICC.OpParam
                                              pure {opSqrt: _481}
                           ; 1667375136 -> do (_482 : uint 64) <- ICC.OpParam
                                              pure {opCb: _482}
                           ; 1667396212 -> do (_483 : uint 64) <- ICC.OpParam
                                              pure {opCbrt: _483}
                           ; 1633841952 -> do (_484 : uint 64) <- ICC.OpParam
                                              pure {opAbs: _484}
                           ; 1852139296 -> do (_485 : uint 64) <- ICC.OpParam
                                              pure {opNeg: _485}
                           ; 1919905380 -> do (_486 : uint 64) <- ICC.OpParam
                                              pure {opRond: _486}
                           ; 1718382450 -> do (_487 : uint 64) <- ICC.OpParam
                                              pure {opFlor: _487}
                           ; 1667590508 -> do (_488 : uint 64) <- ICC.OpParam
                                              pure {opCeil: _488}
                           ; 1953656419 -> do (_489 : uint 64) <- ICC.OpParam
                                              pure {opTrnc: _489}
                           ; 1936287598 -> do (_490 : uint 64) <- ICC.OpParam
                                              pure {opSign: _490}
                           ; 1702391840 -> do (_491 : uint 64) <- ICC.OpParam
                                              pure {opExp: _491}
                           ; 1819240224 -> do (_492 : uint 64) <- ICC.OpParam
                                              pure {opLog: _492}
                           ; 1819156512 -> do (_493 : uint 64) <- ICC.OpParam
                                              pure {opLn: _493}
                           ; 1936289312 -> do (_494 : uint 64) <- ICC.OpParam
                                              pure {opSin: _494}
                           ; 1668248352 -> do (_495 : uint 64) <- ICC.OpParam
                                              pure {opCos: _495}
                           ; 1952542240 -> do (_496 : uint 64) <- ICC.OpParam
                                              pure {opTan: _496}
                           ; 1634953582 -> do (_497 : uint 64) <- ICC.OpParam
                                              pure {opASin: _497}
                           ; 1633906547 -> do (_498 : uint 64) <- ICC.OpParam
                                              pure {opACos: _498}
                           ; 1635017070 -> do (_499 : uint 64) <- ICC.OpParam
                                              pure {opATan: _499}
                           ; 1635020338 -> do (_500 : uint 64) <- ICC.OpParam
                                              pure {opATn2: _500}
                           ; 1668575088 -> do (_501 : uint 64) <- ICC.OpParam
                                              pure {opCTop: _501}
                           ; 1886678883 -> do (_502 : uint 64) <- ICC.OpParam
                                              pure {opPToc: _502}
                           ; 1919841645 -> do (_503 : uint 64) <- ICC.OpParam
                                              pure {opRNum: _503}
                           ; 1819549728 -> do (_504 : uint 64) <- ICC.OpParam
                                              pure {opLT: _504}
                           ; 1818566688 -> do (_505 : uint 64) <- ICC.OpParam
                                              pure {opLE: _505}
                           ; 1701912608 -> do (_506 : uint 64) <- ICC.OpParam
                                              pure {opEQ: _506}
                           ; 1852137842 -> do (_507 : uint 64) <- ICC.OpParam
                                              pure {opNer: _507}
                           ; 1734680608 -> do (_508 : uint 64) <- ICC.OpParam
                                              pure {opGE: _508}
                           ; 1735663648 -> do (_509 : uint 64) <- ICC.OpParam
                                              pure {opGT: _509}
                           ; 1986881902 -> do (_510 : uint 64) <- ICC.OpParam
                                              pure {opVMin: _510}
                           ; 1986879864 -> do (_511 : uint 64) <- ICC.OpParam
                                              pure {opVMax: _511}
                           ; 1986096740 -> do (_512 : uint 64) <- ICC.OpParam
                                              pure {opVAnd: _512}
                           ; 1987015200 -> do (_513 : uint 64) <- ICC.OpParam
                                              pure {opVOr: _513}
                           ; 1951162722 -> do (_514 : uint 64) <- ICC.OpParam
                                              pure {opTLab: _514}
                           ; 1951947098 -> do (_515 : uint 64) <- ICC.OpParam
                                              pure {opTXYZ: _515}
                           ; 1768300576 -> do (_517 : uint 64) <- do (_516 : uint 32) <- Daedalus.BE32
                                                                     pure (_516 as uint 64)
                                              pure {opIf: _517}
                           ; 1701606245 -> do (_519 : uint 64) <- do (_518 : uint 32) <- Daedalus.BE32
                                                                     pure (_518 as uint 64)
                                              pure {opElse: _519}
                           ; 1936026656 -> do (_520 : {}) <- ICC.NoParams
                                              pure {opSel: _520}
                           ; 1667330917 -> do (_522 : uint 64) <- do (_521 : uint 32) <- Daedalus.BE32
                                                                     pure (_521 as uint 64)
                                              pure {opCase: _522}
                           ; 1684434036 -> do (_524 : uint 64) <- do (_523 : uint 32) <- Daedalus.BE32
                                                                     pure (_523 as uint 64)
                                              pure {opDflt: _524}
                           ; _ -> do (_525 : ICC.FunOp83) <- do (tag : [uint 8]) <- pure (ICC.explode32 tag)
                                                                (param : uint 32) <- Daedalus.BE32
                                                                pure {tag = tag,
                                                                      param = param}
                                     pure {unknown: _525}
                           }
     pure $$
 
ICC.CalcFun : Grammar [ICC.FunOp] =
  do ICC._StartTag "func"
     ($$ : [ICC.FunOp]) <- do (_528 : uint 64) <- do (_527 : uint 32) <- Daedalus.BE32
                                                     pure (_527 as uint 64)
                              Many[_528] ICC.FunOp
     pure $$
 
ICC.PositionNumber : Grammar ICC.PositionNumber =
  do (offset : uint 64) <- do (_529 : uint 32) <- Daedalus.BE32
                              pure (_529 as uint 64)
     (size : uint 64) <- do (_530 : uint 32) <- Daedalus.BE32
                            pure (_530 as uint 64)
     pure {offset = offset,
           size = size}
 
ICC.Positioned ?a0 (s : Stream) (P : Grammar ?a0) : Grammar ?a0 =
  do (p : ICC.PositionNumber) <- ICC.PositionNumber
     ($$ : ?a0) <- Daedalus.LookAhead ?a0 do Daedalus._SetStreamAt (p.offset) s
                                             ($$ : ?a0) <- Daedalus.Chunk ?a0 (p.size) P
                                             pure $$
     pure $$
 
ICC.SingleSampledCurve : Grammar ICC.SingleSampledCurve =
  do (n : uint 32) <- Daedalus.BE32
     (f : uint 32) <- Daedalus.BE32
     (l : uint 32) <- Daedalus.BE32
     (e : uint 16) <- Daedalus.BE16
     (ty : uint 16) <- Daedalus.BE16
     pure {n = n,
           f = f,
           l = l,
           e = e,
           ty = ty}
 
ICC.FunParams_g_a_b_c : Grammar ICC.FunParams_g_a_b_c =
  do (g : float) <- Daedalus.BEFloat
     (a : float) <- Daedalus.BEFloat
     (b : float) <- Daedalus.BEFloat
     (c : float) <- Daedalus.BEFloat
     pure {g = g,
           a = a,
           b = b,
           c = c}
 
ICC.FunParams_g_a_b_c_d : Grammar ICC.FunParams_g_a_b_c_d =
  do (g : float) <- Daedalus.BEFloat
     (a : float) <- Daedalus.BEFloat
     (b : float) <- Daedalus.BEFloat
     (c : float) <- Daedalus.BEFloat
     (d : float) <- Daedalus.BEFloat
     pure {g = g,
           a = a,
           b = b,
           c = c,
           d = d}
 
ICC.FunParams_a_b_c_d_e : Grammar ICC.FunParams_a_b_c_d_e =
  do (a : float) <- Daedalus.BEFloat
     (b : float) <- Daedalus.BEFloat
     (c : float) <- Daedalus.BEFloat
     (d : float) <- Daedalus.BEFloat
     (e : float) <- Daedalus.BEFloat
     pure {a = a,
           b = b,
           c = c,
           d = d,
           e = e}
 
ICC.FormualCurveSegment : Grammar ICC.FormualCurveSegment =
  do (fun : uint 16) <- Daedalus.BE16
     do (_534 : bool) <- do (_533 : uint 16) <- Daedalus.BE16
                            pure (_533 == 0)
        Daedalus._Guard _534
     ($$ : ICC.FormualCurveSegment) <- case fun is
                                         { 0 -> do (_536 : ICC.FunParams_g_a_b_c) <- ICC.FunParams_g_a_b_c
                                                   pure {fun0: _536}
                                         ; 1 -> do (_537 : ICC.FunParams_g_a_b_c_d) <- ICC.FunParams_g_a_b_c_d
                                                   pure {fun1: _537}
                                         ; 2 -> do (_538 : ICC.FunParams_a_b_c_d_e) <- ICC.FunParams_a_b_c_d_e
                                                   pure {fun2: _538}
                                         ; 3 -> do (_539 : ICC.FunParams_g_a_b_c) <- ICC.FunParams_g_a_b_c
                                                   pure {fun3: _539}
                                         }
     pure $$
 
ICC.CurveSegment : Grammar ICC.CurveSegment =
  do (tag : uint 32) <- Daedalus.BE32
     ICC._Exactly (uint 32) 0 Daedalus.BE32
     ($$ : ICC.CurveSegment) <- case tag is
                                  { 1885434470 -> do (_541 : ICC.FormualCurveSegment) <- ICC.FormualCurveSegment
                                                     pure {parf: _541}
                                  ; 1935764838 -> do (_544 : [float]) <- do (_543 : uint 64) <- do (_542 : uint 32) <- Daedalus.BE32
                                                                                                   pure (_542 as uint 64)
                                                                            Many[_543] Daedalus.BEFloat
                                                     pure {samf: _544}
                                  }
     pure $$
 
ICC.SegmentedCurve : Grammar ICC.SegmentedCurve =
  do (n : uint 64) <- do (_545 : uint 16) <- Daedalus.BE16
                         pure (_545 as uint 64)
     Choose biased
       { Daedalus._Guard (1 <= n)
       | Fail "Need at least one curve segment"
       }
     ICC._Exactly (uint 16) 0 Daedalus.BE16
     (bnum : uint 64) <- pure (n - 1)
     (breakPoints : [float]) <- Many[bnum] Daedalus.BEFloat
     (segements : [ICC.CurveSegment]) <- Many[n] ICC.CurveSegment
     pure {breakPoints = breakPoints,
           segements = segements}
 
ICC.Curve : Grammar ICC.Curve =
  do (tag : uint 32) <- Daedalus.BE32
     ICC._Exactly (uint 32) 0 Daedalus.BE32
     ($$ : ICC.Curve) <- case tag is
                           { 1936615270 -> do (_547 : ICC.SingleSampledCurve) <- ICC.SingleSampledCurve
                                              pure {sngf: _547}
                           ; 1668641382 -> do (_548 : ICC.SegmentedCurve) <- ICC.SegmentedCurve
                                              pure {curf: _548}
                           ; _ -> pure {unknown: (ICC.explode32 tag)}
                           }
     pure $$
 
ICC.Matrix (p : uint 64) (q : uint 64) : Grammar ICC.Matrix =
  do (matrix : [[float]]) <- Many[q] Many[p] Daedalus.BEFloat
     (vector : [float]) <- Many[q] Daedalus.BEFloat
     pure {matrix = matrix,
           vector = vector}
 
rec value
  ICC.MPElement : Grammar ICC.MPElement =
    do (head : ICC.MPElementHead) <- ICC.MPElementHead
       (body : ICC.MPElementBody) <- ICC.MPElementBody head
       pure {head = head,
             body = body}
   
  ICC.CalcElement (head : ICC.MPElementHead) : Grammar ICC.CalcElement =
    do (subElNum : uint 64) <- do (_549 : uint 32) <- Daedalus.BE32
                                  pure (_549 as uint 64)
       (inputs : uint 64) <- pure (head.inputs)
       (outputs : uint 64) <- pure (head.outputs)
       (main : [ICC.FunOp]) <- ICC.Positioned [ICC.FunOp] (head.offset) ICC.CalcFun
       (subElements : [ICC.MPElement]) <- Many[subElNum] ICC.Positioned ICC.MPElement (head.offset) ICC.MPElement
       pure {inputs = inputs,
             outputs = outputs,
             main = main,
             subElements = subElements}
   
  ICC.MPElementBody (head : ICC.MPElementHead) : Grammar ICC.MPElementBody =
    case head.tag is
      { 1667329123 -> do (_550 : ICC.CalcElement) <- ICC.CalcElement head
                         pure {calc: _550}
      ; 1668707188 -> do (_551 : [ICC.Curve]) <- Many[head.inputs] ICC.Positioned ICC.Curve (head.offset) ICC.Curve
                         pure {cvst: _551}
      ; 1835103334 -> do (_552 : ICC.Matrix) <- ICC.Matrix (head.inputs) (head.outputs)
                         pure {matf: _552}
      ; _ -> pure {unknown: (ICC.explode32 (head.tag))}
      }
 
ICC.MultiProcessElementsType : Grammar ICC.MultiProcessElementsType =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "mpet"
     (number_of_input_channels : uint 16) <- Daedalus.BE16
     (number_of_output_channels : uint 16) <- Daedalus.BE16
     (number_of_processing_elements : uint 32) <- Daedalus.BE32
     (n : uint 64) <- pure (number_of_processing_elements as uint 64)
     Choose biased
       { Daedalus._Guard (1 <= n)
       | Fail "Need at least one MPE"
       }
     (elements : [ICC.MPElement]) <- Many[n] ICC.Positioned ICC.MPElement s ICC.MPElement
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           number_of_processing_elements = number_of_processing_elements,
           elements = elements}
 
ICC.LutAB_or_multi : Grammar ICC.LutAB_or_multi =
  Choose biased
    { {- lutAB -} do (_553 : ICC.LutAToBType) <- ICC.LutAToBType
                     pure {lutAB: _553}
    | {- mpe -} do (_554 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                   pure {mpe: _554}
    }
 
ICC.LutBA_or_multi : Grammar ICC.LutBA_or_multi =
  Choose biased
    { {- lutBA -} do (_555 : ICC.LutAToBType) <- ICC.LutAToBType
                     pure {lutBA: _555}
    | {- mpe -} do (_556 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                   pure {mpe: _556}
    }
 
ICC.UnicodeRecord (s : Stream) : Grammar ICC.UnicodeRecord =
  do (language : [uint 8]) <- Many[2] GetByte
     (country : [uint 8]) <- Many[2] GetByte
     (size : uint 64) <- do (_557 : uint 32) <- Daedalus.BE32
                            pure (_557 as uint 64)
     (offset : uint 64) <- do (_558 : uint 32) <- Daedalus.BE32
                              pure (_558 as uint 64)
     (data : [uint 8]) <- Daedalus.LookAhead [uint 8] do Daedalus._SetStreamAt offset s
                                                         ($$ : [uint 8]) <- Many[size] GetByte
                                                         pure $$
     pure {language = language,
           country = country,
           data = data}
 
ICC.MultiLocalizedUnicodeType : Grammar [ICC.UnicodeRecord] =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "mluc"
     (record_number : uint 32) <- Daedalus.BE32
     ICC._Exactly (uint 32) 12 Daedalus.BE32
     ($$ : [ICC.UnicodeRecord]) <- Many[record_number as uint 64] ICC.UnicodeRecord s
     pure $$
 
ICC.SpectralViewingConditionsType : Grammar ICC.SpectralViewingConditionsType =
  do ICC._StartTag "svcn"
     (colometric_observer : uint 32) <- Daedalus.BE32
     pure {colometric_observer = colometric_observer}
 
ICC.XYZType : Grammar [ICC.XYZNumber] =
  do ICC._StartTag "XYZ "
     ($$ : [ICC.XYZNumber]) <- Many[] ICC.XYZNumber
     pure $$
 
ICC.Tag (sig : uint 32) : Grammar ICC.Tag =
  case sig is
    { 1684370275 -> do (_562 : [ICC.UnicodeRecord]) <- ICC.MultiLocalizedUnicodeType
                       pure {desc: _562}
    ; 1093812784 -> do (_563 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                       pure {A2B0: _563}
    ; 1093812785 -> do (_564 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                       pure {A2B1: _564}
    ; 1093812786 -> do (_565 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                       pure {A2B2: _565}
    ; 1093812787 -> do (_566 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                       pure {A2B3: _566}
    ; 1093815600 -> do (_567 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {A2Mo: _567}
    ; 1110589744 -> do (_568 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                       pure {B2A0: _568}
    ; 1110589745 -> do (_569 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                       pure {B2A1: _569}
    ; 1110589746 -> do (_570 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                       pure {B2A2: _570}
    ; 1110589747 -> do (_571 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                       pure {B2A3: _571}
    ; 1110590512 -> do (_572 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {B2D0: _572}
    ; 1110590513 -> do (_573 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {B2D1: _573}
    ; 1110590514 -> do (_574 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {B2D2: _574}
    ; 1110590515 -> do (_575 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {B2D3: _575}
    ; 2004119668 -> do (_576 : [ICC.XYZNumber]) <- ICC.XYZType
                       pure {wtpt: _576}
    ; 1668313716 -> do (_577 : [ICC.UnicodeRecord]) <- ICC.MultiLocalizedUnicodeType
                       pure {cprt: _577}
    ; 1664250736 -> do (_578 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {c2sp: _578}
    ; 1932682096 -> do (_579 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {s2sp: _579}
    ; 1937138542 -> do (_580 : ICC.SpectralViewingConditionsType) <- ICC.SpectralViewingConditionsType
                       pure {svcn: _580}
    ; _ -> pure {unknown: (ICC.explode32 sig)}
    }
 
ICC.ParseTagIn (s : Stream) (t : ICC.TagEntry) : Grammar ICC.Tag =
  do Daedalus._SetStreamAt (t.offset_to_data_element) s
     ($$ : ICC.Tag) <- Daedalus.Chunk ICC.Tag (t.size_of_data_element) (ICC.Tag (t.tag_signature))
     pure $$
 
ICC.Main : Grammar ICC.Main =
  do (s : Stream) <- CurrentStream
     (profileHeader : ICC.ProfileHeader) <- ICC.ProfileHeader
     (tags : [ICC.Tag]) <- do (_582 : [ICC.TagEntry]) <- ICC.TagTable
                              map ((entry : ICC.TagEntry) in _582)
                                (ICC.ParseTagIn s entry)
     pure {profileHeader = profileHeader,
           tags = tags}
 
ICC.ParseTag (t : ICC.TagEntry) : Grammar ICC.Tag =
  do Daedalus._Skip (t.offset_to_data_element)
     ($$ : ICC.Tag) <- Daedalus.Chunk ICC.Tag (t.size_of_data_element) (ICC.Tag (t.tag_signature))
     pure $$
 
ICC.XYNumber : Grammar ICC.XYNumber =
  do (x : uint 32) <- Daedalus.BE32
     (y : uint 32) <- Daedalus.BE32
     pure {x = x,
           y = y}
 
ICC.ASCII7 : Grammar [uint 7] =
  do ($$ : [uint 7]) <- Many[] do (_584 : uint 8) <- Match (1 .. 255)
                                  _584 AS uint 7
     Choose biased
       { @Many[ 1 .. ] @Match {'\NUL'}
       | Fail "Non 0 string terminator"
       }
     pure $$
 
ICC.Response16Number : Grammar ICC.Response16Number =
  do (device : uint 16) <- Daedalus.BE16
     ICC._Exactly (uint 16) 0 Daedalus.BE16
     (measurement : uint 32) <- Daedalus.BE32
     pure {device = device,
           measurement = measurement}
 
ICC.exp ?a0 ?a1 (Arith ?a0) (Integral ?a1) (Literal 1 ?a1) (Literal 0 ?a1) (Literal 1 ?a0) (b : ?a0) (e : ?a1) : ?a0 =
  for ((x : ?a0) = 1; (i : ?a1) in rangeUp 0 e 1)
    (x * b)
 
ICC.Lut8Type : Grammar ICC.Lut8Type =
  do ICC._StartTag "mft1"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {'\NUL'}
     (encoded_e_parameters : [sint 32]) <- Many[9] do (_585 : uint 32) <- Daedalus.BE32
                                                      pure (_585 as sint 32)
     (input_tables : Stream) <- Daedalus.Bytes (256 * i)
     (clut_values : Stream) <- Daedalus.Bytes ((ICC.exp (uint 64) (uint 64) g i) * o)
     (output_tables : Stream) <- Daedalus.Bytes (256 * o)
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           number_of_clut_grid_points = number_of_clut_grid_points,
           encoded_e_parameters = encoded_e_parameters,
           input_tables = input_tables,
           clut_values = clut_values,
           output_tables = output_tables}
 
ICC.Lut16Type : Grammar ICC.Lut16Type =
  do ICC._StartTag "mft2"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {'\NUL'}
     (encoded_e_parameters : [sint 32]) <- Many[9] do (_586 : uint 32) <- Daedalus.BE32
                                                      pure (_586 as sint 32)
     (number_of_input_table_entries : uint 32) <- Daedalus.BE32
     (n : uint 64) <- pure (number_of_input_table_entries as uint 64)
     (number_of_output_table_entries : uint 32) <- Daedalus.BE32
     (m : uint 64) <- pure (number_of_output_table_entries as uint 64)
     (input_tables : Stream) <- Daedalus.Bytes ((256 * n) * i)
     (clut_values : Stream) <- Daedalus.Bytes ((2 * (ICC.exp (uint 64) (uint 64) g i)) * o)
     (output_tables : Stream) <- Daedalus.Bytes ((2 * m) * o)
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           number_of_clut_grid_points = number_of_clut_grid_points,
           encoded_e_parameters = encoded_e_parameters,
           number_of_input_table_entries = number_of_input_table_entries,
           number_of_output_table_entries = number_of_output_table_entries,
           input_tables = input_tables,
           clut_values = clut_values,
           output_tables = output_tables}
 
ICC.LutBToAType : Grammar ICC.LutBToAType =
  do ICC._StartTag "mBA "
     (number_of_input_channels : uint 8) <- GetByte
     (number_of_output_channels : uint 8) <- GetByte
     @MatchBytes [0,
                  0]
     (offset_first_B_curve : uint 32) <- Daedalus.BE32
     (offset_to_matrix : uint 32) <- Daedalus.BE32
     (offset_to_first_M_curve : uint 32) <- Daedalus.BE32
     (offset_to_CLUT : uint 32) <- Daedalus.BE32
     (offset_to_first_A_curve : uint 32) <- Daedalus.BE32
     (data : Stream) <- CurrentStream
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           offset_first_B_curve = offset_first_B_curve,
           offset_to_matrix = offset_to_matrix,
           offset_to_first_M_curve = offset_to_first_M_curve,
           offset_to_CLUT = offset_to_CLUT,
           offset_to_first_A_curve = offset_to_first_A_curve,
           data = data}
 
ICC.Lut_8_16_AB_BA : Grammar ICC.Lut_8_16_AB_BA =
  Choose biased
    { {- lut8 -} do (_587 : ICC.Lut8Type) <- ICC.Lut8Type
                    pure {lut8: _587}
    | {- lut16 -} do (_588 : ICC.Lut16Type) <- ICC.Lut16Type
                     pure {lut16: _588}
    | {- lutAB -} do (_589 : ICC.LutAToBType) <- ICC.LutAToBType
                     pure {lutAB: _589}
    | {- lutBA -} do (_590 : ICC.LutBToAType) <- ICC.LutBToAType
                     pure {lutBA: _590}
    }
 
ICC.Lut_8_16_AB : Grammar ICC.Lut_8_16_AB =
  Choose biased
    { {- lut8 -} do (_591 : ICC.Lut8Type) <- ICC.Lut8Type
                    pure {lut8: _591}
    | {- lut16 -} do (_592 : ICC.Lut16Type) <- ICC.Lut16Type
                     pure {lut16: _592}
    | {- lutAB -} do (_593 : ICC.LutAToBType) <- ICC.LutAToBType
                     pure {lutAB: _593}
    }
 
ICC.Lut_8_16_BA : Grammar ICC.Lut_8_16_BA =
  Choose biased
    { {- lut8 -} do (_594 : ICC.Lut8Type) <- ICC.Lut8Type
                    pure {lut8: _594}
    | {- lut16 -} do (_595 : ICC.Lut16Type) <- ICC.Lut16Type
                     pure {lut16: _595}
    | {- lutBA -} do (_596 : ICC.LutBToAType) <- ICC.LutBToAType
                     pure {lutBA: _596}
    }
 
ICC.CurveType : Grammar [uint 16] =
  do ICC._StartTag "curv"
     (n : uint 64) <- do (_597 : uint 32) <- Daedalus.BE32
                         pure (_597 as uint 64)
     ($$ : [uint 16]) <- Many[n] Daedalus.BE16
     pure $$
 
ICC.ParametricCurveType : Grammar ICC.ParametricCurveType =
  do ICC._StartTag "para"
     (function : uint 16) <- Daedalus.BE16
     @MatchBytes [0,
                  0]
     (parameters : [uint 32]) <- Many[] Daedalus.BE32
     pure {function = function,
           parameters = parameters}
 
ICC.SomeCurve : Grammar ICC.SomeCurve =
  Choose biased
    { {- curve -} do (_599 : [uint 16]) <- ICC.CurveType
                     pure {curve: _599}
    | {- parametric_curve -} do (_600 : ICC.ParametricCurveType) <- ICC.ParametricCurveType
                                pure {parametric_curve: _600}
    }
 
ICC.StartTag (x : [uint 8]) : Grammar [uint 8] =
  do @MatchBytes x
     ($$ : [uint 8]) <- MatchBytes [0,
                                    0,
                                    0,
                                    0]
     pure $$
 
ICC.DateTimeType : Grammar ICC.DateTimeNumber =
  do ICC._StartTag "dtim"
     ($$ : ICC.DateTimeNumber) <- ICC.DateTimeNumber
     pure $$
 
ICC.TextType : Grammar [uint 7] =
  do ICC._StartTag "text"
     ($$ : [uint 7]) <- Daedalus.Only [uint 7] ICC.ASCII7
     pure $$
 
ICC.SignatureType : Grammar [uint 8] =
  do ICC._StartTag "sig "
     ($$ : [uint 8]) <- Many[4] GetByte
     pure $$
 
ICC.S15Fixed16ArrayType : Grammar [uint 32] =
  do ICC._StartTag "sf32"
     ($$ : [uint 32]) <- Many[] Daedalus.BE32
     pure $$
 
ICC.ChromaticityType : Grammar ICC.ChromaticityType =
  do ICC._StartTag "chrm"
     (number_of_device_channels : uint 64) <- do (_605 : uint 16) <- Daedalus.BE16
                                                 pure (_605 as uint 64)
     (phosphor_or_colorant : uint 16) <- Daedalus.BE16
     (cie_coords : [ICC.XYNumber]) <- Many[number_of_device_channels] ICC.XYNumber
     pure {phosphor_or_colorant = phosphor_or_colorant,
           cie_coords = cie_coords}
 
ICC.ColorantOrderType : Grammar [uint 8] =
  do ICC._StartTag "clro"
     Daedalus._BE32
     ($$ : [uint 8]) <- Many[] GetByte
     pure $$
 
ICC.Colorant : Grammar ICC.Colorant =
  do (name : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (pcs : [uint 16]) <- Many[3] Daedalus.BE16
     pure {name = name,
           pcs = pcs}
 
ICC.ColorantTableType : Grammar [ICC.Colorant] =
  do ICC._StartTag "clrt"
     (count_of_colorant : uint 64) <- do (_607 : uint 32) <- Daedalus.BE32
                                         pure (_607 as uint 64)
     ($$ : [ICC.Colorant]) <- Many[count_of_colorant] ICC.Colorant
     pure $$
 
ICC.ResponseCurve (n : uint 64) : Grammar ICC.ResponseCurve =
  do (measurement_unit : uint 32) <- Daedalus.BE32
     (counts : [uint 32]) <- Many[n] Daedalus.BE32
     (pcxyzs : [ICC.XYNumber]) <- Many[n] ICC.XYNumber
     (response_arrays : [[ICC.Response16Number]]) <- map ((qi : uint 32) in counts)
                                                       (Many[qi as uint 64] ICC.Response16Number)
     pure {measurement_unit = measurement_unit,
           pcxyzs = pcxyzs,
           response_arrays = response_arrays}
 
ICC.ResponseCurveSet16Type : Grammar [ICC.ResponseCurve] =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "rcs2"
     (number_of_channels : uint 64) <- do (_609 : uint 16) <- Daedalus.BE16
                                          pure (_609 as uint 64)
     (count : uint 64) <- do (_610 : uint 16) <- Daedalus.BE16
                             pure (_610 as uint 64)
     ($$ : [ICC.ResponseCurve]) <- Many[count] do (off : uint 64) <- do (_612 : uint 32) <- Daedalus.BE32
                                                                        pure (_612 as uint 64)
                                                  ($$ : ICC.ResponseCurve) <- Daedalus.LookAhead ICC.ResponseCurve do Daedalus._SetStreamAt off s
                                                                                                                      ($$ : ICC.ResponseCurve) <- ICC.ResponseCurve number_of_channels
                                                                                                                      pure $$
                                                  pure $$
     pure $$
 
ICC.MeasurementType : Grammar ICC.MeasurementType =
  do ICC._StartTag "meas"
     (standard_observer : uint 32) <- Daedalus.BE32
     (nCIEXYZ : ICC.XYZNumber) <- ICC.XYZNumber
     (geometry : uint 32) <- Daedalus.BE32
     (flare : uint 32) <- Daedalus.BE32
     (illuminant : uint 32) <- Daedalus.BE32
     pure {standard_observer = standard_observer,
           nCIEXYZ = nCIEXYZ,
           geometry = geometry,
           flare = flare,
           illuminant = illuminant}
 
ICC.ColorName (m : uint 64) : Grammar ICC.ColorName =
  do (name_root : [uint 7]) <- Daedalus.Chunk [uint 7] 32 ICC.ASCII7
     (pcs_coords : [uint 16]) <- Many[3] Daedalus.BE16
     (device_coords : [uint 16]) <- Many[m] Daedalus.BE16
     pure {name_root = name_root,
           pcs_coords = pcs_coords,
           device_coords = device_coords}
 
ICC.NamedColor2Type : Grammar ICC.NamedColor2Type =
  do ICC._StartTag "ncl2"
     (vendor_specific : uint 32) <- Daedalus.BE32
     (count : uint 64) <- do (_615 : uint 32) <- Daedalus.BE32
                             pure (_615 as uint 64)
     (number_of_coords : uint 64) <- do (_616 : uint 32) <- Daedalus.BE32
                                        pure (_616 as uint 64)
     (prefix : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (suffix : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (names : [ICC.ColorName]) <- Many[count] ICC.ColorName number_of_coords
     pure {vendor_specific = vendor_specific,
           prefix = prefix,
           suffix = suffix,
           names = names}
 
ICC.ViewConditionsType : Grammar ICC.ViewConditionsType =
  do ICC._StartTag "view"
     (illuminantXYZ : ICC.XYZNumber) <- ICC.XYZNumber
     (surroundXYZ : ICC.XYZNumber) <- ICC.XYZNumber
     (illuminant : uint 32) <- Daedalus.BE32
     pure {illuminantXYZ = illuminantXYZ,
           surroundXYZ = surroundXYZ,
           illuminant = illuminant}
 
ICC._Positioned ?a0 (s : Stream) (_P : Grammar {}) : Grammar {} =
  do (p : ICC.PositionNumber) <- ICC.PositionNumber
     Daedalus._LookAhead ?a0 do Daedalus._SetStreamAt (p.offset) s
                                Daedalus._Chunk ?a0 (p.size) _P
 
ICC._MPElement : Grammar {} =
  do (head : ICC.MPElementHead) <- ICC.MPElementHead
     ICC.MPElementBody head
     pure {}
 
ICC._MultiProcessElementsType : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "mpet"
     Daedalus._BE16
     Daedalus._BE16
     (number_of_processing_elements : uint 32) <- Daedalus.BE32
     (n : uint 64) <- pure (number_of_processing_elements as uint 64)
     Choose biased
       { Daedalus._Guard (1 <= n)
       | Fail "Need at least one MPE"
       }
     @Many[n] ICC._Positioned ICC.MPElement s ICC._MPElement
 
ICC._LutAToBType : Grammar {} =
  do ICC._StartTag "mAB "
     @GetByte
     @GetByte
     @MatchBytes [0,
                  0]
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
 
ICC._LutAB_or_multi : Grammar {} =
  Choose biased
    { {- lutAB -} ICC._LutAToBType
    | {- mpe -} ICC._MultiProcessElementsType
    }
 
ICC._LutBA_or_multi : Grammar {} =
  Choose biased
    { {- lutBA -} ICC._LutAToBType
    | {- mpe -} ICC._MultiProcessElementsType
    }
 
ICC._UnicodeRecord (s : Stream) : Grammar {} =
  do @Many[2] @GetByte
     @Many[2] @GetByte
     (size : uint 64) <- do (_557 : uint 32) <- Daedalus.BE32
                            pure (_557 as uint 64)
     (offset : uint 64) <- do (_558 : uint 32) <- Daedalus.BE32
                              pure (_558 as uint 64)
     Daedalus._LookAhead [uint 8] do Daedalus._SetStreamAt offset s
                                     @Many[size] @GetByte
 
ICC._MultiLocalizedUnicodeType : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "mluc"
     (record_number : uint 32) <- Daedalus.BE32
     ICC._Exactly (uint 32) 12 Daedalus.BE32
     @Many[record_number as uint 64] ICC._UnicodeRecord s
 
ICC._SpectralViewingConditionsType : Grammar {} =
  do ICC._StartTag "svcn"
     Daedalus._BE32
 
ICC._XYZNumber : Grammar {} =
  do Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
 
ICC._XYZType : Grammar {} =
  do ICC._StartTag "XYZ "
     @Many[] ICC._XYZNumber
 
ICC._Tag (sig : uint 32) : Grammar {} =
  case sig is
    { 1684370275 -> ICC._MultiLocalizedUnicodeType
    ; 1093812784 -> ICC._LutAB_or_multi
    ; 1093812785 -> ICC._LutAB_or_multi
    ; 1093812786 -> ICC._LutAB_or_multi
    ; 1093812787 -> ICC._LutAB_or_multi
    ; 1093815600 -> ICC._MultiProcessElementsType
    ; 1110589744 -> ICC._LutBA_or_multi
    ; 1110589745 -> ICC._LutBA_or_multi
    ; 1110589746 -> ICC._LutBA_or_multi
    ; 1110589747 -> ICC._LutBA_or_multi
    ; 1110590512 -> ICC._MultiProcessElementsType
    ; 1110590513 -> ICC._MultiProcessElementsType
    ; 1110590514 -> ICC._MultiProcessElementsType
    ; 1110590515 -> ICC._MultiProcessElementsType
    ; 2004119668 -> ICC._XYZType
    ; 1668313716 -> ICC._MultiLocalizedUnicodeType
    ; 1664250736 -> ICC._MultiProcessElementsType
    ; 1932682096 -> ICC._MultiProcessElementsType
    ; 1937138542 -> ICC._SpectralViewingConditionsType
    ; _ -> pure {}
    }
 
ICC._ParseTag (t : ICC.TagEntry) : Grammar {} =
  do Daedalus._Skip (t.offset_to_data_element)
     Daedalus._Chunk ICC.Tag (t.size_of_data_element) (ICC._Tag (t.tag_signature))
 
ICC.TagStructType : Grammar ICC.TagStructType =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "tstr"
     (struct_type_id : [uint 8]) <- Many[4] GetByte
     (n : uint 64) <- do (_617 : uint 32) <- Daedalus.BE32
                         pure (_617 as uint 64)
     @Many[n] do (ent : ICC.TagEntry) <- ICC.TagEntry
                 Daedalus._LookAhead ICC.Tag do SetStream s
                                                ICC._ParseTag ent
     pure {struct_type_id = struct_type_id}
 
ICC.funOpChecker : ICC.funOpChecker =
  let stack = 0 in
  {stack = stack}
 
ICC.funOpPush (n : uint 64) (x : ICC.funOpChecker) : ICC.funOpChecker =
  let stack = (x.stack) + n in
  {stack = stack}
 
ICC.FunOpPop (n : uint 64) (x : ICC.funOpChecker) : Grammar ICC.funOpChecker =
  do Daedalus._Guard (n <= (x.stack))
     ($$ : ICC.funOpChecker) <- do (stack : uint 64) <- pure ((x.stack) - n)
                                   pure {stack = stack}
     pure $$
 
ICC.CheckFunOps (c : ICC.CalcElement) : Grammar ICC.funOpChecker =
  for ((calc : ICC.funOpChecker) = ICC.funOpChecker; (i : uint 64), (op : ICC.FunOp) in c.main)
    (case op is
       { {| data = _ |} -> pure (ICC.funOpPush 1 calc)
       ; {| opIn = p |} -> do Choose biased
                                { Daedalus._Guard (if ((p.s) < (c.inputs)) then ((c.inputs) - (p.s)) <= (p.t) else false)
                                | Fail "Invalid channel in `in`"
                                }
                              ($$ : ICC.funOpChecker) <- pure (ICC.funOpPush (p.t) calc)
                              pure $$
       ; {| opOut = p |} -> do Choose biased
                                 { Daedalus._Guard (if ((p.s) < (c.outputs)) then ((c.outputs) - (p.s)) <= (p.t) else false)
                                 | Fail "Invalid channel in `out`"
                                 }
                               ($$ : ICC.funOpChecker) <- ICC.FunOpPop (p.t) calc
                               pure $$
       ; {| opTGet = p |} -> pure (ICC.funOpPush (p.t) calc)
       ; {| opTPut = p |} -> ICC.FunOpPop (p.t) calc
       ; {| opTSave = p |} -> do Choose biased
                                   { Daedalus._Guard ((p.t) <= (calc.stack))
                                   | Fail "Not enough arguments to `tsav`"
                                   }
                                 ($$ : ICC.funOpChecker) <- pure calc
                                 pure $$
       ; {| opEnv = _ |} -> pure (ICC.funOpPush 2 calc)
       ; {| curv = n |} -> do (mpe : ICC.MPElement) <- Index (c.subElements) (n as uint 64)
                              case mpe.body is
                                { {| cvst = _624 |} -> pure {}
                                }
                              (h : ICC.MPElementHead) <- pure (mpe.head)
                              ($$ : ICC.funOpChecker) <- do (_626 : ICC.funOpChecker) <- ICC.FunOpPop (h.inputs) calc
                                                            pure (ICC.funOpPush (h.outputs) _626)
                              pure $$
       ; {| mtx = n |} -> do (mpe : ICC.MPElement) <- Index (c.subElements) (n as uint 64)
                             case mpe.body is
                               { {| matf = _627 |} -> pure {}
                               }
                             (h : ICC.MPElementHead) <- pure (mpe.head)
                             ($$ : ICC.funOpChecker) <- do (_629 : ICC.funOpChecker) <- ICC.FunOpPop (h.inputs) calc
                                                           pure (ICC.funOpPush (h.outputs) _629)
                             pure $$
       ; {| clut = n |} -> do (mpe : ICC.MPElement) <- Index (c.subElements) (n as uint 64)
                              (h : ICC.MPElementHead) <- pure (mpe.head)
                              ($$ : ICC.funOpChecker) <- do (_631 : ICC.funOpChecker) <- ICC.FunOpPop (h.inputs) calc
                                                            pure (ICC.funOpPush (h.outputs) _631)
                              pure $$
       ; {| calc = n |} -> do (mpe : ICC.MPElement) <- Index (c.subElements) (n as uint 64)
                              case mpe.body is
                                { {| calc = _632 |} -> pure {}
                                }
                              (h : ICC.MPElementHead) <- pure (mpe.head)
                              ($$ : ICC.funOpChecker) <- do (_634 : ICC.funOpChecker) <- ICC.FunOpPop (h.inputs) calc
                                                            pure (ICC.funOpPush (h.outputs) _634)
                              pure $$
       ; {| tint = n |} -> do (mpe : ICC.MPElement) <- Index (c.subElements) (n as uint 64)
                              (h : ICC.MPElementHead) <- pure (mpe.head)
                              ($$ : ICC.funOpChecker) <- do (_636 : ICC.funOpChecker) <- ICC.FunOpPop (h.inputs) calc
                                                            pure (ICC.funOpPush (h.outputs) _636)
                              pure $$
       ; {| elem = n |} -> do (mpe : ICC.MPElement) <- Index (c.subElements) (n as uint 64)
                              (h : ICC.MPElementHead) <- pure (mpe.head)
                              ($$ : ICC.funOpChecker) <- do (_638 : ICC.funOpChecker) <- ICC.FunOpPop (h.inputs) calc
                                                            pure (ICC.funOpPush (h.outputs) _638)
                              pure $$
       ; {| copy = p |} -> do Choose biased
                                { Daedalus._Guard ((p.s) <= (calc.stack))
                                | Fail "Not enough arguments to `copy`"
                                }
                              ($$ : ICC.funOpChecker) <- pure (ICC.funOpPush (((p.t) + 1) * (p.s)) calc)
                              pure $$
       ; {| rotl = p |} -> do Choose biased
                                { Daedalus._Guard ((p.s) <= (calc.stack))
                                | Fail "Not enough arguments to `rotl`"
                                }
                              ($$ : ICC.funOpChecker) <- pure calc
                              pure $$
       ; {| rotr = p |} -> do Choose biased
                                { Daedalus._Guard ((p.s) <= (calc.stack))
                                | Fail "Not enough arguments to `rotr`"
                                }
                              ($$ : ICC.funOpChecker) <- pure calc
                              pure $$
       ; {| posd = p |} -> do Choose biased
                                { Daedalus._Guard ((p.s) < (calc.stack))
                                | Fail "Invalid argument for `posd`"
                                }
                              ($$ : ICC.funOpChecker) <- pure (ICC.funOpPush ((p.t) + 1) calc)
                              pure $$
       ; {| flip = s |} -> do Choose biased
                                { Daedalus._Guard (s <= (calc.stack))
                                | Fail "Invalid argument for `flip`"
                                }
                              ($$ : ICC.funOpChecker) <- pure calc
                              pure $$
       ; {| pop = s |} -> do ($$ : ICC.funOpChecker) <- ICC.FunOpPop (s + 1) calc
                             pure $$
       })
 
ICC.ChunkRelativeTo (s : Stream) (off : uint 64) (sz : uint 64) : Grammar Stream =
  do Daedalus._SetStreamAt off s
     ($$ : Stream) <- Daedalus.Bytes sz
     pure $$
 
ICC._VersionField : Grammar {} =
  do @GetByte
     @GetByte
     @MatchBytes [0,
                  0]
 
ICC._ProfileClass : Grammar {} =
  do (_420 : uint 32) <- Daedalus.BE32
     case _420 is
       { 1935896178 -> pure {}
       ; 1835955314 -> pure {}
       ; 1886549106 -> pure {}
       ; 1818848875 -> pure {}
       ; 1936744803 -> pure {}
       ; 1633842036 -> pure {}
       ; 1852662636 -> pure {}
       ; 1667591779 -> pure {}
       ; 1835623456 -> pure {}
       ; 1835822699 -> pure {}
       ; 1836476787 -> pure {}
       }
 
ICC._DataColorSpace : Grammar {} =
  do (tag : uint 32) <- Daedalus.BE32
     case tag is
       { 1482250784 -> pure {}
       ; 1281450528 -> pure {}
       ; 1282766368 -> pure {}
       ; 1499685490 -> pure {}
       ; 1501067552 -> pure {}
       ; 1280135968 -> pure {}
       ; 1380401696 -> pure {}
       ; 1196573017 -> pure {}
       ; 1213421088 -> pure {}
       ; 1212961568 -> pure {}
       ; 1129142603 -> pure {}
       ; 1129142560 -> pure {}
       ; 843271250 -> pure {}
       ; 860048466 -> pure {}
       ; 876825682 -> pure {}
       ; 893602898 -> pure {}
       ; 910380114 -> pure {}
       ; 927157330 -> pure {}
       ; 943934546 -> pure {}
       ; 960711762 -> pure {}
       ; 1094929490 -> pure {}
       ; 1111706706 -> pure {}
       ; 1128483922 -> pure {}
       ; 1145261138 -> pure {}
       ; 1162038354 -> pure {}
       ; 1178815570 -> pure {}
       ; 0 -> pure {}
       ; _ -> Daedalus._Guard ((tag >> 16) == 28261)
       }
 
ICC._PrimaryPlatform : Grammar {} =
  do (_423 : uint 32) <- Daedalus.BE32
     case _423 is
       { 1095782476 -> pure {}
       ; 1297303124 -> pure {}
       ; 1397180704 -> pure {}
       ; 1398099543 -> pure {}
       ; 0 -> pure {}
       }
 
ICC._RenderingIntent : Grammar {} =
  do (_424 : uint 32) <- Daedalus.BE32
     case _424 is
       { 0 -> pure {}
       ; 1 -> pure {}
       ; 2 -> pure {}
       ; 3 -> pure {}
       }
 
ICC._DateTimeNumber : Grammar {} =
  do Daedalus._BE16
     Daedalus._BE16
     Daedalus._BE16
     Daedalus._BE16
     Daedalus._BE16
     Daedalus._BE16
 
ICC._ProfileHeader : Grammar {} =
  do Daedalus._BE32
     @Many[4] @GetByte
     ICC._VersionField
     ICC._ProfileClass
     ICC._DataColorSpace
     ICC._DataColorSpace
     ICC._DateTimeNumber
     @MatchBytes "acsp"
     ICC._PrimaryPlatform
     Daedalus._BE32
     @Many[4] @GetByte
     @Many[4] @GetByte
     Daedalus._BE64
     ICC._RenderingIntent
     ICC._XYZNumber
     @Many[4] @GetByte
     @Many[16] @GetByte
     @Many[28] @GetByte
 
ICC._TagEntry : Grammar {} =
  do Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
 
ICC._TagTable : Grammar {} =
  do (_428 : uint 64) <- do (_427 : uint 32) <- Daedalus.BE32
                            pure (_427 as uint 64)
     @Many[_428] ICC._TagEntry
 
ICC._MPElementHead : Grammar {} =
  do Daedalus._BE32
     @MatchBytes [0,
                  0,
                  0,
                  0]
     Daedalus._BE16
     Daedalus._BE16
 
ICC._NoParams : Grammar {} =
  ICC._Exactly (uint 32) 0 Daedalus.BE32
 
ICC._OpParam : Grammar {} =
  do Daedalus._BE16
     ICC._Exactly (uint 16) 0 Daedalus.BE16
 
ICC._OpParams : Grammar {} =
  do Daedalus._BE16
     Daedalus._BE16
 
ICC._FunOp : Grammar {} =
  do (tag : uint 32) <- Daedalus.BE32
     case tag is
       { 1684108385 -> Daedalus._BEFloat
       ; 1768824864 -> ICC._OpParams
       ; 1869968416 -> ICC._OpParams
       ; 1952933236 -> ICC._OpParams
       ; 1953527156 -> ICC._OpParams
       ; 1953718646 -> ICC._OpParams
       ; 1701738016 -> Daedalus._BE32
       ; 1668641398 -> Daedalus._BE32
       ; 1836349472 -> Daedalus._BE32
       ; 1668052340 -> Daedalus._BE32
       ; 1667329123 -> Daedalus._BE32
       ; 1953066612 -> Daedalus._BE32
       ; 1701602669 -> Daedalus._BE32
       ; 1668247673 -> ICC._OpParams
       ; 1919906924 -> ICC._OpParams
       ; 1919906930 -> ICC._OpParams
       ; 1886352228 -> ICC._OpParams
       ; 1718380912 -> ICC._OpParam
       ; 1886351392 -> ICC._OpParam
       ; 1936682102 -> ICC._OpParams
       ; 1953653102 -> ICC._OpParams
       ; 1937075488 -> ICC._OpParam
       ; 1886547812 -> ICC._OpParam
       ; 1835626016 -> ICC._OpParam
       ; 1835104288 -> ICC._OpParam
       ; 1634624544 -> ICC._OpParam
       ; 1869750304 -> ICC._OpParam
       ; 1885937696 -> ICC._OpParam
       ; 726224454 -> ICC._OpParam
       ; 759778886 -> ICC._OpParam
       ; 1312902688 -> ICC._OpParam
       ; 1633969184 -> ICC._OpParam
       ; 1937072672 -> ICC._OpParam
       ; 1836411936 -> ICC._OpParam
       ; 1684633120 -> ICC._OpParam
       ; 1836016672 -> ICC._OpParam
       ; 1886353184 -> ICC._OpParam
       ; 1734438241 -> ICC._OpParam
       ; 1935762532 -> ICC._OpParam
       ; 1936946530 -> ICC._OpParam
       ; 1936553324 -> ICC._OpParam
       ; 1935960438 -> ICC._OpParam
       ; 1936793632 -> ICC._OpParam
       ; 1936814708 -> ICC._OpParam
       ; 1667375136 -> ICC._OpParam
       ; 1667396212 -> ICC._OpParam
       ; 1633841952 -> ICC._OpParam
       ; 1852139296 -> ICC._OpParam
       ; 1919905380 -> ICC._OpParam
       ; 1718382450 -> ICC._OpParam
       ; 1667590508 -> ICC._OpParam
       ; 1953656419 -> ICC._OpParam
       ; 1936287598 -> ICC._OpParam
       ; 1702391840 -> ICC._OpParam
       ; 1819240224 -> ICC._OpParam
       ; 1819156512 -> ICC._OpParam
       ; 1936289312 -> ICC._OpParam
       ; 1668248352 -> ICC._OpParam
       ; 1952542240 -> ICC._OpParam
       ; 1634953582 -> ICC._OpParam
       ; 1633906547 -> ICC._OpParam
       ; 1635017070 -> ICC._OpParam
       ; 1635020338 -> ICC._OpParam
       ; 1668575088 -> ICC._OpParam
       ; 1886678883 -> ICC._OpParam
       ; 1919841645 -> ICC._OpParam
       ; 1819549728 -> ICC._OpParam
       ; 1818566688 -> ICC._OpParam
       ; 1701912608 -> ICC._OpParam
       ; 1852137842 -> ICC._OpParam
       ; 1734680608 -> ICC._OpParam
       ; 1735663648 -> ICC._OpParam
       ; 1986881902 -> ICC._OpParam
       ; 1986879864 -> ICC._OpParam
       ; 1986096740 -> ICC._OpParam
       ; 1987015200 -> ICC._OpParam
       ; 1951162722 -> ICC._OpParam
       ; 1951947098 -> ICC._OpParam
       ; 1768300576 -> Daedalus._BE32
       ; 1701606245 -> Daedalus._BE32
       ; 1936026656 -> ICC._NoParams
       ; 1667330917 -> Daedalus._BE32
       ; 1684434036 -> Daedalus._BE32
       ; _ -> Daedalus._BE32
       }
 
ICC._CalcFun : Grammar {} =
  do ICC._StartTag "func"
     (_528 : uint 64) <- do (_527 : uint 32) <- Daedalus.BE32
                            pure (_527 as uint 64)
     @Many[_528] ICC._FunOp
 
ICC._PositionNumber : Grammar {} =
  do Daedalus._BE32
     Daedalus._BE32
 
ICC._SingleSampledCurve : Grammar {} =
  do Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE16
     Daedalus._BE16
 
ICC._FunParams_g_a_b_c : Grammar {} =
  do Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
 
ICC._FunParams_g_a_b_c_d : Grammar {} =
  do Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
 
ICC._FunParams_a_b_c_d_e : Grammar {} =
  do Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
 
ICC._FormualCurveSegment : Grammar {} =
  do (fun : uint 16) <- Daedalus.BE16
     do (_534 : bool) <- do (_533 : uint 16) <- Daedalus.BE16
                            pure (_533 == 0)
        Daedalus._Guard _534
     case fun is
       { 0 -> ICC._FunParams_g_a_b_c
       ; 1 -> ICC._FunParams_g_a_b_c_d
       ; 2 -> ICC._FunParams_a_b_c_d_e
       ; 3 -> ICC._FunParams_g_a_b_c
       }
 
ICC._CurveSegment : Grammar {} =
  do (tag : uint 32) <- Daedalus.BE32
     ICC._Exactly (uint 32) 0 Daedalus.BE32
     case tag is
       { 1885434470 -> ICC._FormualCurveSegment
       ; 1935764838 -> do (_543 : uint 64) <- do (_542 : uint 32) <- Daedalus.BE32
                                                 pure (_542 as uint 64)
                          @Many[_543] Daedalus._BEFloat
       }
 
ICC._SegmentedCurve : Grammar {} =
  do (n : uint 64) <- do (_545 : uint 16) <- Daedalus.BE16
                         pure (_545 as uint 64)
     Choose biased
       { Daedalus._Guard (1 <= n)
       | Fail "Need at least one curve segment"
       }
     ICC._Exactly (uint 16) 0 Daedalus.BE16
     (bnum : uint 64) <- pure (n - 1)
     @Many[bnum] Daedalus._BEFloat
     @Many[n] ICC._CurveSegment
 
ICC._Curve : Grammar {} =
  do (tag : uint 32) <- Daedalus.BE32
     ICC._Exactly (uint 32) 0 Daedalus.BE32
     case tag is
       { 1936615270 -> ICC._SingleSampledCurve
       ; 1668641382 -> ICC._SegmentedCurve
       ; _ -> pure {}
       }
 
ICC._Matrix (p : uint 64) (q : uint 64) : Grammar {} =
  do @Many[q] @Many[p] Daedalus._BEFloat
     @Many[q] Daedalus._BEFloat
 
ICC._CalcElement (head : ICC.MPElementHead) : Grammar {} =
  do (subElNum : uint 64) <- do (_549 : uint 32) <- Daedalus.BE32
                                pure (_549 as uint 64)
     ICC._Positioned [ICC.FunOp] (head.offset) ICC._CalcFun
     @Many[subElNum] ICC._Positioned ICC.MPElement (head.offset) ICC._MPElement
 
ICC._MPElementBody (head : ICC.MPElementHead) : Grammar {} =
  case head.tag is
    { 1667329123 -> ICC._CalcElement head
    ; 1668707188 -> @Many[head.inputs] ICC._Positioned ICC.Curve (head.offset) ICC._Curve
    ; 1835103334 -> ICC._Matrix (head.inputs) (head.outputs)
    ; _ -> pure {}
    }
 
ICC._ParseTagIn (s : Stream) (t : ICC.TagEntry) : Grammar {} =
  do Daedalus._SetStreamAt (t.offset_to_data_element) s
     Daedalus._Chunk ICC.Tag (t.size_of_data_element) (ICC._Tag (t.tag_signature))
 
ICC._Main : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._ProfileHeader
     (_582 : [ICC.TagEntry]) <- ICC.TagTable
     map ((entry : ICC.TagEntry) in _582)
       (ICC.ParseTagIn s entry)
     pure {}
 
ICC._XYNumber : Grammar {} =
  do Daedalus._BE32
     Daedalus._BE32
 
ICC._ASCII7 : Grammar {} =
  do @Many[] do (_584 : uint 8) <- Match (1 .. 255)
                @(_584 AS uint 7)
     Choose biased
       { @Many[ 1 .. ] @Match {'\NUL'}
       | Fail "Non 0 string terminator"
       }
 
ICC._Response16Number : Grammar {} =
  do Daedalus._BE16
     ICC._Exactly (uint 16) 0 Daedalus.BE16
     Daedalus._BE32
 
ICC._Lut8Type : Grammar {} =
  do ICC._StartTag "mft1"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {'\NUL'}
     @Many[9] Daedalus._BE32
     Daedalus._Bytes (256 * i)
     Daedalus._Bytes ((ICC.exp (uint 64) (uint 64) g i) * o)
     Daedalus._Bytes (256 * o)
 
ICC._Lut16Type : Grammar {} =
  do ICC._StartTag "mft2"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {'\NUL'}
     @Many[9] Daedalus._BE32
     (number_of_input_table_entries : uint 32) <- Daedalus.BE32
     (n : uint 64) <- pure (number_of_input_table_entries as uint 64)
     (number_of_output_table_entries : uint 32) <- Daedalus.BE32
     (m : uint 64) <- pure (number_of_output_table_entries as uint 64)
     Daedalus._Bytes ((256 * n) * i)
     Daedalus._Bytes ((2 * (ICC.exp (uint 64) (uint 64) g i)) * o)
     Daedalus._Bytes ((2 * m) * o)
 
ICC._LutBToAType : Grammar {} =
  do ICC._StartTag "mBA "
     @GetByte
     @GetByte
     @MatchBytes [0,
                  0]
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
 
ICC._Lut_8_16_AB_BA : Grammar {} =
  Choose biased
    { {- lut8 -} ICC._Lut8Type
    | {- lut16 -} ICC._Lut16Type
    | {- lutAB -} ICC._LutAToBType
    | {- lutBA -} ICC._LutBToAType
    }
 
ICC._Lut_8_16_AB : Grammar {} =
  Choose biased
    { {- lut8 -} ICC._Lut8Type
    | {- lut16 -} ICC._Lut16Type
    | {- lutAB -} ICC._LutAToBType
    }
 
ICC._Lut_8_16_BA : Grammar {} =
  Choose biased
    { {- lut8 -} ICC._Lut8Type
    | {- lut16 -} ICC._Lut16Type
    | {- lutBA -} ICC._LutBToAType
    }
 
ICC._CurveType : Grammar {} =
  do ICC._StartTag "curv"
     (n : uint 64) <- do (_597 : uint 32) <- Daedalus.BE32
                         pure (_597 as uint 64)
     @Many[n] Daedalus._BE16
 
ICC._ParametricCurveType : Grammar {} =
  do ICC._StartTag "para"
     Daedalus._BE16
     @MatchBytes [0,
                  0]
     @Many[] Daedalus._BE32
 
ICC._SomeCurve : Grammar {} =
  Choose biased
    { {- curve -} ICC._CurveType
    | {- parametric_curve -} ICC._ParametricCurveType
    }
 
ICC._DateTimeType : Grammar {} =
  do ICC._StartTag "dtim"
     ICC._DateTimeNumber
 
ICC._TextType : Grammar {} =
  do ICC._StartTag "text"
     Daedalus._Only [uint 7] ICC._ASCII7
 
ICC._SignatureType : Grammar {} =
  do ICC._StartTag "sig "
     @Many[4] @GetByte
 
ICC._S15Fixed16ArrayType : Grammar {} =
  do ICC._StartTag "sf32"
     @Many[] Daedalus._BE32
 
ICC._ChromaticityType : Grammar {} =
  do ICC._StartTag "chrm"
     (number_of_device_channels : uint 64) <- do (_605 : uint 16) <- Daedalus.BE16
                                                 pure (_605 as uint 64)
     Daedalus._BE16
     @Many[number_of_device_channels] ICC._XYNumber
 
ICC._ColorantOrderType : Grammar {} =
  do ICC._StartTag "clro"
     Daedalus._BE32
     @Many[] @GetByte
 
ICC._Colorant : Grammar {} =
  do Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     @Many[3] Daedalus._BE16
 
ICC._ColorantTableType : Grammar {} =
  do ICC._StartTag "clrt"
     (count_of_colorant : uint 64) <- do (_607 : uint 32) <- Daedalus.BE32
                                         pure (_607 as uint 64)
     @Many[count_of_colorant] ICC._Colorant
 
ICC._ResponseCurve (n : uint 64) : Grammar {} =
  do Daedalus._BE32
     (counts : [uint 32]) <- Many[n] Daedalus.BE32
     @Many[n] ICC._XYNumber
     map ((qi : uint 32) in counts)
       (Many[qi as uint 64] ICC.Response16Number)
     pure {}
 
ICC._ResponseCurveSet16Type : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "rcs2"
     (number_of_channels : uint 64) <- do (_609 : uint 16) <- Daedalus.BE16
                                          pure (_609 as uint 64)
     (count : uint 64) <- do (_610 : uint 16) <- Daedalus.BE16
                             pure (_610 as uint 64)
     @Many[count] do (off : uint 64) <- do (_612 : uint 32) <- Daedalus.BE32
                                           pure (_612 as uint 64)
                     Daedalus._LookAhead ICC.ResponseCurve do Daedalus._SetStreamAt off s
                                                              ICC._ResponseCurve number_of_channels
 
ICC._MeasurementType : Grammar {} =
  do ICC._StartTag "meas"
     Daedalus._BE32
     ICC._XYZNumber
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
 
ICC._ColorName (m : uint 64) : Grammar {} =
  do Daedalus._Chunk [uint 7] 32 ICC._ASCII7
     @Many[3] Daedalus._BE16
     @Many[m] Daedalus._BE16
 
ICC._NamedColor2Type : Grammar {} =
  do ICC._StartTag "ncl2"
     Daedalus._BE32
     (count : uint 64) <- do (_615 : uint 32) <- Daedalus.BE32
                             pure (_615 as uint 64)
     (number_of_coords : uint 64) <- do (_616 : uint 32) <- Daedalus.BE32
                                        pure (_616 as uint 64)
     Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     @Many[count] ICC._ColorName number_of_coords
 
ICC._ViewConditionsType : Grammar {} =
  do ICC._StartTag "view"
     ICC._XYZNumber
     ICC._XYZNumber
     Daedalus._BE32
 
ICC._TagStructType : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "tstr"
     @Many[4] @GetByte
     (n : uint 64) <- do (_617 : uint 32) <- Daedalus.BE32
                         pure (_617 as uint 64)
     @Many[n] do (ent : ICC.TagEntry) <- ICC.TagEntry
                 Daedalus._LookAhead ICC.Tag do SetStream s
                                                ICC._ParseTag ent
 
ICC._FunOpPop (n : uint 64) (x : ICC.funOpChecker) : Grammar {} =
  Daedalus._Guard (n <= (x.stack))
 
ICC._CheckFunOps (c : ICC.CalcElement) : Grammar {} =
  do for ((calc : ICC.funOpChecker) = ICC.funOpChecker; (i : uint 64), (op : ICC.FunOp) in c.main)
       (case op is
          { {| data = _ |} -> pure (ICC.funOpPush 1 calc)
          ; {| opIn = p |} -> do Choose biased
                                   { Daedalus._Guard (if ((p.s) < (c.inputs)) then ((c.inputs) - (p.s)) <= (p.t) else false)
                                   | Fail "Invalid channel in `in`"
                                   }
                                 ($$ : ICC.funOpChecker) <- pure (ICC.funOpPush (p.t) calc)
                                 pure $$
          ; {| opOut = p |} -> do Choose biased
                                    { Daedalus._Guard (if ((p.s) < (c.outputs)) then ((c.outputs) - (p.s)) <= (p.t) else false)
                                    | Fail "Invalid channel in `out`"
                                    }
                                  ($$ : ICC.funOpChecker) <- ICC.FunOpPop (p.t) calc
                                  pure $$
          ; {| opTGet = p |} -> pure (ICC.funOpPush (p.t) calc)
          ; {| opTPut = p |} -> ICC.FunOpPop (p.t) calc
          ; {| opTSave = p |} -> do Choose biased
                                      { Daedalus._Guard ((p.t) <= (calc.stack))
                                      | Fail "Not enough arguments to `tsav`"
                                      }
                                    ($$ : ICC.funOpChecker) <- pure calc
                                    pure $$
          ; {| opEnv = _ |} -> pure (ICC.funOpPush 2 calc)
          ; {| curv = n |} -> do (mpe : ICC.MPElement) <- Index (c.subElements) (n as uint 64)
                                 case mpe.body is
                                   { {| cvst = _624 |} -> pure {}
                                   }
                                 (h : ICC.MPElementHead) <- pure (mpe.head)
                                 ($$ : ICC.funOpChecker) <- do (_626 : ICC.funOpChecker) <- ICC.FunOpPop (h.inputs) calc
                                                               pure (ICC.funOpPush (h.outputs) _626)
                                 pure $$
          ; {| mtx = n |} -> do (mpe : ICC.MPElement) <- Index (c.subElements) (n as uint 64)
                                case mpe.body is
                                  { {| matf = _627 |} -> pure {}
                                  }
                                (h : ICC.MPElementHead) <- pure (mpe.head)
                                ($$ : ICC.funOpChecker) <- do (_629 : ICC.funOpChecker) <- ICC.FunOpPop (h.inputs) calc
                                                              pure (ICC.funOpPush (h.outputs) _629)
                                pure $$
          ; {| clut = n |} -> do (mpe : ICC.MPElement) <- Index (c.subElements) (n as uint 64)
                                 (h : ICC.MPElementHead) <- pure (mpe.head)
                                 ($$ : ICC.funOpChecker) <- do (_631 : ICC.funOpChecker) <- ICC.FunOpPop (h.inputs) calc
                                                               pure (ICC.funOpPush (h.outputs) _631)
                                 pure $$
          ; {| calc = n |} -> do (mpe : ICC.MPElement) <- Index (c.subElements) (n as uint 64)
                                 case mpe.body is
                                   { {| calc = _632 |} -> pure {}
                                   }
                                 (h : ICC.MPElementHead) <- pure (mpe.head)
                                 ($$ : ICC.funOpChecker) <- do (_634 : ICC.funOpChecker) <- ICC.FunOpPop (h.inputs) calc
                                                               pure (ICC.funOpPush (h.outputs) _634)
                                 pure $$
          ; {| tint = n |} -> do (mpe : ICC.MPElement) <- Index (c.subElements) (n as uint 64)
                                 (h : ICC.MPElementHead) <- pure (mpe.head)
                                 ($$ : ICC.funOpChecker) <- do (_636 : ICC.funOpChecker) <- ICC.FunOpPop (h.inputs) calc
                                                               pure (ICC.funOpPush (h.outputs) _636)
                                 pure $$
          ; {| elem = n |} -> do (mpe : ICC.MPElement) <- Index (c.subElements) (n as uint 64)
                                 (h : ICC.MPElementHead) <- pure (mpe.head)
                                 ($$ : ICC.funOpChecker) <- do (_638 : ICC.funOpChecker) <- ICC.FunOpPop (h.inputs) calc
                                                               pure (ICC.funOpPush (h.outputs) _638)
                                 pure $$
          ; {| copy = p |} -> do Choose biased
                                   { Daedalus._Guard ((p.s) <= (calc.stack))
                                   | Fail "Not enough arguments to `copy`"
                                   }
                                 ($$ : ICC.funOpChecker) <- pure (ICC.funOpPush (((p.t) + 1) * (p.s)) calc)
                                 pure $$
          ; {| rotl = p |} -> do Choose biased
                                   { Daedalus._Guard ((p.s) <= (calc.stack))
                                   | Fail "Not enough arguments to `rotl`"
                                   }
                                 ($$ : ICC.funOpChecker) <- pure calc
                                 pure $$
          ; {| rotr = p |} -> do Choose biased
                                   { Daedalus._Guard ((p.s) <= (calc.stack))
                                   | Fail "Not enough arguments to `rotr`"
                                   }
                                 ($$ : ICC.funOpChecker) <- pure calc
                                 pure $$
          ; {| posd = p |} -> do Choose biased
                                   { Daedalus._Guard ((p.s) < (calc.stack))
                                   | Fail "Invalid argument for `posd`"
                                   }
                                 ($$ : ICC.funOpChecker) <- pure (ICC.funOpPush ((p.t) + 1) calc)
                                 pure $$
          ; {| flip = s |} -> do Choose biased
                                   { Daedalus._Guard (s <= (calc.stack))
                                   | Fail "Invalid argument for `flip`"
                                   }
                                 ($$ : ICC.funOpChecker) <- pure calc
                                 pure $$
          ; {| pop = s |} -> do ($$ : ICC.funOpChecker) <- ICC.FunOpPop (s + 1) calc
                                pure $$
          })
     pure {}
 
ICC._ChunkRelativeTo (s : Stream) (off : uint 64) (sz : uint 64) : Grammar {} =
  do Daedalus._SetStreamAt off s
     Daedalus._Bytes sz
