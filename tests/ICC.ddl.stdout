module Daedalus
 
--- Imports:
 
--- Type defs:
 
--- Rules:
 
Daedalus.joinWords ?a0 ?a1 ?a2 (?a0 + ?a1 = ?a2) (?a1 + ?a0 = ?a2) (_477 : bool) (a : uint ?a0) (b : uint ?a1) : uint ?a2 =
  if _477 then a # b else b # a
 
Daedalus.UInt16 (_478 : bool) : Grammar (uint 16) =
  do (_479 : uint 8) <- GetByte
     (_480 : uint 8) <- GetByte
     pure (Daedalus.joinWords 8 8 16 _478 _479 _480)
 
Daedalus.UInt32 (_481 : bool) : Grammar (uint 32) =
  do (_482 : uint 16) <- Daedalus.UInt16 _481
     (_483 : uint 16) <- Daedalus.UInt16 _481
     pure (Daedalus.joinWords 16 16 32 _481 _482 _483)
 
Daedalus.UInt64 (_484 : bool) : Grammar (uint 64) =
  do (_485 : uint 32) <- Daedalus.UInt32 _484
     (_486 : uint 32) <- Daedalus.UInt32 _484
     pure (Daedalus.joinWords 32 32 64 _484 _485 _486)
 
Daedalus.SInt16 (_487 : bool) : Grammar (sint 16) =
  do (_488 : uint 16) <- Daedalus.UInt16 _487
     pure (_488 as sint 16)
 
Daedalus.SInt32 (_489 : bool) : Grammar (sint 32) =
  do (_490 : uint 32) <- Daedalus.UInt32 _489
     pure (_490 as sint 32)
 
Daedalus.SInt64 (_491 : bool) : Grammar (sint 64) =
  do (_492 : uint 64) <- Daedalus.UInt64 _491
     pure (_492 as sint 64)
 
Daedalus.wordToHalfFloat (w : uint 16) : float =
  let sign = w >> 15 as uint 1 in
  let expo = w >> 10 as uint 5 in
  let mant = w as uint 10 in
  if (expo == 0) then let magic = 126 << 23 in
                      let num = (wordToFloat (magic + (0 # mant))) - (wordToFloat magic) in
                      if (sign == 1) then - num else num else let newExp = if (expo == 0x1F) then 0xFF else (127 - 15) + (0 # expo) in
                                                              wordToFloat (((sign # newExp) # mant) # 0)
 
Daedalus.HalfFloat (_493 : bool) : Grammar float =
  do (_494 : uint 16) <- Daedalus.UInt16 _493
     pure (Daedalus.wordToHalfFloat _494)
 
Daedalus.Float (_495 : bool) : Grammar float =
  do (_496 : uint 32) <- Daedalus.UInt32 _495
     pure (wordToFloat _496)
 
Daedalus.Double (_497 : bool) : Grammar double =
  do (_498 : uint 64) <- Daedalus.UInt64 _497
     pure (wordToDouble _498)
 
Daedalus.BEUInt16 : Grammar (uint 16) =
  do (_499 : bool) <- pure true
     ($$ : uint 16) <- Daedalus.UInt16 _499
     pure $$
 
Daedalus.BEUInt32 : Grammar (uint 32) =
  do (_501 : bool) <- pure true
     ($$ : uint 32) <- Daedalus.UInt32 _501
     pure $$
 
Daedalus.BEUInt64 : Grammar (uint 64) =
  do (_503 : bool) <- pure true
     ($$ : uint 64) <- Daedalus.UInt64 _503
     pure $$
 
Daedalus.BESInt16 : Grammar (sint 16) =
  do (_505 : bool) <- pure true
     ($$ : sint 16) <- Daedalus.SInt16 _505
     pure $$
 
Daedalus.BESInt32 : Grammar (sint 32) =
  do (_507 : bool) <- pure true
     ($$ : sint 32) <- Daedalus.SInt32 _507
     pure $$
 
Daedalus.BESInt64 : Grammar (sint 64) =
  do (_509 : bool) <- pure true
     ($$ : sint 64) <- Daedalus.SInt64 _509
     pure $$
 
Daedalus.BEHalfFloat : Grammar float =
  do (_511 : bool) <- pure true
     ($$ : float) <- Daedalus.HalfFloat _511
     pure $$
 
Daedalus.BEFloat : Grammar float =
  do (_513 : bool) <- pure true
     ($$ : float) <- Daedalus.Float _513
     pure $$
 
Daedalus.BEDouble : Grammar double =
  do (_515 : bool) <- pure true
     ($$ : double) <- Daedalus.Double _515
     pure $$
 
Daedalus.LEUInt16 : Grammar (uint 16) =
  do (_517 : bool) <- pure false
     ($$ : uint 16) <- Daedalus.UInt16 _517
     pure $$
 
Daedalus.LEUInt32 : Grammar (uint 32) =
  do (_519 : bool) <- pure false
     ($$ : uint 32) <- Daedalus.UInt32 _519
     pure $$
 
Daedalus.LEUInt64 : Grammar (uint 64) =
  do (_521 : bool) <- pure false
     ($$ : uint 64) <- Daedalus.UInt64 _521
     pure $$
 
Daedalus.LESInt16 : Grammar (sint 16) =
  do (_523 : bool) <- pure false
     ($$ : sint 16) <- Daedalus.SInt16 _523
     pure $$
 
Daedalus.LESInt32 : Grammar (sint 32) =
  do (_525 : bool) <- pure false
     ($$ : sint 32) <- Daedalus.SInt32 _525
     pure $$
 
Daedalus.LESInt64 : Grammar (sint 64) =
  do (_527 : bool) <- pure false
     ($$ : sint 64) <- Daedalus.SInt64 _527
     pure $$
 
Daedalus.LEHalfFloat : Grammar float =
  do (_529 : bool) <- pure false
     ($$ : float) <- Daedalus.HalfFloat _529
     pure $$
 
Daedalus.LEFloat : Grammar float =
  do (_531 : bool) <- pure false
     ($$ : float) <- Daedalus.Float _531
     pure $$
 
Daedalus.LEDouble : Grammar double =
  do (_533 : bool) <- pure false
     ($$ : double) <- Daedalus.Double _533
     pure $$
 
Daedalus.Guard (b : bool) : Grammar {} =
  case b is
    { true -> pure {}
    }
 
Daedalus.Only ?a0 (P : Grammar ?a0) : Grammar ?a0 =
  do ($$ : ?a0) <- P
     END
     pure $$
 
Daedalus.SetStreamAt (n : uint 64) (s : Stream) : Grammar {} =
  do (_535 : Stream) <- StreamOff n s
     SetStream _535
 
Daedalus.Skip (n : uint 64) : Grammar {} =
  do (_536 : Stream) <- CurrentStream
     Daedalus.SetStreamAt n _536
 
Daedalus._SetStreamAt (n : uint 64) (s : Stream) : Grammar {} =
  do (_535 : Stream) <- StreamOff n s
     SetStream _535
 
Daedalus.Chunk ?a0 (n : uint 64) (P : Grammar ?a0) : Grammar ?a0 =
  do (s : Stream) <- CurrentStream
     do (_537 : Stream) <- StreamLen n s
        SetStream _537
     ($$ : ?a0) <- P
     Daedalus._SetStreamAt n s
     pure $$
 
Daedalus.Bytes (n : uint 64) : Grammar Stream =
  Daedalus.Chunk Stream n CurrentStream
 
Daedalus.LookAhead ?a0 (P : Grammar ?a0) : Grammar ?a0 =
  do (s : Stream) <- CurrentStream
     ($$ : ?a0) <- P
     SetStream s
     pure $$
 
Daedalus._UInt16 : Grammar {} =
  do @GetByte
     @GetByte
 
Daedalus._UInt32 : Grammar {} =
  do Daedalus._UInt16
     Daedalus._UInt16
 
Daedalus._UInt64 : Grammar {} =
  do Daedalus._UInt32
     Daedalus._UInt32
 
Daedalus._SInt16 : Grammar {} =
  Daedalus._UInt16
 
Daedalus._SInt32 : Grammar {} =
  Daedalus._UInt32
 
Daedalus._SInt64 : Grammar {} =
  Daedalus._UInt64
 
Daedalus._HalfFloat : Grammar {} =
  Daedalus._UInt16
 
Daedalus._Float : Grammar {} =
  Daedalus._UInt32
 
Daedalus._Double : Grammar {} =
  Daedalus._UInt64
 
Daedalus._BEUInt16 : Grammar {} =
  Daedalus._UInt16
 
Daedalus._BEUInt32 : Grammar {} =
  Daedalus._UInt32
 
Daedalus._BEUInt64 : Grammar {} =
  Daedalus._UInt64
 
Daedalus._BESInt16 : Grammar {} =
  Daedalus._SInt16
 
Daedalus._BESInt32 : Grammar {} =
  Daedalus._SInt32
 
Daedalus._BESInt64 : Grammar {} =
  Daedalus._SInt64
 
Daedalus._BEHalfFloat : Grammar {} =
  Daedalus._HalfFloat
 
Daedalus._BEFloat : Grammar {} =
  Daedalus._Float
 
Daedalus._BEDouble : Grammar {} =
  Daedalus._Double
 
Daedalus._LEUInt16 : Grammar {} =
  Daedalus._UInt16
 
Daedalus._LEUInt32 : Grammar {} =
  Daedalus._UInt32
 
Daedalus._LEUInt64 : Grammar {} =
  Daedalus._UInt64
 
Daedalus._LESInt16 : Grammar {} =
  Daedalus._SInt16
 
Daedalus._LESInt32 : Grammar {} =
  Daedalus._SInt32
 
Daedalus._LESInt64 : Grammar {} =
  Daedalus._SInt64
 
Daedalus._LEHalfFloat : Grammar {} =
  Daedalus._HalfFloat
 
Daedalus._LEFloat : Grammar {} =
  Daedalus._Float
 
Daedalus._LEDouble : Grammar {} =
  Daedalus._Double
 
Daedalus._Guard (b : bool) : Grammar {} =
  case b is
    { true -> pure {}
    }
 
Daedalus._Only ?a0 (_P : Grammar {}) : Grammar {} =
  do _P
     END
 
Daedalus._Skip (n : uint 64) : Grammar {} =
  do (_536 : Stream) <- CurrentStream
     Daedalus._SetStreamAt n _536
 
Daedalus._Chunk ?a0 (n : uint 64) (_P : Grammar {}) : Grammar {} =
  do (s : Stream) <- CurrentStream
     do (_537 : Stream) <- StreamLen n s
        SetStream _537
     _P
     Daedalus._SetStreamAt n s
 
Daedalus._Bytes (n : uint 64) : Grammar {} =
  Daedalus._Chunk Stream n (pure {})
 
Daedalus._LookAhead ?a0 (_P : Grammar {}) : Grammar {} =
  do (s : Stream) <- CurrentStream
     _P
     SetStream s
module ICC
 
--- Imports:
import Daedalus
 
--- Type defs:
type ICC.VersionField = { major: uint 8
                        ; minor: uint 4
                        ; bugfix: uint 4
                        }
 
type ICC.ProfileClass = Choose { multiplex_vis: {}
                               ; multiplex_link: {}
                               ; multiplex_id: {}
                               ; color_encoding_space: {}
                               ; named_color_profile: {}
                               ; abstract_profile: {}
                               ; color_space_profile: {}
                               ; device_link_profile: {}
                               ; output_device_profile: {}
                               ; display_device_profile: {}
                               ; input_device_profile: {}
                               }
 
type ICC.DataColorSpace = Choose { n_channel: uint 16
                                 ; none: {}
                                 ; fifteen_colour: {}
                                 ; fourteen_colour: {}
                                 ; thirteen_colour: {}
                                 ; twelve_colour: {}
                                 ; eleven_colour: {}
                                 ; ten_colour: {}
                                 ; nine_colour: {}
                                 ; eight_colour: {}
                                 ; seven_colour: {}
                                 ; six_colour: {}
                                 ; five_colour: {}
                                 ; four_colour: {}
                                 ; three_colour: {}
                                 ; two_colour: {}
                                 ; cmy: {}
                                 ; cmyk: {}
                                 ; hls: {}
                                 ; hsv: {}
                                 ; gray: {}
                                 ; rgb: {}
                                 ; lms: {}
                                 ; cieyxy: {}
                                 ; ycbcr: {}
                                 ; cieluv: {}
                                 ; cielab_or_pcslab: {}
                                 ; nciexyz_or_pcsxyz: {}
                                 }
 
type ICC.PrimaryPlatform = Choose { none: {}
                                  ; sun_microsystems: {}
                                  ; silicon_graphics_inc: {}
                                  ; microsoft_corporation: {}
                                  ; apple_computer_inc: {}
                                  }
 
type ICC.RenderingIntent = Choose { icc_absolute_colorimetric: {}
                                  ; saturation: {}
                                  ; media_relative_colorimetric: {}
                                  ; perceptual: {}
                                  }
 
type ICC.XYZNumber = { x: sint 32
                     ; y: sint 32
                     ; z: sint 32
                     }
 
type ICC.DateTimeNumber = { year: uint 16
                          ; month: uint 16
                          ; day: uint 16
                          ; hour: uint 16
                          ; minute: uint 16
                          ; second: uint 16
                          }
 
type ICC.ProfileHeader = { size: uint 32
                         ; preferred_cmm_type: [uint 8]
                         ; version: ICC.VersionField
                         ; devce_class: ICC.ProfileClass
                         ; color_space: ICC.DataColorSpace
                         ; pcs: ICC.DataColorSpace
                         ; creation_date_time: ICC.DateTimeNumber
                         ; primary_platform: ICC.PrimaryPlatform
                         ; profile_flags: uint 32
                         ; device_manufacturer: [uint 8]
                         ; device_model: [uint 8]
                         ; device_attributes: uint 64
                         ; rendering_intent: ICC.RenderingIntent
                         ; illuminant: ICC.XYZNumber
                         ; creator: [uint 8]
                         ; identifier: [uint 8]
                         ; reserved_data: [uint 8]
                         }
 
type ICC.InvalidTag = { sig: [uint 8]
                      ; data: [uint 8]
                      }
 
type ICC.LutAToBType = { number_of_input_channels: uint 8
                       ; number_of_output_channels: uint 8
                       ; offset_first_B_curve: uint 32
                       ; offset_to_matrix: uint 32
                       ; offset_to_first_M_curve: uint 32
                       ; offset_to_CLUT: uint 32
                       ; offset_to_first_A_curve: uint 32
                       ; data: Stream
                       }
 
type ICC.MPElementHead = { offset: Stream
                         ; tag: uint 32
                         ; inputs: uint 64
                         ; outputs: uint 64
                         }
 
type ICC.OpParams = { s: uint 64
                    ; t: uint 64
                    }
 
rec
  type ICC.FunOpWithPosition = { offset: Stream
                               ; op: ICC.FunOp
                               }
   
  type ICC.Sel = { case1: [ICC.FunOpWithPosition]
                 ; cases: [[ICC.FunOpWithPosition]]
                 ; dflt: Maybe [ICC.FunOpWithPosition]
                 }
   
  type ICC.IfThenElse = { thenOps: [ICC.FunOpWithPosition]
                        ; elseOps: [ICC.FunOpWithPosition]
                        }
   
  type ICC.FunOp = Choose { data: float
                          ; opIn: ICC.OpParams
                          ; opOut: ICC.OpParams
                          ; opTGet: ICC.OpParams
                          ; opTPut: ICC.OpParams
                          ; opTSave: ICC.OpParams
                          ; opEnv: uint 32
                          ; curv: uint 64
                          ; mtx: uint 64
                          ; clut: uint 64
                          ; calc: uint 64
                          ; tint: uint 64
                          ; elem: uint 64
                          ; copy: ICC.OpParams
                          ; rotl: ICC.OpParams
                          ; rotr: ICC.OpParams
                          ; posd: ICC.OpParams
                          ; flip: uint 64
                          ; pop: uint 64
                          ; solv: ICC.OpParams
                          ; tran: ICC.OpParams
                          ; sum: uint 64
                          ; prod: uint 64
                          ; min: uint 64
                          ; max: uint 64
                          ; and: uint 64
                          ; or: uint 64
                          ; opPi: {}
                          ; opPosInf: {}
                          ; opNegInf: {}
                          ; opNaN: {}
                          ; opAdd: uint 64
                          ; opSub: uint 64
                          ; opMul: uint 64
                          ; opDiv: uint 64
                          ; opMod: uint 64
                          ; opPow: uint 64
                          ; opGamma: uint 64
                          ; opSAdd: uint 64
                          ; opSSub: uint 64
                          ; opSMul: uint 64
                          ; opSDiv: uint 64
                          ; opSq: uint 64
                          ; opSqrt: uint 64
                          ; opCb: uint 64
                          ; opCbrt: uint 64
                          ; opAbs: uint 64
                          ; opNeg: uint 64
                          ; opRond: uint 64
                          ; opFlor: uint 64
                          ; opCeil: uint 64
                          ; opTrnc: uint 64
                          ; opSign: uint 64
                          ; opExp: uint 64
                          ; opLog: uint 64
                          ; opLn: uint 64
                          ; opSin: uint 64
                          ; opCos: uint 64
                          ; opTan: uint 64
                          ; opASin: uint 64
                          ; opACos: uint 64
                          ; opATan: uint 64
                          ; opATn2: uint 64
                          ; opCTop: uint 64
                          ; opPToc: uint 64
                          ; opRNum: uint 64
                          ; opLT: uint 64
                          ; opLE: uint 64
                          ; opEQ: uint 64
                          ; opNear: uint 64
                          ; opGE: uint 64
                          ; opGT: uint 64
                          ; opVMin: uint 64
                          ; opVMax: uint 64
                          ; opVAnd: uint 64
                          ; opVOr: uint 64
                          ; opTLab: uint 64
                          ; opTXYZ: uint 64
                          ; opIfThen: [ICC.FunOpWithPosition]
                          ; opIfThenElse: ICC.IfThenElse
                          ; opSel: ICC.Sel
                          }
 
type ICC.SingleSampledCurve = { n: uint 32
                              ; f: uint 32
                              ; l: uint 32
                              ; e: uint 16
                              ; ty: uint 16
                              }
 
type ICC.FormualCurveSegment = { fun: uint 16
                               ; args: [float]
                               }
 
type ICC.CurveSegment = Choose { samf: [float]
                               ; parf: ICC.FormualCurveSegment
                               }
 
type ICC.SegmentedCurve = { breakPoints: [float]
                          ; segments: [ICC.CurveSegment]
                          }
 
type ICC.Curve = Choose { unimplemented: [uint 8]
                        ; curf: ICC.SegmentedCurve
                        ; sngf: ICC.SingleSampledCurve
                        }
 
type ICC.Matrix = { matrix: [[float]]
                  ; vector: [float]
                  }
 
rec
  type ICC.MPElement = { head: ICC.MPElementHead
                       ; body: ICC.MPElementBody
                       }
   
  type ICC.CalcElement = { inputs: uint 64
                         ; outputs: uint 64
                         ; main: [ICC.FunOpWithPosition]
                         ; subElements: [ICC.MPElement]
                         }
   
  type ICC.MPElementBody = Choose { calc: ICC.CalcElement
                                  ; cvst: [ICC.Curve]
                                  ; matf: ICC.Matrix
                                  ; mpet: [ICC.MPElement]
                                  ; unimplemented: [uint 8]
                                  }
 
type ICC.LutAB_or_multi = Choose { lutAB: ICC.LutAToBType
                                 ; mpe: ICC.MPElement
                                 }
 
type ICC.LutBA_or_multi = Choose { lutBA: ICC.LutAToBType
                                 ; mpe: ICC.MPElement
                                 }
 
type ICC.ParametricCurveType = { function: uint 16
                               ; parameters: [uint 32]
                               }
 
type ICC.CurveOrPCurve = Choose { curve: [uint 16]
                                ; pcurve: ICC.ParametricCurveType
                                }
 
type ICC.UnicodeRecord = { language: [uint 8]
                         ; country: [uint 8]
                         ; data: [uint 8]
                         }
 
type ICC.TextDescriptionType = { ascii_data: [uint 8]
                               ; unicode_code: [uint 8]
                               ; unicode_data: [uint 8]
                               ; script_code: [uint 8]
                               ; script_data: [uint 8]
                               }
 
type ICC.LaxTextType = Choose { desc: ICC.TextDescriptionType
                              ; text: [uint 7]
                              ; uni: [ICC.UnicodeRecord]
                              }
 
type ICC.XYNumber = { x: uint 32
                    ; y: uint 32
                    }
 
type ICC.ChromaticityType = { phosphor_or_colorant: uint 16
                            ; cie_coords: [ICC.XYNumber]
                            }
 
type ICC.SpectralViewingConditionsType = { colometric_observer: uint 32
                                         ; xxx: [uint 8]
                                         }
 
type ICC.Tag = Choose { invalid_tag: ICC.InvalidTag
                      ; unimplemented: [uint 8]
                      ; chad: [uint 32]
                      ; chrm: ICC.ChromaticityType
                      ; dmnd: ICC.LaxTextType
                      ; dmdd: ICC.LaxTextType
                      ; bTRC: ICC.CurveOrPCurve
                      ; gTRC: ICC.CurveOrPCurve
                      ; rTRC: ICC.CurveOrPCurve
                      ; bXYZ: [ICC.XYZNumber]
                      ; gXYZ: [ICC.XYZNumber]
                      ; rXYZ: [ICC.XYZNumber]
                      ; svcn: ICC.SpectralViewingConditionsType
                      ; s2cp: ICC.MPElement
                      ; c2sp: ICC.MPElement
                      ; cprt: ICC.LaxTextType
                      ; wtpt: [ICC.XYZNumber]
                      ; B2D3: ICC.MPElement
                      ; B2D2: ICC.MPElement
                      ; B2D1: ICC.MPElement
                      ; B2D0: ICC.MPElement
                      ; B2A3: ICC.LutBA_or_multi
                      ; B2A2: ICC.LutBA_or_multi
                      ; B2A1: ICC.LutBA_or_multi
                      ; B2A0: ICC.LutBA_or_multi
                      ; A2M0: ICC.MPElement
                      ; A2B3: ICC.LutAB_or_multi
                      ; A2B2: ICC.LutAB_or_multi
                      ; A2B1: ICC.LutAB_or_multi
                      ; A2B0: ICC.LutAB_or_multi
                      ; desc: ICC.LaxTextType
                      }
 
type ICC.Main = { header: ICC.ProfileHeader
                ; tags: [ICC.Tag]
                }
 
type ICC.PositionNumber = { offset: uint 64
                          ; size: uint 64
                          }
 
type ICC.Response16Number = { device: uint 16
                            ; measurement: uint 32
                            }
 
type ICC.Colorant = { name: [uint 7]
                    ; pcs: [uint 16]
                    }
 
type ICC.ResponseCurve = { measurement_unit: uint 32
                         ; pcxyzs: [ICC.XYNumber]
                         ; response_arrays: [[ICC.Response16Number]]
                         }
 
type ICC.Lut8Type = { number_of_input_channels: uint 8
                    ; number_of_output_channels: uint 8
                    ; number_of_clut_grid_points: uint 8
                    ; encoded_e_parameters: [sint 32]
                    ; input_tables: Stream
                    ; clut_values: Stream
                    ; output_tables: Stream
                    }
 
type ICC.Lut16Type = { number_of_input_channels: uint 8
                     ; number_of_output_channels: uint 8
                     ; number_of_clut_grid_points: uint 8
                     ; encoded_e_parameters: [sint 32]
                     ; number_of_input_table_entries: uint 32
                     ; number_of_output_table_entries: uint 32
                     ; input_tables: Stream
                     ; clut_values: Stream
                     ; output_tables: Stream
                     }
 
type ICC.LutBToAType = { number_of_input_channels: uint 8
                       ; number_of_output_channels: uint 8
                       ; offset_first_B_curve: uint 32
                       ; offset_to_matrix: uint 32
                       ; offset_to_first_M_curve: uint 32
                       ; offset_to_CLUT: uint 32
                       ; offset_to_first_A_curve: uint 32
                       ; data: Stream
                       }
 
type ICC.MeasurementType = { standard_observer: uint 32
                           ; nCIEXYZ: ICC.XYZNumber
                           ; geometry: uint 32
                           ; flare: uint 32
                           ; illuminant: uint 32
                           }
 
type ICC.ColorName = { name_root: [uint 7]
                     ; pcs_coords: [uint 16]
                     ; device_coords: [uint 16]
                     }
 
type ICC.NamedColor2Type = { vendor_specific: uint 32
                           ; prefix: [uint 7]
                           ; suffix: [uint 7]
                           ; names: [ICC.ColorName]
                           }
 
type ICC.ViewConditionsType = { illuminantXYZ: ICC.XYZNumber
                              ; surroundXYZ: ICC.XYZNumber
                              ; illuminant: uint 32
                              }
 
type ICC.funOpChecker = { stack: uint 64
                        }
 
--- Rules:
 
ICC.VersionField : Grammar ICC.VersionField =
  do (major : uint 8) <- GetByte
     (min_bf : uint 8) <- GetByte
     (minor : uint 4) <- pure (min_bf >> 4 as uint 4)
     (bugfix : uint 4) <- pure (min_bf as uint 4)
     @MatchBytes [0x00,
                  0x00]
     pure {major = major,
           minor = minor,
           bugfix = bugfix}
 
ICC.ProfileClass : Grammar ICC.ProfileClass =
  do (_538 : uint 32) <- Daedalus.BEUInt32
     case _538 is
       { 0s"scnr" -> {- case branch  0s"scnr" -} pure {input_device_profile: {}}
       ; 0s"mntr" -> {- case branch  0s"mntr" -} pure {display_device_profile: {}}
       ; 0s"prtr" -> {- case branch  0s"prtr" -} pure {output_device_profile: {}}
       ; 0s"link" -> {- case branch  0s"link" -} pure {device_link_profile: {}}
       ; 0s"spac" -> {- case branch  0s"spac" -} pure {color_space_profile: {}}
       ; 0s"abst" -> {- case branch  0s"abst" -} pure {abstract_profile: {}}
       ; 0s"nmcl" -> {- case branch  0s"nmcl" -} pure {named_color_profile: {}}
       ; 0s"cenc" -> {- case branch  0s"cenc" -} pure {color_encoding_space: {}}
       ; 0s"mid " -> {- case branch  0s"mid " -} pure {multiplex_id: {}}
       ; 0s"mlnk" -> {- case branch  0s"mlnk" -} pure {multiplex_link: {}}
       ; 0s"mvis" -> {- case branch  0s"mvis" -} pure {multiplex_vis: {}}
       }
 
ICC.DataColorSpace : Grammar ICC.DataColorSpace =
  do (tag : uint 32) <- Daedalus.BEUInt32
     ($$ : ICC.DataColorSpace) <- case tag is
                                    { 0s"XYZ " -> {- case branch  0s"XYZ " -} pure {nciexyz_or_pcsxyz: {}}
                                    ; 0s"Lab " -> {- case branch  0s"Lab " -} pure {cielab_or_pcslab: {}}
                                    ; 0s"Luv " -> {- case branch  0s"Luv " -} pure {cieluv: {}}
                                    ; 0s"Ycbr" -> {- case branch  0s"Ycbr" -} pure {ycbcr: {}}
                                    ; 0s"Yxy " -> {- case branch  0s"Yxy " -} pure {cieyxy: {}}
                                    ; 0s"LMS " -> {- case branch  0s"LMS " -} pure {lms: {}}
                                    ; 0s"RGB " -> {- case branch  0s"RGB " -} pure {rgb: {}}
                                    ; 0s"GRAY" -> {- case branch  0s"GRAY" -} pure {gray: {}}
                                    ; 0s"HSV " -> {- case branch  0s"HSV " -} pure {hsv: {}}
                                    ; 0s"HLS " -> {- case branch  0s"HLS " -} pure {hls: {}}
                                    ; 0s"CMYK" -> {- case branch  0s"CMYK" -} pure {cmyk: {}}
                                    ; 0s"CMY " -> {- case branch  0s"CMY " -} pure {cmy: {}}
                                    ; 0s"2CLR" -> {- case branch  0s"2CLR" -} pure {two_colour: {}}
                                    ; 0s"3CLR" -> {- case branch  0s"3CLR" -} pure {three_colour: {}}
                                    ; 0s"4CLR" -> {- case branch  0s"4CLR" -} pure {four_colour: {}}
                                    ; 0s"5CLR" -> {- case branch  0s"5CLR" -} pure {five_colour: {}}
                                    ; 0s"6CLR" -> {- case branch  0s"6CLR" -} pure {six_colour: {}}
                                    ; 0s"7CLR" -> {- case branch  0s"7CLR" -} pure {seven_colour: {}}
                                    ; 0s"8CLR" -> {- case branch  0s"8CLR" -} pure {eight_colour: {}}
                                    ; 0s"9CLR" -> {- case branch  0s"9CLR" -} pure {nine_colour: {}}
                                    ; 0s"ACLR" -> {- case branch  0s"ACLR" -} pure {ten_colour: {}}
                                    ; 0s"BCLR" -> {- case branch  0s"BCLR" -} pure {eleven_colour: {}}
                                    ; 0s"CCLR" -> {- case branch  0s"CCLR" -} pure {twelve_colour: {}}
                                    ; 0s"DCLR" -> {- case branch  0s"DCLR" -} pure {thirteen_colour: {}}
                                    ; 0s"ECLR" -> {- case branch  0s"ECLR" -} pure {fourteen_colour: {}}
                                    ; 0s"FCLR" -> {- case branch  0s"FCLR" -} pure {fifteen_colour: {}}
                                    ; 0 -> {- case branch  0 -} pure {none: {}}
                                    ; _ -> do Daedalus._Guard ((tag >> 16) == 0s"ne")
                                              ($$ : ICC.DataColorSpace) <- pure {n_channel: (tag as uint 16)}
                                              pure $$
                                    }
     pure $$
 
ICC.PrimaryPlatform : Grammar ICC.PrimaryPlatform =
  do (_541 : uint 32) <- Daedalus.BEUInt32
     case _541 is
       { 0s"APPL" -> {- case branch  0s"APPL" -} pure {apple_computer_inc: {}}
       ; 0s"MSFT" -> {- case branch  0s"MSFT" -} pure {microsoft_corporation: {}}
       ; 0s"SGI " -> {- case branch  0s"SGI " -} pure {silicon_graphics_inc: {}}
       ; 0s"SUNW" -> {- case branch  0s"SUNW" -} pure {sun_microsystems: {}}
       ; 0 -> {- case branch  0 -} pure {none: {}}
       }
 
ICC.RenderingIntent : Grammar ICC.RenderingIntent =
  do (_542 : uint 32) <- Daedalus.BEUInt32
     case _542 is
       { 0 -> {- case branch  0 -} pure {perceptual: {}}
       ; 1 -> {- case branch  1 -} pure {media_relative_colorimetric: {}}
       ; 2 -> {- case branch  2 -} pure {saturation: {}}
       ; 3 -> {- case branch  3 -} pure {icc_absolute_colorimetric: {}}
       }
 
ICC.XYZNumber : Grammar ICC.XYZNumber =
  do (x : sint 32) <- Daedalus.BESInt32
     (y : sint 32) <- Daedalus.BESInt32
     (z : sint 32) <- Daedalus.BESInt32
     pure {x = x,
           y = y,
           z = z}
 
ICC.DateTimeNumber : Grammar ICC.DateTimeNumber =
  do (year : uint 16) <- Daedalus.BEUInt16
     (month : uint 16) <- Daedalus.BEUInt16
     (day : uint 16) <- Daedalus.BEUInt16
     (hour : uint 16) <- Daedalus.BEUInt16
     (minute : uint 16) <- Daedalus.BEUInt16
     (second : uint 16) <- Daedalus.BEUInt16
     pure {year = year,
           month = month,
           day = day,
           hour = hour,
           minute = minute,
           second = second}
 
ICC.ProfileHeader : Grammar ICC.ProfileHeader =
  do (size : uint 32) <- Daedalus.BEUInt32
     (preferred_cmm_type : [uint 8]) <- Many[4] GetByte
     (version : ICC.VersionField) <- ICC.VersionField
     (devce_class : ICC.ProfileClass) <- ICC.ProfileClass
     (color_space : ICC.DataColorSpace) <- ICC.DataColorSpace
     (pcs : ICC.DataColorSpace) <- ICC.DataColorSpace
     (creation_date_time : ICC.DateTimeNumber) <- ICC.DateTimeNumber
     @MatchBytes "acsp"
     (primary_platform : ICC.PrimaryPlatform) <- ICC.PrimaryPlatform
     (profile_flags : uint 32) <- Daedalus.BEUInt32
     (device_manufacturer : [uint 8]) <- Many[4] GetByte
     (device_model : [uint 8]) <- Many[4] GetByte
     (device_attributes : uint 64) <- Daedalus.BEUInt64
     (rendering_intent : ICC.RenderingIntent) <- ICC.RenderingIntent
     (illuminant : ICC.XYZNumber) <- ICC.XYZNumber
     (creator : [uint 8]) <- Many[4] GetByte
     (identifier : [uint 8]) <- Many[16] GetByte
     (reserved_data : [uint 8]) <- Many[28] GetByte
     pure {size = size,
           preferred_cmm_type = preferred_cmm_type,
           version = version,
           devce_class = devce_class,
           color_space = color_space,
           pcs = pcs,
           creation_date_time = creation_date_time,
           primary_platform = primary_platform,
           profile_flags = profile_flags,
           device_manufacturer = device_manufacturer,
           device_model = device_model,
           device_attributes = device_attributes,
           rendering_intent = rendering_intent,
           illuminant = illuminant,
           creator = creator,
           identifier = identifier,
           reserved_data = reserved_data}
 
ICC.explode32 (sig : uint 32) : [uint 8] =
  [sig >> 24 as uint 8,
   sig >> 16 as uint 8,
   sig >> 8 as uint 8,
   sig as uint 8]
 
ICC.InvalidTag (sig : uint 32) : Grammar ICC.InvalidTag =
  do (sig : [uint 8]) <- pure (ICC.explode32 sig)
     (data : [uint 8]) <- Many[] GetByte
     pure {sig = sig,
           data = data}
 
ICC.MPElementHead : Grammar ICC.MPElementHead =
  do (offset : Stream) <- CurrentStream
     (tag : uint 32) <- Daedalus.BEUInt32
     @MatchBytes [0,
                  0,
                  0,
                  0]
     (inputs : uint 64) <- do (_543 : uint 16) <- Daedalus.BEUInt16
                              pure (_543 as uint 64)
     (outputs : uint 64) <- do (_544 : uint 16) <- Daedalus.BEUInt16
                               pure (_544 as uint 64)
     pure {offset = offset,
           tag = tag,
           inputs = inputs,
           outputs = outputs}
 
ICC.SelCase : Grammar (uint 64) =
  do @MatchBytes "case"
     ($$ : uint 64) <- do (_547 : uint 32) <- Daedalus.BEUInt32
                          pure (_547 as uint 64)
     pure $$
 
ICC._Exactly ?a0 (x : ?a0) (P : Grammar ?a0) : Grammar {} =
  Choose biased
    { do (_549 : bool) <- do (_548 : ?a0) <- P
                             pure (_548 == x)
         Daedalus._Guard _549
    | Fail "Unexpected field value"
    }
 
ICC.NoParams : Grammar {} =
  ICC._Exactly (uint 32) 0 Daedalus.BEUInt32
 
ICC.OpParam : Grammar (uint 64) =
  do ($$ : uint 64) <- do (_551 : uint 16) <- Daedalus.BEUInt16
                          pure (_551 as uint 64)
     ICC._Exactly (uint 16) 0 Daedalus.BEUInt16
     pure $$
 
ICC.OpParams : Grammar ICC.OpParams =
  do (s : uint 64) <- do (_552 : uint 16) <- Daedalus.BEUInt16
                         pure (_552 as uint 64)
     (t : uint 64) <- do (_553 : uint 16) <- Daedalus.BEUInt16
                         pure (_553 as uint 64)
     pure {s = s,
           t = t}
 
ICC._NoParams : Grammar {} =
  ICC._Exactly (uint 32) 0 Daedalus.BEUInt32
 
rec value
  ICC.ManyFunOps (n : uint 64) : Grammar [ICC.FunOpWithPosition] =
    Daedalus.Chunk [ICC.FunOpWithPosition] (8 * n) (Daedalus.Only [ICC.FunOpWithPosition] (Many[] ICC.FunOpWithPosition))
   
  ICC.Sel (alt : uint 64) (alts : [uint 64]) (mbDflt : Maybe (uint 64)) : Grammar ICC.Sel =
    do (case1 : [ICC.FunOpWithPosition]) <- ICC.ManyFunOps alt
       (cases : [[ICC.FunOpWithPosition]]) <- map ((n : uint 64) in alts)
                                                (ICC.ManyFunOps n)
       (dflt : Maybe [ICC.FunOpWithPosition]) <- case mbDflt is
                                                   { nothing -> {- case branch  nothing -} pure nothing
                                                   ; just n -> {- case branch  just n -} do (_554 : [ICC.FunOpWithPosition]) <- ICC.ManyFunOps n
                                                                                            pure (just _554)
                                                   }
       pure {case1 = case1,
             cases = cases,
             dflt = dflt}
   
  ICC.IfThenElse (thenOps : uint 64) (elseOps : uint 64) : Grammar ICC.IfThenElse =
    do (thenOps : [ICC.FunOpWithPosition]) <- ICC.ManyFunOps thenOps
       (elseOps : [ICC.FunOpWithPosition]) <- ICC.ManyFunOps elseOps
       pure {thenOps = thenOps,
             elseOps = elseOps}
   
  ICC.FunOp : Grammar ICC.FunOp =
    do (tag : uint 32) <- Daedalus.BEUInt32
       ($$ : ICC.FunOp) <- case tag is
                             { 0s"data" -> {- case branch  0s"data" -} do (_556 : float) <- Daedalus.BEFloat
                                                                          pure {data: _556}
                             ; 0s"in  " -> {- case branch  0s"in  " -} do (_557 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {opIn: _557}
                             ; 0s"out " -> {- case branch  0s"out " -} do (_558 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {opOut: _558}
                             ; 0s"tget" -> {- case branch  0s"tget" -} do (_559 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {opTGet: _559}
                             ; 0s"tput" -> {- case branch  0s"tput" -} do (_560 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {opTPut: _560}
                             ; 0s"tsav" -> {- case branch  0s"tsav" -} do (_561 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {opTSave: _561}
                             ; 0s"env " -> {- case branch  0s"env " -} do (_562 : uint 32) <- Daedalus.BEUInt32
                                                                          pure {opEnv: _562}
                             ; 0s"curv" -> {- case branch  0s"curv" -} do (_564 : uint 64) <- do (_563 : uint 64) <- ICC.OpParam
                                                                                                 pure (_563 as uint 64)
                                                                          pure {curv: _564}
                             ; 0s"mtx " -> {- case branch  0s"mtx " -} do (_566 : uint 64) <- do (_565 : uint 64) <- ICC.OpParam
                                                                                                 pure (_565 as uint 64)
                                                                          pure {mtx: _566}
                             ; 0s"clut" -> {- case branch  0s"clut" -} do (_568 : uint 64) <- do (_567 : uint 64) <- ICC.OpParam
                                                                                                 pure (_567 as uint 64)
                                                                          pure {clut: _568}
                             ; 0s"calc" -> {- case branch  0s"calc" -} do (_570 : uint 64) <- do (_569 : uint 64) <- ICC.OpParam
                                                                                                 pure (_569 as uint 64)
                                                                          pure {calc: _570}
                             ; 0s"tint" -> {- case branch  0s"tint" -} do (_572 : uint 64) <- do (_571 : uint 64) <- ICC.OpParam
                                                                                                 pure (_571 as uint 64)
                                                                          pure {tint: _572}
                             ; 0s"elem" -> {- case branch  0s"elem" -} do (_574 : uint 64) <- do (_573 : uint 64) <- ICC.OpParam
                                                                                                 pure (_573 as uint 64)
                                                                          pure {elem: _574}
                             ; 0s"copy" -> {- case branch  0s"copy" -} do (_575 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {copy: _575}
                             ; 0s"rotl" -> {- case branch  0s"rotl" -} do (_576 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {rotl: _576}
                             ; 0s"rotr" -> {- case branch  0s"rotr" -} do (_577 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {rotr: _577}
                             ; 0s"posd" -> {- case branch  0s"posd" -} do (_578 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {posd: _578}
                             ; 0s"flip" -> {- case branch  0s"flip" -} do (_579 : uint 64) <- ICC.OpParam
                                                                          pure {flip: _579}
                             ; 0s"pop " -> {- case branch  0s"pop " -} do (_580 : uint 64) <- ICC.OpParam
                                                                          pure {pop: _580}
                             ; 0s"solv" -> {- case branch  0s"solv" -} do (_581 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {solv: _581}
                             ; 0s"tran" -> {- case branch  0s"tran" -} do (_582 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {tran: _582}
                             ; 0s"sum " -> {- case branch  0s"sum " -} do (_583 : uint 64) <- ICC.OpParam
                                                                          pure {sum: _583}
                             ; 0s"prod" -> {- case branch  0s"prod" -} do (_584 : uint 64) <- ICC.OpParam
                                                                          pure {prod: _584}
                             ; 0s"min " -> {- case branch  0s"min " -} do (_585 : uint 64) <- ICC.OpParam
                                                                          pure {min: _585}
                             ; 0s"max " -> {- case branch  0s"max " -} do (_586 : uint 64) <- ICC.OpParam
                                                                          pure {max: _586}
                             ; 0s"and " -> {- case branch  0s"and " -} do (_587 : uint 64) <- ICC.OpParam
                                                                          pure {and: _587}
                             ; 0s"or  " -> {- case branch  0s"or  " -} do (_588 : uint 64) <- ICC.OpParam
                                                                          pure {or: _588}
                             ; 0s"pi  " -> {- case branch  0s"pi  " -} do (_589 : {}) <- ICC.NoParams
                                                                          pure {opPi: _589}
                             ; 0s"+INF" -> {- case branch  0s"+INF" -} do (_590 : {}) <- ICC.NoParams
                                                                          pure {opPosInf: _590}
                             ; 0s"-INF" -> {- case branch  0s"-INF" -} do (_591 : {}) <- ICC.NoParams
                                                                          pure {opNegInf: _591}
                             ; 0s"NaN " -> {- case branch  0s"NaN " -} do (_592 : {}) <- ICC.NoParams
                                                                          pure {opNaN: _592}
                             ; 0s"add " -> {- case branch  0s"add " -} do (_593 : uint 64) <- ICC.OpParam
                                                                          pure {opAdd: _593}
                             ; 0s"sub " -> {- case branch  0s"sub " -} do (_594 : uint 64) <- ICC.OpParam
                                                                          pure {opSub: _594}
                             ; 0s"mul " -> {- case branch  0s"mul " -} do (_595 : uint 64) <- ICC.OpParam
                                                                          pure {opMul: _595}
                             ; 0s"div " -> {- case branch  0s"div " -} do (_596 : uint 64) <- ICC.OpParam
                                                                          pure {opDiv: _596}
                             ; 0s"mod " -> {- case branch  0s"mod " -} do (_597 : uint 64) <- ICC.OpParam
                                                                          pure {opMod: _597}
                             ; 0s"pow " -> {- case branch  0s"pow " -} do (_598 : uint 64) <- ICC.OpParam
                                                                          pure {opPow: _598}
                             ; 0s"gama" -> {- case branch  0s"gama" -} do (_599 : uint 64) <- ICC.OpParam
                                                                          pure {opGamma: _599}
                             ; 0s"sadd" -> {- case branch  0s"sadd" -} do (_600 : uint 64) <- ICC.OpParam
                                                                          pure {opSAdd: _600}
                             ; 0s"ssub" -> {- case branch  0s"ssub" -} do (_601 : uint 64) <- ICC.OpParam
                                                                          pure {opSSub: _601}
                             ; 0s"smul" -> {- case branch  0s"smul" -} do (_602 : uint 64) <- ICC.OpParam
                                                                          pure {opSMul: _602}
                             ; 0s"sdiv" -> {- case branch  0s"sdiv" -} do (_603 : uint 64) <- ICC.OpParam
                                                                          pure {opSDiv: _603}
                             ; 0s"sq  " -> {- case branch  0s"sq  " -} do (_604 : uint 64) <- ICC.OpParam
                                                                          pure {opSq: _604}
                             ; 0s"sqrt" -> {- case branch  0s"sqrt" -} do (_605 : uint 64) <- ICC.OpParam
                                                                          pure {opSqrt: _605}
                             ; 0s"cb  " -> {- case branch  0s"cb  " -} do (_606 : uint 64) <- ICC.OpParam
                                                                          pure {opCb: _606}
                             ; 0s"cbrt" -> {- case branch  0s"cbrt" -} do (_607 : uint 64) <- ICC.OpParam
                                                                          pure {opCbrt: _607}
                             ; 0s"abs " -> {- case branch  0s"abs " -} do (_608 : uint 64) <- ICC.OpParam
                                                                          pure {opAbs: _608}
                             ; 0s"neg " -> {- case branch  0s"neg " -} do (_609 : uint 64) <- ICC.OpParam
                                                                          pure {opNeg: _609}
                             ; 0s"rond" -> {- case branch  0s"rond" -} do (_610 : uint 64) <- ICC.OpParam
                                                                          pure {opRond: _610}
                             ; 0s"flor" -> {- case branch  0s"flor" -} do (_611 : uint 64) <- ICC.OpParam
                                                                          pure {opFlor: _611}
                             ; 0s"ceil" -> {- case branch  0s"ceil" -} do (_612 : uint 64) <- ICC.OpParam
                                                                          pure {opCeil: _612}
                             ; 0s"trnc" -> {- case branch  0s"trnc" -} do (_613 : uint 64) <- ICC.OpParam
                                                                          pure {opTrnc: _613}
                             ; 0s"sign" -> {- case branch  0s"sign" -} do (_614 : uint 64) <- ICC.OpParam
                                                                          pure {opSign: _614}
                             ; 0s"exp " -> {- case branch  0s"exp " -} do (_615 : uint 64) <- ICC.OpParam
                                                                          pure {opExp: _615}
                             ; 0s"log " -> {- case branch  0s"log " -} do (_616 : uint 64) <- ICC.OpParam
                                                                          pure {opLog: _616}
                             ; 0s"ln  " -> {- case branch  0s"ln  " -} do (_617 : uint 64) <- ICC.OpParam
                                                                          pure {opLn: _617}
                             ; 0s"sin " -> {- case branch  0s"sin " -} do (_618 : uint 64) <- ICC.OpParam
                                                                          pure {opSin: _618}
                             ; 0s"cos " -> {- case branch  0s"cos " -} do (_619 : uint 64) <- ICC.OpParam
                                                                          pure {opCos: _619}
                             ; 0s"tan " -> {- case branch  0s"tan " -} do (_620 : uint 64) <- ICC.OpParam
                                                                          pure {opTan: _620}
                             ; 0s"asin" -> {- case branch  0s"asin" -} do (_621 : uint 64) <- ICC.OpParam
                                                                          pure {opASin: _621}
                             ; 0s"acos" -> {- case branch  0s"acos" -} do (_622 : uint 64) <- ICC.OpParam
                                                                          pure {opACos: _622}
                             ; 0s"atan" -> {- case branch  0s"atan" -} do (_623 : uint 64) <- ICC.OpParam
                                                                          pure {opATan: _623}
                             ; 0s"atn2" -> {- case branch  0s"atn2" -} do (_624 : uint 64) <- ICC.OpParam
                                                                          pure {opATn2: _624}
                             ; 0s"ctop" -> {- case branch  0s"ctop" -} do (_625 : uint 64) <- ICC.OpParam
                                                                          pure {opCTop: _625}
                             ; 0s"ptoc" -> {- case branch  0s"ptoc" -} do (_626 : uint 64) <- ICC.OpParam
                                                                          pure {opPToc: _626}
                             ; 0s"rnum" -> {- case branch  0s"rnum" -} do (_627 : uint 64) <- ICC.OpParam
                                                                          pure {opRNum: _627}
                             ; 0s"lt  " -> {- case branch  0s"lt  " -} do (_628 : uint 64) <- ICC.OpParam
                                                                          pure {opLT: _628}
                             ; 0s"le  " -> {- case branch  0s"le  " -} do (_629 : uint 64) <- ICC.OpParam
                                                                          pure {opLE: _629}
                             ; 0s"eq  " -> {- case branch  0s"eq  " -} do (_630 : uint 64) <- ICC.OpParam
                                                                          pure {opEQ: _630}
                             ; 0s"near" -> {- case branch  0s"near" -} do (_631 : uint 64) <- ICC.OpParam
                                                                          pure {opNear: _631}
                             ; 0s"ge  " -> {- case branch  0s"ge  " -} do (_632 : uint 64) <- ICC.OpParam
                                                                          pure {opGE: _632}
                             ; 0s"gt  " -> {- case branch  0s"gt  " -} do (_633 : uint 64) <- ICC.OpParam
                                                                          pure {opGT: _633}
                             ; 0s"vmin" -> {- case branch  0s"vmin" -} do (_634 : uint 64) <- ICC.OpParam
                                                                          pure {opVMin: _634}
                             ; 0s"vmax" -> {- case branch  0s"vmax" -} do (_635 : uint 64) <- ICC.OpParam
                                                                          pure {opVMax: _635}
                             ; 0s"vand" -> {- case branch  0s"vand" -} do (_636 : uint 64) <- ICC.OpParam
                                                                          pure {opVAnd: _636}
                             ; 0s"vor " -> {- case branch  0s"vor " -} do (_637 : uint 64) <- ICC.OpParam
                                                                          pure {opVOr: _637}
                             ; 0s"tLab" -> {- case branch  0s"tLab" -} do (_638 : uint 64) <- ICC.OpParam
                                                                          pure {opTLab: _638}
                             ; 0s"tXYZ" -> {- case branch  0s"tXYZ" -} do (_639 : uint 64) <- ICC.OpParam
                                                                          pure {opTXYZ: _639}
                             ; 0s"if  " -> {- case branch  0s"if  " -} do (thenOps : uint 64) <- do (_640 : uint 32) <- Daedalus.BEUInt32
                                                                                                    pure (_640 as uint 64)
                                                                          ($$ : ICC.FunOp) <- do (_642 : Maybe [uint 8]) <- Optional (MatchBytes "else")
                                                                                                 case _642 is
                                                                                                   { nothing -> {- case branch  nothing -} do (_643 : [ICC.FunOpWithPosition]) <- ICC.ManyFunOps thenOps
                                                                                                                                              pure {opIfThen: _643}
                                                                                                   ; just _ -> {- case branch  just _ -} do (_646 : ICC.IfThenElse) <- do (_645 : uint 64) <- do (_644 : uint 32) <- Daedalus.BEUInt32
                                                                                                                                                                                                 pure (_644 as uint 64)
                                                                                                                                                                          ICC.IfThenElse thenOps _645
                                                                                                                                            pure {opIfThenElse: _646}
                                                                                                   }
                                                                          pure $$
                             ; 0s"else" -> {- case branch  0s"else" -} Fail "`else` with no `if"
                             ; 0s"sel " -> {- case branch  0s"sel " -} do ICC._NoParams
                                                                          (c1 : uint 64) <- ICC.SelCase
                                                                          (cs : [uint 64]) <- Many[] ICC.SelCase
                                                                          (d : Maybe (uint 64)) <- Optional do @MatchBytes "dflt"
                                                                                                               ($$ : uint 64) <- do (_648 : uint 32) <- Daedalus.BEUInt32
                                                                                                                                    pure (_648 as uint 64)
                                                                                                               pure $$
                                                                          ($$ : ICC.FunOp) <- do (_650 : ICC.Sel) <- ICC.Sel c1 cs d
                                                                                                 pure {opSel: _650}
                                                                          pure $$
                             ; 0s"case" -> {- case branch  0s"case" -} Fail "`case` with no `sel`"
                             ; 0s"dflt" -> {- case branch  0s"dflt" -} Fail "`dflt` with no `sel`"
                             ; _ -> Fail (concat ["invalid tag: ",
                                                  ICC.explode32 tag])
                             }
       pure $$
   
  ICC.FunOpWithPosition : Grammar ICC.FunOpWithPosition =
    do (offset : Stream) <- CurrentStream
       (op : ICC.FunOp) <- ICC.FunOp
       pure {offset = offset,
             op = op}
 
ICC._StartTag (x : [uint 8]) : Grammar {} =
  do @MatchBytes x
     @MatchBytes [0,
                  0,
                  0,
                  0]
 
ICC.CalcFun : Grammar [ICC.FunOpWithPosition] =
  do ICC._StartTag "func"
     ($$ : [ICC.FunOpWithPosition]) <- do (_653 : uint 64) <- do (_652 : uint 32) <- Daedalus.BEUInt32
                                                                 pure (_652 as uint 64)
                                          ICC.ManyFunOps _653
     pure $$
 
ICC.PositionNumber : Grammar ICC.PositionNumber =
  do (offset : uint 64) <- do (_654 : uint 32) <- Daedalus.BEUInt32
                              pure (_654 as uint 64)
     (size : uint 64) <- do (_655 : uint 32) <- Daedalus.BEUInt32
                            pure (_655 as uint 64)
     pure {offset = offset,
           size = size}
 
ICC.Positioned ?a0 (s : Stream) (P : Grammar ?a0) : Grammar ?a0 =
  do (p : ICC.PositionNumber) <- ICC.PositionNumber
     ($$ : ?a0) <- Daedalus.LookAhead ?a0 do Daedalus._SetStreamAt (p.offset) s
                                             ($$ : ?a0) <- Daedalus.Chunk ?a0 (p.size) P
                                             pure $$
     pure $$
 
ICC.SingleSampledCurve : Grammar ICC.SingleSampledCurve =
  do (n : uint 32) <- Daedalus.BEUInt32
     (f : uint 32) <- Daedalus.BEUInt32
     (l : uint 32) <- Daedalus.BEUInt32
     (e : uint 16) <- Daedalus.BEUInt16
     (ty : uint 16) <- Daedalus.BEUInt16
     pure {n = n,
           f = f,
           l = l,
           e = e,
           ty = ty}
 
ICC.FormualCurveSegment : Grammar ICC.FormualCurveSegment =
  do (fun : uint 16) <- Daedalus.BEUInt16
     do (_659 : bool) <- do (_658 : uint 16) <- Daedalus.BEUInt16
                            pure (_658 == 0)
        Daedalus._Guard _659
     ($$ : ICC.FormualCurveSegment) <- case fun is
                                         { 0 -> {- case branch  0 -} do (fun : uint 16) <- pure fun
                                                                        (args : [float]) <- Many[4] Daedalus.BEFloat
                                                                        pure {fun = fun,
                                                                              args = args}
                                         ; 1 -> {- case branch  1 -} do (fun : uint 16) <- pure fun
                                                                        (args : [float]) <- Many[5] Daedalus.BEFloat
                                                                        pure {fun = fun,
                                                                              args = args}
                                         ; 2 -> {- case branch  2 -} do (fun : uint 16) <- pure fun
                                                                        (args : [float]) <- Many[5] Daedalus.BEFloat
                                                                        pure {fun = fun,
                                                                              args = args}
                                         ; 3 -> {- case branch  3 -} do (fun : uint 16) <- pure fun
                                                                        (args : [float]) <- Many[4] Daedalus.BEFloat
                                                                        pure {fun = fun,
                                                                              args = args}
                                         }
     pure $$
 
ICC.CurveSegment : Grammar ICC.CurveSegment =
  do (tag : uint 32) <- Daedalus.BEUInt32
     ICC._Exactly (uint 32) 0 Daedalus.BEUInt32
     ($$ : ICC.CurveSegment) <- case tag is
                                  { 0s"parf" -> {- case branch  0s"parf" -} do (_662 : ICC.FormualCurveSegment) <- ICC.FormualCurveSegment
                                                                               pure {parf: _662}
                                  ; 0s"samf" -> {- case branch  0s"samf" -} do (_665 : [float]) <- do (_664 : uint 64) <- do (_663 : uint 32) <- Daedalus.BEUInt32
                                                                                                                             pure (_663 as uint 64)
                                                                                                      Many[_664] Daedalus.BEFloat
                                                                               pure {samf: _665}
                                  }
     pure $$
 
ICC.SegmentedCurve : Grammar ICC.SegmentedCurve =
  do (n : uint 64) <- do (_666 : uint 16) <- Daedalus.BEUInt16
                         pure (_666 as uint 64)
     Choose biased
       { Daedalus._Guard (1 <= n)
       | Fail "Need at least one curve segment"
       }
     ICC._Exactly (uint 16) 0 Daedalus.BEUInt16
     (bnum : uint 64) <- pure (n - 1)
     (breakPoints : [float]) <- Many[bnum] Daedalus.BEFloat
     (segments : [ICC.CurveSegment]) <- Many[n] ICC.CurveSegment
     pure {breakPoints = breakPoints,
           segments = segments}
 
ICC.Curve : Grammar ICC.Curve =
  do (tag : uint 32) <- Daedalus.BEUInt32
     ICC._Exactly (uint 32) 0 Daedalus.BEUInt32
     ($$ : ICC.Curve) <- case tag is
                           { 0s"sngf" -> {- case branch  0s"sngf" -} do (_668 : ICC.SingleSampledCurve) <- ICC.SingleSampledCurve
                                                                        pure {sngf: _668}
                           ; 0s"curf" -> {- case branch  0s"curf" -} do (_669 : ICC.SegmentedCurve) <- ICC.SegmentedCurve
                                                                        pure {curf: _669}
                           ; _ -> pure {unimplemented: (ICC.explode32 tag)}
                           }
     pure $$
 
ICC.Matrix (p : uint 64) (q : uint 64) : Grammar ICC.Matrix =
  do (matrix : [[float]]) <- Many[q] Many[p] Daedalus.BEFloat
     (vector : [float]) <- Many[q] Daedalus.BEFloat
     pure {matrix = matrix,
           vector = vector}
 
rec value
  ICC.MPElement : Grammar ICC.MPElement =
    do (head : ICC.MPElementHead) <- ICC.MPElementHead
       (body : ICC.MPElementBody) <- ICC.MPElementBody head
       pure {head = head,
             body = body}
   
  ICC.CalcElement (head : ICC.MPElementHead) : Grammar ICC.CalcElement =
    do (subElNum : uint 64) <- do (_670 : uint 32) <- Daedalus.BEUInt32
                                  pure (_670 as uint 64)
       (inputs : uint 64) <- pure (head.inputs)
       (outputs : uint 64) <- pure (head.outputs)
       (main : [ICC.FunOpWithPosition]) <- ICC.Positioned [ICC.FunOpWithPosition] (head.offset) ICC.CalcFun
       (subElements : [ICC.MPElement]) <- Many[subElNum] ICC.Positioned ICC.MPElement (head.offset) ICC.MPElement
       pure {inputs = inputs,
             outputs = outputs,
             main = main,
             subElements = subElements}
   
  ICC.MPElementBody (head : ICC.MPElementHead) : Grammar ICC.MPElementBody =
    case head.tag is
      { 0s"calc" -> {- case branch  0s"calc" -} do (_671 : ICC.CalcElement) <- do ($$ : ICC.CalcElement) <- ICC.CalcElement head
                                                                                  pure $$
                                                   pure {calc: _671}
      ; 0s"cvst" -> {- case branch  0s"cvst" -} do (_672 : [ICC.Curve]) <- Many[head.inputs] ICC.Positioned ICC.Curve (head.offset) ICC.Curve
                                                   pure {cvst: _672}
      ; 0s"matf" -> {- case branch  0s"matf" -} do (_673 : ICC.Matrix) <- ICC.Matrix (head.inputs) (head.outputs)
                                                   pure {matf: _673}
      ; 0s"mpet" -> {- case branch  0s"mpet" -} do (_676 : [ICC.MPElement]) <- do (n : uint 64) <- do (_674 : uint 32) <- Daedalus.BEUInt32
                                                                                                      pure (_674 as uint 64)
                                                                                  Choose biased
                                                                                    { Daedalus._Guard (1 <= n)
                                                                                    | Fail "Need at least one MPE"
                                                                                    }
                                                                                  ($$ : [ICC.MPElement]) <- Many[n] ICC.Positioned ICC.MPElement (head.offset) ICC.MPElement
                                                                                  pure $$
                                                   pure {mpet: _676}
      ; _ -> pure {unimplemented: (ICC.explode32 (head.tag))}
      }
 
ICC.MultiProcessElementsType : Grammar ICC.MPElement =
  ICC.MPElement
 
ICC.LutAToBType : Grammar ICC.LutAToBType =
  do ICC._StartTag "mAB "
     (number_of_input_channels : uint 8) <- GetByte
     (number_of_output_channels : uint 8) <- GetByte
     @MatchBytes [0,
                  0]
     (offset_first_B_curve : uint 32) <- Daedalus.BEUInt32
     (offset_to_matrix : uint 32) <- Daedalus.BEUInt32
     (offset_to_first_M_curve : uint 32) <- Daedalus.BEUInt32
     (offset_to_CLUT : uint 32) <- Daedalus.BEUInt32
     (offset_to_first_A_curve : uint 32) <- Daedalus.BEUInt32
     (data : Stream) <- CurrentStream
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           offset_first_B_curve = offset_first_B_curve,
           offset_to_matrix = offset_to_matrix,
           offset_to_first_M_curve = offset_to_first_M_curve,
           offset_to_CLUT = offset_to_CLUT,
           offset_to_first_A_curve = offset_to_first_A_curve,
           data = data}
 
ICC.LutAB_or_multi : Grammar ICC.LutAB_or_multi =
  Choose biased
    { {- lutAB -} do (_677 : ICC.LutAToBType) <- ICC.LutAToBType
                     pure {lutAB: _677}
    | {- mpe -} do (_678 : ICC.MPElement) <- ICC.MultiProcessElementsType
                   pure {mpe: _678}
    }
 
ICC.LutBA_or_multi : Grammar ICC.LutBA_or_multi =
  Choose biased
    { {- lutBA -} do (_679 : ICC.LutAToBType) <- ICC.LutAToBType
                     pure {lutBA: _679}
    | {- mpe -} do (_680 : ICC.MPElement) <- ICC.MultiProcessElementsType
                   pure {mpe: _680}
    }
 
ICC.CurveType : Grammar [uint 16] =
  do ICC._StartTag "curv"
     (n : uint 64) <- do (_681 : uint 32) <- Daedalus.BEUInt32
                         pure (_681 as uint 64)
     ($$ : [uint 16]) <- Many[n] Daedalus.BEUInt16
     pure $$
 
ICC.ParametricCurveType : Grammar ICC.ParametricCurveType =
  do ICC._StartTag "para"
     (function : uint 16) <- Daedalus.BEUInt16
     @MatchBytes [0,
                  0]
     (parameters : [uint 32]) <- Many[] Daedalus.BEUInt32
     pure {function = function,
           parameters = parameters}
 
ICC.CurveOrPCurve : Grammar ICC.CurveOrPCurve =
  Choose biased
    { {- curve -} do (_683 : [uint 16]) <- ICC.CurveType
                     pure {curve: _683}
    | {- pcurve -} do (_684 : ICC.ParametricCurveType) <- ICC.ParametricCurveType
                      pure {pcurve: _684}
    }
 
ICC.ASCII7 : Grammar [uint 7] =
  do ($$ : [uint 7]) <- Many[] do (_685 : uint 8) <- Match (1 .. 255)
                                  _685 AS uint 7
     Choose biased
       { @Many[ 1 .. ] @Match {0}
       | Fail "Non 0 string terminator"
       }
     pure $$
 
ICC.TextType : Grammar [uint 7] =
  do ICC._StartTag "text"
     ($$ : [uint 7]) <- ICC.ASCII7
     pure $$
 
ICC.UnicodeRecord (s : Stream) : Grammar ICC.UnicodeRecord =
  do (language : [uint 8]) <- Many[2] GetByte
     (country : [uint 8]) <- Many[2] GetByte
     (data : [uint 8]) <- ICC.Positioned [uint 8] s (Many[] GetByte)
     pure {language = language,
           country = country,
           data = data}
 
ICC.MultiLocalizedUnicodeType : Grammar [ICC.UnicodeRecord] =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "mluc"
     (record_number : uint 32) <- Daedalus.BEUInt32
     ICC._Exactly (uint 32) 12 Daedalus.BEUInt32
     ($$ : [ICC.UnicodeRecord]) <- Many[record_number as uint 64] ICC.UnicodeRecord s
     pure $$
 
ICC.TextDescriptionType : Grammar ICC.TextDescriptionType =
  do ICC._StartTag "desc"
     (ascii_data : [uint 8]) <- do (_689 : uint 64) <- do (_688 : uint 32) <- Daedalus.BEUInt32
                                                          pure (_688 as uint 64)
                                   Many[_689] GetByte
     (unicode_code : [uint 8]) <- Many[4] GetByte
     (unicode_data : [uint 8]) <- do (_692 : uint 64) <- do (_691 : uint 32) <- do (_690 : uint 32) <- Daedalus.BEUInt32
                                                                                   pure (2 * _690)
                                                            pure (_691 as uint 64)
                                     Many[_692] GetByte
     (script_code : [uint 8]) <- Many[2] GetByte
     Daedalus._BEUInt32
     (script_data : [uint 8]) <- do (_695 : uint 64) <- do (_694 : uint 32) <- Daedalus.BEUInt32
                                                           pure (_694 as uint 64)
                                    Many[_695] GetByte
     @Many[] @Match {0}
     pure {ascii_data = ascii_data,
           unicode_code = unicode_code,
           unicode_data = unicode_data,
           script_code = script_code,
           script_data = script_data}
 
ICC.LaxTextType : Grammar ICC.LaxTextType =
  Choose biased
    { {- uni -} do (_696 : [ICC.UnicodeRecord]) <- ICC.MultiLocalizedUnicodeType
                   pure {uni: _696}
    | {- desc -} do (_697 : ICC.TextDescriptionType) <- Daedalus.Only ICC.TextDescriptionType ICC.TextDescriptionType
                    pure {desc: _697}
    | {- text -} do (_698 : [uint 7]) <- Daedalus.Only [uint 7] ICC.TextType
                    pure {text: _698}
    }
 
ICC.S15Fixed16ArrayType : Grammar [uint 32] =
  Daedalus.Only [uint 32] do ICC._StartTag "sf32"
                             ($$ : [uint 32]) <- Many[] Daedalus.BEUInt32
                             pure $$
 
ICC.XYNumber : Grammar ICC.XYNumber =
  do (x : uint 32) <- Daedalus.BEUInt32
     (y : uint 32) <- Daedalus.BEUInt32
     pure {x = x,
           y = y}
 
ICC.ChromaticityType : Grammar ICC.ChromaticityType =
  do ICC._StartTag "chrm"
     (number_of_device_channels : uint 64) <- do (_700 : uint 16) <- Daedalus.BEUInt16
                                                 pure (_700 as uint 64)
     (phosphor_or_colorant : uint 16) <- Daedalus.BEUInt16
     (cie_coords : [ICC.XYNumber]) <- Many[number_of_device_channels] ICC.XYNumber
     pure {phosphor_or_colorant = phosphor_or_colorant,
           cie_coords = cie_coords}
 
ICC.SpectralViewingConditionsType : Grammar ICC.SpectralViewingConditionsType =
  do ICC._StartTag "svcn"
     (colometric_observer : uint 32) <- Daedalus.BEUInt32
     (xxx : [uint 8]) <- Daedalus.Only [uint 8] (Many[] GetByte)
     pure {colometric_observer = colometric_observer,
           xxx = xxx}
 
ICC.XYZType : Grammar [ICC.XYZNumber] =
  do ICC._StartTag "XYZ "
     ($$ : [ICC.XYZNumber]) <- Many[] do ($$ : ICC.XYZNumber) <- ICC.XYZNumber
                                         Choose biased
                                           { Daedalus._Guard (0 <= ($$.x))
                                           | Fail "x value needs to be positive"
                                           }
                                         Choose biased
                                           { Daedalus._Guard (0 <= ($$.y))
                                           | Fail "y value needs to be positive"
                                           }
                                         Choose biased
                                           { Daedalus._Guard (0 <= ($$.z))
                                           | Fail "z value needs to be positive"
                                           }
                                         pure $$
     pure $$
 
ICC.Tag (sig : uint 32) : Grammar ICC.Tag =
  Choose biased
    { case sig is
        { 0s"desc" -> {- case branch  0s"desc" -} do (_702 : ICC.LaxTextType) <- ICC.LaxTextType
                                                     pure {desc: _702}
        ; 0s"A2B0" -> {- case branch  0s"A2B0" -} do (_703 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                                                     pure {A2B0: _703}
        ; 0s"A2B1" -> {- case branch  0s"A2B1" -} do (_704 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                                                     pure {A2B1: _704}
        ; 0s"A2B2" -> {- case branch  0s"A2B2" -} do (_705 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                                                     pure {A2B2: _705}
        ; 0s"A2B3" -> {- case branch  0s"A2B3" -} do (_706 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                                                     pure {A2B3: _706}
        ; 0s"A2M0" -> {- case branch  0s"A2M0" -} do (_707 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {A2M0: _707}
        ; 0s"B2A0" -> {- case branch  0s"B2A0" -} do (_708 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                                                     pure {B2A0: _708}
        ; 0s"B2A1" -> {- case branch  0s"B2A1" -} do (_709 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                                                     pure {B2A1: _709}
        ; 0s"B2A2" -> {- case branch  0s"B2A2" -} do (_710 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                                                     pure {B2A2: _710}
        ; 0s"B2A3" -> {- case branch  0s"B2A3" -} do (_711 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                                                     pure {B2A3: _711}
        ; 0s"B2D0" -> {- case branch  0s"B2D0" -} do (_712 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {B2D0: _712}
        ; 0s"B2D1" -> {- case branch  0s"B2D1" -} do (_713 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {B2D1: _713}
        ; 0s"B2D2" -> {- case branch  0s"B2D2" -} do (_714 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {B2D2: _714}
        ; 0s"B2D3" -> {- case branch  0s"B2D3" -} do (_715 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {B2D3: _715}
        ; 0s"wtpt" -> {- case branch  0s"wtpt" -} do (_716 : [ICC.XYZNumber]) <- Daedalus.Only [ICC.XYZNumber] ICC.XYZType
                                                     pure {wtpt: _716}
        ; 0s"cprt" -> {- case branch  0s"cprt" -} do (_717 : ICC.LaxTextType) <- ICC.LaxTextType
                                                     pure {cprt: _717}
        ; 0s"c2sp" -> {- case branch  0s"c2sp" -} do (_718 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {c2sp: _718}
        ; 0s"s2cp" -> {- case branch  0s"s2cp" -} do (_719 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {s2cp: _719}
        ; 0s"svcn" -> {- case branch  0s"svcn" -} do (_720 : ICC.SpectralViewingConditionsType) <- ICC.SpectralViewingConditionsType
                                                     pure {svcn: _720}
        ; 0s"rXYZ" -> {- case branch  0s"rXYZ" -} do (_721 : [ICC.XYZNumber]) <- Daedalus.Only [ICC.XYZNumber] ICC.XYZType
                                                     pure {rXYZ: _721}
        ; 0s"gXYZ" -> {- case branch  0s"gXYZ" -} do (_722 : [ICC.XYZNumber]) <- Daedalus.Only [ICC.XYZNumber] ICC.XYZType
                                                     pure {gXYZ: _722}
        ; 0s"bXYZ" -> {- case branch  0s"bXYZ" -} do (_723 : [ICC.XYZNumber]) <- Daedalus.Only [ICC.XYZNumber] ICC.XYZType
                                                     pure {bXYZ: _723}
        ; 0s"rTRC" -> {- case branch  0s"rTRC" -} do (_724 : ICC.CurveOrPCurve) <- ICC.CurveOrPCurve
                                                     pure {rTRC: _724}
        ; 0s"gTRC" -> {- case branch  0s"gTRC" -} do (_725 : ICC.CurveOrPCurve) <- ICC.CurveOrPCurve
                                                     pure {gTRC: _725}
        ; 0s"bTRC" -> {- case branch  0s"bTRC" -} do (_726 : ICC.CurveOrPCurve) <- ICC.CurveOrPCurve
                                                     pure {bTRC: _726}
        ; 0s"dmdd" -> {- case branch  0s"dmdd" -} do (_727 : ICC.LaxTextType) <- ICC.LaxTextType
                                                     pure {dmdd: _727}
        ; 0s"dmnd" -> {- case branch  0s"dmnd" -} do (_728 : ICC.LaxTextType) <- ICC.LaxTextType
                                                     pure {dmnd: _728}
        ; 0s"chrm" -> {- case branch  0s"chrm" -} do (_729 : ICC.ChromaticityType) <- ICC.ChromaticityType
                                                     pure {chrm: _729}
        ; 0s"chad" -> {- case branch  0s"chad" -} do (_730 : [uint 32]) <- ICC.S15Fixed16ArrayType
                                                     pure {chad: _730}
        ; _ -> pure {unimplemented: (ICC.explode32 sig)}
        }
    | do (_731 : ICC.InvalidTag) <- ICC.InvalidTag sig
         pure {invalid_tag: _731}
    }
 
ICC.TagTable (s : Stream) : Grammar [ICC.Tag] =
  do (_734 : uint 64) <- do (_733 : uint 32) <- Daedalus.BEUInt32
                            pure (_733 as uint 64)
     Many[_734] do (sig : uint 32) <- Daedalus.BEUInt32
                   ($$ : ICC.Tag) <- ICC.Positioned ICC.Tag s (ICC.Tag sig)
                   pure $$
 
ICC.Main : Grammar ICC.Main =
  do (s : Stream) <- CurrentStream
     (header : ICC.ProfileHeader) <- ICC.ProfileHeader
     (tags : [ICC.Tag]) <- ICC.TagTable s
     pure {header = header,
           tags = tags}
 
ICC.Response16Number : Grammar ICC.Response16Number =
  do (device : uint 16) <- Daedalus.BEUInt16
     ICC._Exactly (uint 16) 0 Daedalus.BEUInt16
     (measurement : uint 32) <- Daedalus.BEUInt32
     pure {device = device,
           measurement = measurement}
 
ICC.StartTag (x : [uint 8]) : Grammar [uint 8] =
  do @MatchBytes x
     ($$ : [uint 8]) <- MatchBytes [0,
                                    0,
                                    0,
                                    0]
     pure $$
 
ICC.DateTimeType : Grammar ICC.DateTimeNumber =
  do ICC._StartTag "dtim"
     ($$ : ICC.DateTimeNumber) <- ICC.DateTimeNumber
     pure $$
 
ICC.SignatureType : Grammar [uint 8] =
  do ICC._StartTag "sig "
     ($$ : [uint 8]) <- Many[4] GetByte
     pure $$
 
ICC.ColorantOrderType : Grammar [uint 8] =
  do ICC._StartTag "clro"
     Daedalus._BEUInt32
     ($$ : [uint 8]) <- Many[] GetByte
     pure $$
 
ICC.Colorant : Grammar ICC.Colorant =
  do (name : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (pcs : [uint 16]) <- Many[3] Daedalus.BEUInt16
     pure {name = name,
           pcs = pcs}
 
ICC.ColorantTableType : Grammar [ICC.Colorant] =
  do ICC._StartTag "clrt"
     (count_of_colorant : uint 64) <- do (_738 : uint 32) <- Daedalus.BEUInt32
                                         pure (_738 as uint 64)
     ($$ : [ICC.Colorant]) <- Many[count_of_colorant] ICC.Colorant
     pure $$
 
ICC.ResponseCurve (n : uint 64) : Grammar ICC.ResponseCurve =
  do (measurement_unit : uint 32) <- Daedalus.BEUInt32
     (counts : [uint 32]) <- Many[n] Daedalus.BEUInt32
     (pcxyzs : [ICC.XYNumber]) <- Many[n] ICC.XYNumber
     (response_arrays : [[ICC.Response16Number]]) <- map ((qi : uint 32) in counts)
                                                       (Many[qi as uint 64] ICC.Response16Number)
     pure {measurement_unit = measurement_unit,
           pcxyzs = pcxyzs,
           response_arrays = response_arrays}
 
ICC.ResponseCurveSet16Type : Grammar [ICC.ResponseCurve] =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "rcs2"
     (number_of_channels : uint 64) <- do (_740 : uint 16) <- Daedalus.BEUInt16
                                          pure (_740 as uint 64)
     (count : uint 64) <- do (_741 : uint 16) <- Daedalus.BEUInt16
                             pure (_741 as uint 64)
     ($$ : [ICC.ResponseCurve]) <- Many[count] do (off : uint 64) <- do (_743 : uint 32) <- Daedalus.BEUInt32
                                                                        pure (_743 as uint 64)
                                                  ($$ : ICC.ResponseCurve) <- Daedalus.LookAhead ICC.ResponseCurve do Daedalus._SetStreamAt off s
                                                                                                                      ($$ : ICC.ResponseCurve) <- ICC.ResponseCurve number_of_channels
                                                                                                                      pure $$
                                                  pure $$
     pure $$
 
ICC.exp ?a0 ?a1 (Arith ?a0) (Integral ?a1) (Literal 1 ?a1) (Literal 0 ?a1) (Literal 1 ?a0) (b : ?a0) (e : ?a1) : ?a0 =
  for ((x : ?a0) = 1; (i : ?a1) in rangeUp 0 e 1)
    (x * b)
 
ICC.Lut8Type : Grammar ICC.Lut8Type =
  do ICC._StartTag "mft1"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {0x00}
     (encoded_e_parameters : [sint 32]) <- Many[9] do (_746 : uint 32) <- Daedalus.BEUInt32
                                                      pure (_746 as sint 32)
     (input_tables : Stream) <- Daedalus.Bytes (256 * i)
     (clut_values : Stream) <- Daedalus.Bytes ((ICC.exp (uint 64) (uint 64) g i) * o)
     (output_tables : Stream) <- Daedalus.Bytes (256 * o)
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           number_of_clut_grid_points = number_of_clut_grid_points,
           encoded_e_parameters = encoded_e_parameters,
           input_tables = input_tables,
           clut_values = clut_values,
           output_tables = output_tables}
 
ICC.Lut16Type : Grammar ICC.Lut16Type =
  do ICC._StartTag "mft2"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {0x00}
     (encoded_e_parameters : [sint 32]) <- Many[9] do (_747 : uint 32) <- Daedalus.BEUInt32
                                                      pure (_747 as sint 32)
     (number_of_input_table_entries : uint 32) <- Daedalus.BEUInt32
     (n : uint 64) <- pure (number_of_input_table_entries as uint 64)
     (number_of_output_table_entries : uint 32) <- Daedalus.BEUInt32
     (m : uint 64) <- pure (number_of_output_table_entries as uint 64)
     (input_tables : Stream) <- Daedalus.Bytes ((256 * n) * i)
     (clut_values : Stream) <- Daedalus.Bytes ((2 * (ICC.exp (uint 64) (uint 64) g i)) * o)
     (output_tables : Stream) <- Daedalus.Bytes ((2 * m) * o)
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           number_of_clut_grid_points = number_of_clut_grid_points,
           encoded_e_parameters = encoded_e_parameters,
           number_of_input_table_entries = number_of_input_table_entries,
           number_of_output_table_entries = number_of_output_table_entries,
           input_tables = input_tables,
           clut_values = clut_values,
           output_tables = output_tables}
 
ICC.LutBToAType : Grammar ICC.LutBToAType =
  do ICC._StartTag "mBA "
     (number_of_input_channels : uint 8) <- GetByte
     (number_of_output_channels : uint 8) <- GetByte
     @MatchBytes [0,
                  0]
     (offset_first_B_curve : uint 32) <- Daedalus.BEUInt32
     (offset_to_matrix : uint 32) <- Daedalus.BEUInt32
     (offset_to_first_M_curve : uint 32) <- Daedalus.BEUInt32
     (offset_to_CLUT : uint 32) <- Daedalus.BEUInt32
     (offset_to_first_A_curve : uint 32) <- Daedalus.BEUInt32
     (data : Stream) <- CurrentStream
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           offset_first_B_curve = offset_first_B_curve,
           offset_to_matrix = offset_to_matrix,
           offset_to_first_M_curve = offset_to_first_M_curve,
           offset_to_CLUT = offset_to_CLUT,
           offset_to_first_A_curve = offset_to_first_A_curve,
           data = data}
 
ICC.MeasurementType : Grammar ICC.MeasurementType =
  do ICC._StartTag "meas"
     (standard_observer : uint 32) <- Daedalus.BEUInt32
     (nCIEXYZ : ICC.XYZNumber) <- ICC.XYZNumber
     (geometry : uint 32) <- Daedalus.BEUInt32
     (flare : uint 32) <- Daedalus.BEUInt32
     (illuminant : uint 32) <- Daedalus.BEUInt32
     pure {standard_observer = standard_observer,
           nCIEXYZ = nCIEXYZ,
           geometry = geometry,
           flare = flare,
           illuminant = illuminant}
 
ICC.ColorName (m : uint 64) : Grammar ICC.ColorName =
  do (name_root : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (pcs_coords : [uint 16]) <- Many[3] Daedalus.BEUInt16
     (device_coords : [uint 16]) <- Many[m] Daedalus.BEUInt16
     pure {name_root = name_root,
           pcs_coords = pcs_coords,
           device_coords = device_coords}
 
ICC.NamedColor2Type : Grammar ICC.NamedColor2Type =
  do ICC._StartTag "ncl2"
     (vendor_specific : uint 32) <- Daedalus.BEUInt32
     (count : uint 64) <- do (_748 : uint 32) <- Daedalus.BEUInt32
                             pure (_748 as uint 64)
     (number_of_coords : uint 64) <- do (_749 : uint 32) <- Daedalus.BEUInt32
                                        pure (_749 as uint 64)
     (prefix : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (suffix : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (names : [ICC.ColorName]) <- Many[count] ICC.ColorName number_of_coords
     pure {vendor_specific = vendor_specific,
           prefix = prefix,
           suffix = suffix,
           names = names}
 
ICC.ViewConditionsType : Grammar ICC.ViewConditionsType =
  do ICC._StartTag "view"
     (illuminantXYZ : ICC.XYZNumber) <- ICC.XYZNumber
     (surroundXYZ : ICC.XYZNumber) <- ICC.XYZNumber
     (illuminant : uint 32) <- Daedalus.BEUInt32
     pure {illuminantXYZ = illuminantXYZ,
           surroundXYZ = surroundXYZ,
           illuminant = illuminant}
 
ICC.funOpChecker : ICC.funOpChecker =
  let stack = 0 in
  {stack = stack}
 
ICC.funOpPush (n : uint 64) (x : ICC.funOpChecker) : ICC.funOpChecker =
  let stack = (x.stack) + n in
  {stack = stack}
 
ICC._FunOpAssert ?a0 (HasStruct ?a0 offset Stream) (op : ?a0) (b : bool) (msg : [uint 8]) : Grammar {} =
  Choose biased
    { Daedalus._Guard b
    | do SetStream (op.offset)
         Fail msg
    }
 
ICC.FunOpPop ?a0 (HasStruct ?a0 offset Stream) (op : ?a0) (n : uint 64) (x : ICC.funOpChecker) : Grammar ICC.funOpChecker =
  do ICC._FunOpAssert ?a0 op (n <= (x.stack)) "Not enough arguments for operation"
     ($$ : ICC.funOpChecker) <- do (stack : uint 64) <- pure ((x.stack) - n)
                                   pure {stack = stack}
     pure $$
 
ICC.funOpStackSize (x : ICC.funOpChecker) : uint 64 =
  x.stack
 
ICC.FunOpAssert ?a0 (HasStruct ?a0 offset Stream) (op : ?a0) (b : bool) (msg : [uint 8]) : Grammar {} =
  Choose biased
    { Daedalus.Guard b
    | do SetStream (op.offset)
         ($$ : {}) <- Fail msg
         pure $$
    }
 
ICC.FunOpArgs ?a0 (HasStruct ?a0 offset Stream) (op : ?a0) (inArgs : uint 64) (outArgs : uint 64) (calc : ICC.funOpChecker) : Grammar ICC.funOpChecker =
  do (_752 : ICC.funOpChecker) <- ICC.FunOpPop ?a0 op inArgs calc
     pure (ICC.funOpPush outArgs _752)
 
rec value
  ICC.CheckFunOps (c : ICC.CalcElement) (ops : [ICC.FunOpWithPosition]) (startCalc : ICC.funOpChecker) : Grammar ICC.funOpChecker =
    for ((calc : ICC.funOpChecker) = startCalc; (op : ICC.FunOpWithPosition) in ops)
      do SetStream (op.offset)
         ($$ : ICC.funOpChecker) <- case op.op is
                                      { {| data = _ |} -> {- case branch  {| data = _ |} -} pure (ICC.funOpPush 1 calc)
                                      ; {| opIn = p |} -> {- case branch  {| opIn = p |} -} do (n : uint 64) <- pure ((p.t) + 1)
                                                                                               ICC._FunOpAssert ICC.FunOpWithPosition op (if ((p.s) < (c.inputs)) then n <= ((c.inputs) - (p.s)) else false) "Invalid channel in `in`"
                                                                                               ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op 0 n calc
                                                                                               pure $$
                                      ; {| opOut = p |} -> {- case branch  {| opOut = p |} -} do (n : uint 64) <- pure ((p.t) + 1)
                                                                                                 ICC._FunOpAssert ICC.FunOpWithPosition op (if ((p.s) < (c.outputs)) then n <= ((c.outputs) - (p.s)) else false) "Invalid channel in `out`"
                                                                                                 ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op n 0 calc
                                                                                                 pure $$
                                      ; {| opTGet = p |} -> {- case branch  {| opTGet = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op 0 ((p.t) + 1) calc
                                      ; {| opTPut = p |} -> {- case branch  {| opTPut = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op ((p.t) + 1) 0 calc
                                      ; {| opTSave = p |} -> {- case branch  {| opTSave = p |} -} do (n : uint 64) <- pure ((p.t) + 1)
                                                                                                     ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op n n calc
                                                                                                     pure $$
                                      ; {| opEnv = _ |} -> {- case branch  {| opEnv = _ |} -} ICC.FunOpArgs ICC.FunOpWithPosition op 0 2 calc
                                      ; {| curv = n |} -> {- case branch  {| curv = n |} -} do (mpe : ICC.MPElement) <- Choose biased
                                                                                                                          { Index (c.subElements) n
                                                                                                                          | Fail "`curv` sub element index out of bounds"
                                                                                                                          }
                                                                                               Choose biased
                                                                                                 { case mpe.body is
                                                                                                     { {| cvst = _757 |} -> pure {}
                                                                                                     }
                                                                                                 | Fail "`curv` argument is not a curve"
                                                                                                 }
                                                                                               (h : ICC.MPElementHead) <- pure (mpe.head)
                                                                                               ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op (h.inputs) (h.outputs) calc
                                                                                               pure $$
                                      ; {| mtx = n |} -> {- case branch  {| mtx = n |} -} do (mpe : ICC.MPElement) <- Choose biased
                                                                                                                        { Index (c.subElements) n
                                                                                                                        | Fail "`mtx` sub element index out of bounds"
                                                                                                                        }
                                                                                             Choose biased
                                                                                               { case mpe.body is
                                                                                                   { {| matf = _759 |} -> pure {}
                                                                                                   }
                                                                                               | Fail "`mtx` sub element is not a matrix"
                                                                                               }
                                                                                             (h : ICC.MPElementHead) <- pure (mpe.head)
                                                                                             ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op (h.inputs) (h.outputs) calc
                                                                                             pure $$
                                      ; {| clut = n |} -> {- case branch  {| clut = n |} -} do (mpe : ICC.MPElement) <- Choose biased
                                                                                                                          { Index (c.subElements) n
                                                                                                                          | Fail "`clut` sub element index out of bounds"
                                                                                                                          }
                                                                                               (h : ICC.MPElementHead) <- pure (mpe.head)
                                                                                               ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op (h.inputs) (h.outputs) calc
                                                                                               pure $$
                                      ; {| calc = n |} -> {- case branch  {| calc = n |} -} do (mpe : ICC.MPElement) <- Choose biased
                                                                                                                          { Index (c.subElements) n
                                                                                                                          | Fail "`calc` sub element index out of bounds"
                                                                                                                          }
                                                                                               Choose biased
                                                                                                 { case mpe.body is
                                                                                                     { {| calc = _762 |} -> pure {}
                                                                                                     }
                                                                                                 | Fail "`calc` arguemtn is not a calculator"
                                                                                                 }
                                                                                               (h : ICC.MPElementHead) <- pure (mpe.head)
                                                                                               ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op (h.inputs) (h.outputs) calc
                                                                                               pure $$
                                      ; {| tint = n |} -> {- case branch  {| tint = n |} -} do (mpe : ICC.MPElement) <- Choose biased
                                                                                                                          { Index (c.subElements) n
                                                                                                                          | Fail "`tint` sub element index out of bounds"
                                                                                                                          }
                                                                                               (h : ICC.MPElementHead) <- pure (mpe.head)
                                                                                               ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op (h.inputs) (h.outputs) calc
                                                                                               pure $$
                                      ; {| elem = n |} -> {- case branch  {| elem = n |} -} do (mpe : ICC.MPElement) <- Choose biased
                                                                                                                          { Index (c.subElements) n
                                                                                                                          | Fail "`elem` sub element index out of bounds"
                                                                                                                          }
                                                                                               (h : ICC.MPElementHead) <- pure (mpe.head)
                                                                                               ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op (h.inputs) (h.outputs) calc
                                                                                               pure $$
                                      ; {| copy = p |} -> {- case branch  {| copy = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op ((p.s) + 1) (((p.s) + 1) * ((p.t) + 2)) calc
                                      ; {| rotl = p |} -> {- case branch  {| rotl = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op ((p.s) + 1) ((p.s) + 1) calc
                                      ; {| rotr = p |} -> {- case branch  {| rotr = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op ((p.s) + 1) ((p.s) + 1) calc
                                      ; {| posd = p |} -> {- case branch  {| posd = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op ((p.s) + 1) (((p.s) + 1) + ((p.t) + 1)) calc
                                      ; {| flip = s |} -> {- case branch  {| flip = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 2) (s + 2) calc
                                      ; {| pop = s |} -> {- case branch  {| pop = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) 0 calc
                                      ; {| solv = p |} -> {- case branch  {| solv = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (((p.s) + 1) * ((p.t) + 2)) ((p.t) + 2) calc
                                      ; {| tran = p |} -> {- case branch  {| tran = p |} -} do (els : uint 64) <- pure (((p.t) + 1) * ((p.s) + 1))
                                                                                               ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op els els calc
                                                                                               pure $$
                                      ; {| sum = n |} -> {- case branch  {| sum = n |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (n + 2) 1 calc
                                      ; {| prod = n |} -> {- case branch  {| prod = n |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (n + 2) 1 calc
                                      ; {| min = n |} -> {- case branch  {| min = n |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (n + 2) 1 calc
                                      ; {| max = n |} -> {- case branch  {| max = n |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (n + 2) 1 calc
                                      ; {| and = n |} -> {- case branch  {| and = n |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (n + 2) 1 calc
                                      ; {| or = n |} -> {- case branch  {| or = n |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (n + 2) 1 calc
                                      ; {| opPi = _ |} -> {- case branch  {| opPi = _ |} -} ICC.FunOpArgs ICC.FunOpWithPosition op 0 1 calc
                                      ; {| opPosInf = _ |} -> {- case branch  {| opPosInf = _ |} -} ICC.FunOpArgs ICC.FunOpWithPosition op 0 1 calc
                                      ; {| opNegInf = _ |} -> {- case branch  {| opNegInf = _ |} -} ICC.FunOpArgs ICC.FunOpWithPosition op 0 1 calc
                                      ; {| opNaN = _ |} -> {- case branch  {| opNaN = _ |} -} ICC.FunOpArgs ICC.FunOpWithPosition op 0 1 calc
                                      ; {| opAdd = s |} -> {- case branch  {| opAdd = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opSub = s |} -> {- case branch  {| opSub = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opMul = s |} -> {- case branch  {| opMul = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opDiv = s |} -> {- case branch  {| opDiv = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opMod = s |} -> {- case branch  {| opMod = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opPow = s |} -> {- case branch  {| opPow = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opGamma = s |} -> {- case branch  {| opGamma = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 2) (s + 1) calc
                                      ; {| opSAdd = s |} -> {- case branch  {| opSAdd = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 2) (s + 1) calc
                                      ; {| opSSub = s |} -> {- case branch  {| opSSub = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 2) (s + 1) calc
                                      ; {| opSMul = s |} -> {- case branch  {| opSMul = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 2) (s + 1) calc
                                      ; {| opSDiv = s |} -> {- case branch  {| opSDiv = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 2) (s + 1) calc
                                      ; {| opSq = s |} -> {- case branch  {| opSq = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opSqrt = s |} -> {- case branch  {| opSqrt = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opCb = s |} -> {- case branch  {| opCb = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opCbrt = s |} -> {- case branch  {| opCbrt = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opAbs = s |} -> {- case branch  {| opAbs = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opNeg = s |} -> {- case branch  {| opNeg = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opRond = s |} -> {- case branch  {| opRond = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opFlor = s |} -> {- case branch  {| opFlor = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opCeil = s |} -> {- case branch  {| opCeil = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opTrnc = s |} -> {- case branch  {| opTrnc = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opSign = s |} -> {- case branch  {| opSign = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opExp = s |} -> {- case branch  {| opExp = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opLog = s |} -> {- case branch  {| opLog = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opLn = s |} -> {- case branch  {| opLn = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opSin = s |} -> {- case branch  {| opSin = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opCos = s |} -> {- case branch  {| opCos = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opTan = s |} -> {- case branch  {| opTan = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opASin = s |} -> {- case branch  {| opASin = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opACos = s |} -> {- case branch  {| opACos = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opATan = s |} -> {- case branch  {| opATan = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opATn2 = s |} -> {- case branch  {| opATn2 = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opCTop = s |} -> {- case branch  {| opCTop = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (2 * (s + 1)) calc
                                      ; {| opPToc = s |} -> {- case branch  {| opPToc = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (2 * (s + 1)) calc
                                      ; {| opRNum = s |} -> {- case branch  {| opRNum = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                      ; {| opLT = s |} -> {- case branch  {| opLT = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opLE = s |} -> {- case branch  {| opLE = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opEQ = s |} -> {- case branch  {| opEQ = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opNear = s |} -> {- case branch  {| opNear = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opGE = s |} -> {- case branch  {| opGE = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opGT = s |} -> {- case branch  {| opGT = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opVMin = s |} -> {- case branch  {| opVMin = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opVMax = s |} -> {- case branch  {| opVMax = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opVAnd = s |} -> {- case branch  {| opVAnd = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opVOr = s |} -> {- case branch  {| opVOr = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                      ; {| opTLab = s |} -> {- case branch  {| opTLab = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (3 * (s + 1)) (3 * (s + 1)) calc
                                      ; {| opTXYZ = s |} -> {- case branch  {| opTXYZ = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (3 * (s + 1)) (3 * (s + 1)) calc
                                      ; {| opIfThen = thenOps |} -> {- case branch  {| opIfThen = thenOps |} -} do (calc1 : ICC.funOpChecker) <- ICC.FunOpPop ICC.FunOpWithPosition op 1 calc
                                                                                                                   (calc2 : ICC.funOpChecker) <- ICC.CheckFunOps c thenOps calc1
                                                                                                                   ICC._FunOpAssert ICC.FunOpWithPosition op (calc1 == calc2) "`if-then` does not preserve the stack size"
                                                                                                                   ($$ : ICC.funOpChecker) <- pure calc1
                                                                                                                   pure $$
                                      ; {| opIfThenElse = ops |} -> {- case branch  {| opIfThenElse = ops |} -} do (calc1 : ICC.funOpChecker) <- ICC.FunOpPop ICC.FunOpWithPosition op 1 calc
                                                                                                                   (calc2 : ICC.funOpChecker) <- ICC.CheckFunOps c (ops.thenOps) calc1
                                                                                                                   (calc3 : ICC.funOpChecker) <- ICC.CheckFunOps c (ops.elseOps) calc1
                                                                                                                   ICC._FunOpAssert ICC.FunOpWithPosition op (calc2 == calc3) "`if-then-else` branches affect stack differently"
                                                                                                                   ($$ : ICC.funOpChecker) <- pure calc2
                                                                                                                   pure $$
                                      ; {| opSel = ops |} -> {- case branch  {| opSel = ops |} -} do (calc1 : ICC.funOpChecker) <- ICC.FunOpPop ICC.FunOpWithPosition op 1 calc
                                                                                                     (res : ICC.funOpChecker) <- ICC.CheckFunOps c (ops.case1) calc1
                                                                                                     do map ((alt : [ICC.FunOpWithPosition]) in ops.cases)
                                                                                                          do (_770 : bool) <- do (_769 : ICC.funOpChecker) <- ICC.CheckFunOps c alt calc1
                                                                                                                                 pure (_769 == res)
                                                                                                             ICC.FunOpAssert ICC.FunOpWithPosition op _770 "`cases` in `sel` affect stack differently"
                                                                                                        pure {}
                                                                                                     case ops.dflt is
                                                                                                       { nothing -> {- case branch  nothing -} ICC._FunOpAssert ICC.FunOpWithPosition op (res == calc1) "`cases` in `sel` with no default do not preserve stack"
                                                                                                       ; just x -> {- case branch  just x -} do (_772 : bool) <- do (_771 : ICC.funOpChecker) <- ICC.CheckFunOps c x calc1
                                                                                                                                                                    pure (_771 == res)
                                                                                                                                                ICC._FunOpAssert ICC.FunOpWithPosition op _772 "`dflt` in `case` has different effect from `case`s"
                                                                                                       }
                                                                                                     ($$ : ICC.funOpChecker) <- pure res
                                                                                                     pure $$
                                      }
         pure $$
 
ICC.CheckFunOpsInCalc (c : ICC.CalcElement) : Grammar {} =
  Choose biased
    { do (_775 : bool) <- do (_774 : ICC.funOpChecker) <- ICC.CheckFunOps c (c.main) ICC.funOpChecker
                             pure (_774 == ICC.funOpChecker)
         Daedalus.Guard _775
    | Fail "Left over elements on the stack"
    }
 
ICC.Exactly ?a0 (x : ?a0) (P : Grammar ?a0) : Grammar {} =
  Choose biased
    { do (_549 : bool) <- do (_548 : ?a0) <- P
                             pure (_548 == x)
         Daedalus.Guard _549
    | Fail "Unexpected field value"
    }
 
ICC.ChunkRelativeTo (s : Stream) (off : uint 64) (sz : uint 64) : Grammar Stream =
  do Daedalus._SetStreamAt off s
     ($$ : Stream) <- Daedalus.Bytes sz
     pure $$
 
ICC._VersionField : Grammar {} =
  do @GetByte
     @GetByte
     @MatchBytes [0x00,
                  0x00]
 
ICC._ProfileClass : Grammar {} =
  do (_538 : uint 32) <- Daedalus.BEUInt32
     case _538 is
       { 0s"scnr" -> {- case branch  0s"scnr" -} pure {}
       ; 0s"mntr" -> {- case branch  0s"mntr" -} pure {}
       ; 0s"prtr" -> {- case branch  0s"prtr" -} pure {}
       ; 0s"link" -> {- case branch  0s"link" -} pure {}
       ; 0s"spac" -> {- case branch  0s"spac" -} pure {}
       ; 0s"abst" -> {- case branch  0s"abst" -} pure {}
       ; 0s"nmcl" -> {- case branch  0s"nmcl" -} pure {}
       ; 0s"cenc" -> {- case branch  0s"cenc" -} pure {}
       ; 0s"mid " -> {- case branch  0s"mid " -} pure {}
       ; 0s"mlnk" -> {- case branch  0s"mlnk" -} pure {}
       ; 0s"mvis" -> {- case branch  0s"mvis" -} pure {}
       }
 
ICC._DataColorSpace : Grammar {} =
  do (tag : uint 32) <- Daedalus.BEUInt32
     case tag is
       { 0s"XYZ " -> {- case branch  0s"XYZ " -} pure {}
       ; 0s"Lab " -> {- case branch  0s"Lab " -} pure {}
       ; 0s"Luv " -> {- case branch  0s"Luv " -} pure {}
       ; 0s"Ycbr" -> {- case branch  0s"Ycbr" -} pure {}
       ; 0s"Yxy " -> {- case branch  0s"Yxy " -} pure {}
       ; 0s"LMS " -> {- case branch  0s"LMS " -} pure {}
       ; 0s"RGB " -> {- case branch  0s"RGB " -} pure {}
       ; 0s"GRAY" -> {- case branch  0s"GRAY" -} pure {}
       ; 0s"HSV " -> {- case branch  0s"HSV " -} pure {}
       ; 0s"HLS " -> {- case branch  0s"HLS " -} pure {}
       ; 0s"CMYK" -> {- case branch  0s"CMYK" -} pure {}
       ; 0s"CMY " -> {- case branch  0s"CMY " -} pure {}
       ; 0s"2CLR" -> {- case branch  0s"2CLR" -} pure {}
       ; 0s"3CLR" -> {- case branch  0s"3CLR" -} pure {}
       ; 0s"4CLR" -> {- case branch  0s"4CLR" -} pure {}
       ; 0s"5CLR" -> {- case branch  0s"5CLR" -} pure {}
       ; 0s"6CLR" -> {- case branch  0s"6CLR" -} pure {}
       ; 0s"7CLR" -> {- case branch  0s"7CLR" -} pure {}
       ; 0s"8CLR" -> {- case branch  0s"8CLR" -} pure {}
       ; 0s"9CLR" -> {- case branch  0s"9CLR" -} pure {}
       ; 0s"ACLR" -> {- case branch  0s"ACLR" -} pure {}
       ; 0s"BCLR" -> {- case branch  0s"BCLR" -} pure {}
       ; 0s"CCLR" -> {- case branch  0s"CCLR" -} pure {}
       ; 0s"DCLR" -> {- case branch  0s"DCLR" -} pure {}
       ; 0s"ECLR" -> {- case branch  0s"ECLR" -} pure {}
       ; 0s"FCLR" -> {- case branch  0s"FCLR" -} pure {}
       ; 0 -> {- case branch  0 -} pure {}
       ; _ -> Daedalus._Guard ((tag >> 16) == 0s"ne")
       }
 
ICC._PrimaryPlatform : Grammar {} =
  do (_541 : uint 32) <- Daedalus.BEUInt32
     case _541 is
       { 0s"APPL" -> {- case branch  0s"APPL" -} pure {}
       ; 0s"MSFT" -> {- case branch  0s"MSFT" -} pure {}
       ; 0s"SGI " -> {- case branch  0s"SGI " -} pure {}
       ; 0s"SUNW" -> {- case branch  0s"SUNW" -} pure {}
       ; 0 -> {- case branch  0 -} pure {}
       }
 
ICC._RenderingIntent : Grammar {} =
  do (_542 : uint 32) <- Daedalus.BEUInt32
     case _542 is
       { 0 -> {- case branch  0 -} pure {}
       ; 1 -> {- case branch  1 -} pure {}
       ; 2 -> {- case branch  2 -} pure {}
       ; 3 -> {- case branch  3 -} pure {}
       }
 
ICC._XYZNumber : Grammar {} =
  do Daedalus._BESInt32
     Daedalus._BESInt32
     Daedalus._BESInt32
 
ICC._DateTimeNumber : Grammar {} =
  do Daedalus._BEUInt16
     Daedalus._BEUInt16
     Daedalus._BEUInt16
     Daedalus._BEUInt16
     Daedalus._BEUInt16
     Daedalus._BEUInt16
 
ICC._ProfileHeader : Grammar {} =
  do Daedalus._BEUInt32
     @Many[4] @GetByte
     ICC._VersionField
     ICC._ProfileClass
     ICC._DataColorSpace
     ICC._DataColorSpace
     ICC._DateTimeNumber
     @MatchBytes "acsp"
     ICC._PrimaryPlatform
     Daedalus._BEUInt32
     @Many[4] @GetByte
     @Many[4] @GetByte
     Daedalus._BEUInt64
     ICC._RenderingIntent
     ICC._XYZNumber
     @Many[4] @GetByte
     @Many[16] @GetByte
     @Many[28] @GetByte
 
ICC._InvalidTag : Grammar {} =
  @Many[] @GetByte
 
ICC._MPElementHead : Grammar {} =
  do Daedalus._BEUInt32
     @MatchBytes [0,
                  0,
                  0,
                  0]
     Daedalus._BEUInt16
     Daedalus._BEUInt16
 
ICC._SelCase : Grammar {} =
  do @MatchBytes "case"
     Daedalus._BEUInt32
 
ICC._OpParam : Grammar {} =
  do Daedalus._BEUInt16
     ICC._Exactly (uint 16) 0 Daedalus.BEUInt16
 
ICC._OpParams : Grammar {} =
  do Daedalus._BEUInt16
     Daedalus._BEUInt16
 
ICC._ManyFunOps (n : uint 64) : Grammar {} =
  Daedalus._Chunk [ICC.FunOpWithPosition] (8 * n) (Daedalus._Only [ICC.FunOpWithPosition] (@Many[] do ICC.FunOpWithPosition
                                                                                                      pure {}))
 
ICC._Sel (alt : uint 64) (alts : [uint 64]) (mbDflt : Maybe (uint 64)) : Grammar {} =
  do ICC._ManyFunOps alt
     do map ((n : uint 64) in alts)
          (ICC.ManyFunOps n)
        pure {}
     case mbDflt is
       { nothing -> {- case branch  nothing -} pure {}
       ; just n -> {- case branch  just n -} ICC._ManyFunOps n
       }
 
ICC._IfThenElse (thenOps : uint 64) (elseOps : uint 64) : Grammar {} =
  do ICC._ManyFunOps thenOps
     ICC._ManyFunOps elseOps
 
ICC._FunOp : Grammar {} =
  do (tag : uint 32) <- Daedalus.BEUInt32
     case tag is
       { 0s"data" -> {- case branch  0s"data" -} Daedalus._BEFloat
       ; 0s"in  " -> {- case branch  0s"in  " -} ICC._OpParams
       ; 0s"out " -> {- case branch  0s"out " -} ICC._OpParams
       ; 0s"tget" -> {- case branch  0s"tget" -} ICC._OpParams
       ; 0s"tput" -> {- case branch  0s"tput" -} ICC._OpParams
       ; 0s"tsav" -> {- case branch  0s"tsav" -} ICC._OpParams
       ; 0s"env " -> {- case branch  0s"env " -} Daedalus._BEUInt32
       ; 0s"curv" -> {- case branch  0s"curv" -} ICC._OpParam
       ; 0s"mtx " -> {- case branch  0s"mtx " -} ICC._OpParam
       ; 0s"clut" -> {- case branch  0s"clut" -} ICC._OpParam
       ; 0s"calc" -> {- case branch  0s"calc" -} ICC._OpParam
       ; 0s"tint" -> {- case branch  0s"tint" -} ICC._OpParam
       ; 0s"elem" -> {- case branch  0s"elem" -} ICC._OpParam
       ; 0s"copy" -> {- case branch  0s"copy" -} ICC._OpParams
       ; 0s"rotl" -> {- case branch  0s"rotl" -} ICC._OpParams
       ; 0s"rotr" -> {- case branch  0s"rotr" -} ICC._OpParams
       ; 0s"posd" -> {- case branch  0s"posd" -} ICC._OpParams
       ; 0s"flip" -> {- case branch  0s"flip" -} ICC._OpParam
       ; 0s"pop " -> {- case branch  0s"pop " -} ICC._OpParam
       ; 0s"solv" -> {- case branch  0s"solv" -} ICC._OpParams
       ; 0s"tran" -> {- case branch  0s"tran" -} ICC._OpParams
       ; 0s"sum " -> {- case branch  0s"sum " -} ICC._OpParam
       ; 0s"prod" -> {- case branch  0s"prod" -} ICC._OpParam
       ; 0s"min " -> {- case branch  0s"min " -} ICC._OpParam
       ; 0s"max " -> {- case branch  0s"max " -} ICC._OpParam
       ; 0s"and " -> {- case branch  0s"and " -} ICC._OpParam
       ; 0s"or  " -> {- case branch  0s"or  " -} ICC._OpParam
       ; 0s"pi  " -> {- case branch  0s"pi  " -} ICC._NoParams
       ; 0s"+INF" -> {- case branch  0s"+INF" -} ICC._NoParams
       ; 0s"-INF" -> {- case branch  0s"-INF" -} ICC._NoParams
       ; 0s"NaN " -> {- case branch  0s"NaN " -} ICC._NoParams
       ; 0s"add " -> {- case branch  0s"add " -} ICC._OpParam
       ; 0s"sub " -> {- case branch  0s"sub " -} ICC._OpParam
       ; 0s"mul " -> {- case branch  0s"mul " -} ICC._OpParam
       ; 0s"div " -> {- case branch  0s"div " -} ICC._OpParam
       ; 0s"mod " -> {- case branch  0s"mod " -} ICC._OpParam
       ; 0s"pow " -> {- case branch  0s"pow " -} ICC._OpParam
       ; 0s"gama" -> {- case branch  0s"gama" -} ICC._OpParam
       ; 0s"sadd" -> {- case branch  0s"sadd" -} ICC._OpParam
       ; 0s"ssub" -> {- case branch  0s"ssub" -} ICC._OpParam
       ; 0s"smul" -> {- case branch  0s"smul" -} ICC._OpParam
       ; 0s"sdiv" -> {- case branch  0s"sdiv" -} ICC._OpParam
       ; 0s"sq  " -> {- case branch  0s"sq  " -} ICC._OpParam
       ; 0s"sqrt" -> {- case branch  0s"sqrt" -} ICC._OpParam
       ; 0s"cb  " -> {- case branch  0s"cb  " -} ICC._OpParam
       ; 0s"cbrt" -> {- case branch  0s"cbrt" -} ICC._OpParam
       ; 0s"abs " -> {- case branch  0s"abs " -} ICC._OpParam
       ; 0s"neg " -> {- case branch  0s"neg " -} ICC._OpParam
       ; 0s"rond" -> {- case branch  0s"rond" -} ICC._OpParam
       ; 0s"flor" -> {- case branch  0s"flor" -} ICC._OpParam
       ; 0s"ceil" -> {- case branch  0s"ceil" -} ICC._OpParam
       ; 0s"trnc" -> {- case branch  0s"trnc" -} ICC._OpParam
       ; 0s"sign" -> {- case branch  0s"sign" -} ICC._OpParam
       ; 0s"exp " -> {- case branch  0s"exp " -} ICC._OpParam
       ; 0s"log " -> {- case branch  0s"log " -} ICC._OpParam
       ; 0s"ln  " -> {- case branch  0s"ln  " -} ICC._OpParam
       ; 0s"sin " -> {- case branch  0s"sin " -} ICC._OpParam
       ; 0s"cos " -> {- case branch  0s"cos " -} ICC._OpParam
       ; 0s"tan " -> {- case branch  0s"tan " -} ICC._OpParam
       ; 0s"asin" -> {- case branch  0s"asin" -} ICC._OpParam
       ; 0s"acos" -> {- case branch  0s"acos" -} ICC._OpParam
       ; 0s"atan" -> {- case branch  0s"atan" -} ICC._OpParam
       ; 0s"atn2" -> {- case branch  0s"atn2" -} ICC._OpParam
       ; 0s"ctop" -> {- case branch  0s"ctop" -} ICC._OpParam
       ; 0s"ptoc" -> {- case branch  0s"ptoc" -} ICC._OpParam
       ; 0s"rnum" -> {- case branch  0s"rnum" -} ICC._OpParam
       ; 0s"lt  " -> {- case branch  0s"lt  " -} ICC._OpParam
       ; 0s"le  " -> {- case branch  0s"le  " -} ICC._OpParam
       ; 0s"eq  " -> {- case branch  0s"eq  " -} ICC._OpParam
       ; 0s"near" -> {- case branch  0s"near" -} ICC._OpParam
       ; 0s"ge  " -> {- case branch  0s"ge  " -} ICC._OpParam
       ; 0s"gt  " -> {- case branch  0s"gt  " -} ICC._OpParam
       ; 0s"vmin" -> {- case branch  0s"vmin" -} ICC._OpParam
       ; 0s"vmax" -> {- case branch  0s"vmax" -} ICC._OpParam
       ; 0s"vand" -> {- case branch  0s"vand" -} ICC._OpParam
       ; 0s"vor " -> {- case branch  0s"vor " -} ICC._OpParam
       ; 0s"tLab" -> {- case branch  0s"tLab" -} ICC._OpParam
       ; 0s"tXYZ" -> {- case branch  0s"tXYZ" -} ICC._OpParam
       ; 0s"if  " -> {- case branch  0s"if  " -} do (thenOps : uint 64) <- do (_640 : uint 32) <- Daedalus.BEUInt32
                                                                              pure (_640 as uint 64)
                                                    (_642 : Maybe [uint 8]) <- Optional (MatchBytes "else")
                                                    case _642 is
                                                      { nothing -> {- case branch  nothing -} ICC._ManyFunOps thenOps
                                                      ; just _ -> {- case branch  just _ -} do (_645 : uint 64) <- do (_644 : uint 32) <- Daedalus.BEUInt32
                                                                                                                      pure (_644 as uint 64)
                                                                                               ICC._IfThenElse thenOps _645
                                                      }
       ; 0s"else" -> {- case branch  0s"else" -} Fail "`else` with no `if"
       ; 0s"sel " -> {- case branch  0s"sel " -} do ICC._NoParams
                                                    (c1 : uint 64) <- ICC.SelCase
                                                    (cs : [uint 64]) <- Many[] ICC.SelCase
                                                    (d : Maybe (uint 64)) <- Optional do @MatchBytes "dflt"
                                                                                         ($$ : uint 64) <- do (_648 : uint 32) <- Daedalus.BEUInt32
                                                                                                              pure (_648 as uint 64)
                                                                                         pure $$
                                                    ICC._Sel c1 cs d
       ; 0s"case" -> {- case branch  0s"case" -} Fail "`case` with no `sel`"
       ; 0s"dflt" -> {- case branch  0s"dflt" -} Fail "`dflt` with no `sel`"
       ; _ -> Fail (concat ["invalid tag: ",
                            ICC.explode32 tag])
       }
 
ICC._FunOpWithPosition : Grammar {} =
  ICC._FunOp
 
ICC._CalcFun : Grammar {} =
  do ICC._StartTag "func"
     (_653 : uint 64) <- do (_652 : uint 32) <- Daedalus.BEUInt32
                            pure (_652 as uint 64)
     ICC._ManyFunOps _653
 
ICC._PositionNumber : Grammar {} =
  do Daedalus._BEUInt32
     Daedalus._BEUInt32
 
ICC._Positioned ?a0 (s : Stream) (_P : Grammar {}) : Grammar {} =
  do (p : ICC.PositionNumber) <- ICC.PositionNumber
     Daedalus._LookAhead ?a0 do Daedalus._SetStreamAt (p.offset) s
                                Daedalus._Chunk ?a0 (p.size) _P
 
ICC._SingleSampledCurve : Grammar {} =
  do Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt16
     Daedalus._BEUInt16
 
ICC._FormualCurveSegment : Grammar {} =
  do (fun : uint 16) <- Daedalus.BEUInt16
     do (_659 : bool) <- do (_658 : uint 16) <- Daedalus.BEUInt16
                            pure (_658 == 0)
        Daedalus._Guard _659
     case fun is
       { 0 -> {- case branch  0 -} @Many[4] Daedalus._BEFloat
       ; 1 -> {- case branch  1 -} @Many[5] Daedalus._BEFloat
       ; 2 -> {- case branch  2 -} @Many[5] Daedalus._BEFloat
       ; 3 -> {- case branch  3 -} @Many[4] Daedalus._BEFloat
       }
 
ICC._CurveSegment : Grammar {} =
  do (tag : uint 32) <- Daedalus.BEUInt32
     ICC._Exactly (uint 32) 0 Daedalus.BEUInt32
     case tag is
       { 0s"parf" -> {- case branch  0s"parf" -} ICC._FormualCurveSegment
       ; 0s"samf" -> {- case branch  0s"samf" -} do (_664 : uint 64) <- do (_663 : uint 32) <- Daedalus.BEUInt32
                                                                           pure (_663 as uint 64)
                                                    @Many[_664] Daedalus._BEFloat
       }
 
ICC._SegmentedCurve : Grammar {} =
  do (n : uint 64) <- do (_666 : uint 16) <- Daedalus.BEUInt16
                         pure (_666 as uint 64)
     Choose biased
       { Daedalus._Guard (1 <= n)
       | Fail "Need at least one curve segment"
       }
     ICC._Exactly (uint 16) 0 Daedalus.BEUInt16
     (bnum : uint 64) <- pure (n - 1)
     @Many[bnum] Daedalus._BEFloat
     @Many[n] ICC._CurveSegment
 
ICC._Curve : Grammar {} =
  do (tag : uint 32) <- Daedalus.BEUInt32
     ICC._Exactly (uint 32) 0 Daedalus.BEUInt32
     case tag is
       { 0s"sngf" -> {- case branch  0s"sngf" -} ICC._SingleSampledCurve
       ; 0s"curf" -> {- case branch  0s"curf" -} ICC._SegmentedCurve
       ; _ -> pure {}
       }
 
ICC._Matrix (p : uint 64) (q : uint 64) : Grammar {} =
  do @Many[q] @Many[p] Daedalus._BEFloat
     @Many[q] Daedalus._BEFloat
 
ICC._MPElement : Grammar {} =
  do (head : ICC.MPElementHead) <- ICC.MPElementHead
     ICC.MPElementBody head
     pure {}
 
ICC._CalcElement (head : ICC.MPElementHead) : Grammar {} =
  do (subElNum : uint 64) <- do (_670 : uint 32) <- Daedalus.BEUInt32
                                pure (_670 as uint 64)
     ICC._Positioned [ICC.FunOpWithPosition] (head.offset) ICC._CalcFun
     @Many[subElNum] ICC._Positioned ICC.MPElement (head.offset) ICC._MPElement
 
ICC._MPElementBody (head : ICC.MPElementHead) : Grammar {} =
  case head.tag is
    { 0s"calc" -> {- case branch  0s"calc" -} ICC._CalcElement head
    ; 0s"cvst" -> {- case branch  0s"cvst" -} @Many[head.inputs] ICC._Positioned ICC.Curve (head.offset) ICC._Curve
    ; 0s"matf" -> {- case branch  0s"matf" -} ICC._Matrix (head.inputs) (head.outputs)
    ; 0s"mpet" -> {- case branch  0s"mpet" -} do (n : uint 64) <- do (_674 : uint 32) <- Daedalus.BEUInt32
                                                                     pure (_674 as uint 64)
                                                 Choose biased
                                                   { Daedalus._Guard (1 <= n)
                                                   | Fail "Need at least one MPE"
                                                   }
                                                 @Many[n] ICC._Positioned ICC.MPElement (head.offset) ICC._MPElement
    ; _ -> pure {}
    }
 
ICC._MultiProcessElementsType : Grammar {} =
  ICC._MPElement
 
ICC._LutAToBType : Grammar {} =
  do ICC._StartTag "mAB "
     @GetByte
     @GetByte
     @MatchBytes [0,
                  0]
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
 
ICC._LutAB_or_multi : Grammar {} =
  Choose biased
    { {- lutAB -} ICC._LutAToBType
    | {- mpe -} ICC._MultiProcessElementsType
    }
 
ICC._LutBA_or_multi : Grammar {} =
  Choose biased
    { {- lutBA -} ICC._LutAToBType
    | {- mpe -} ICC._MultiProcessElementsType
    }
 
ICC._CurveType : Grammar {} =
  do ICC._StartTag "curv"
     (n : uint 64) <- do (_681 : uint 32) <- Daedalus.BEUInt32
                         pure (_681 as uint 64)
     @Many[n] Daedalus._BEUInt16
 
ICC._ParametricCurveType : Grammar {} =
  do ICC._StartTag "para"
     Daedalus._BEUInt16
     @MatchBytes [0,
                  0]
     @Many[] Daedalus._BEUInt32
 
ICC._CurveOrPCurve : Grammar {} =
  Choose biased
    { {- curve -} ICC._CurveType
    | {- pcurve -} ICC._ParametricCurveType
    }
 
ICC._ASCII7 : Grammar {} =
  do @Many[] do (_685 : uint 8) <- Match (1 .. 255)
                @(_685 AS uint 7)
     Choose biased
       { @Many[ 1 .. ] @Match {0}
       | Fail "Non 0 string terminator"
       }
 
ICC._TextType : Grammar {} =
  do ICC._StartTag "text"
     ICC._ASCII7
 
ICC._UnicodeRecord (s : Stream) : Grammar {} =
  do @Many[2] @GetByte
     @Many[2] @GetByte
     ICC._Positioned [uint 8] s (@Many[] @GetByte)
 
ICC._MultiLocalizedUnicodeType : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "mluc"
     (record_number : uint 32) <- Daedalus.BEUInt32
     ICC._Exactly (uint 32) 12 Daedalus.BEUInt32
     @Many[record_number as uint 64] ICC._UnicodeRecord s
 
ICC._TextDescriptionType : Grammar {} =
  do ICC._StartTag "desc"
     do (_689 : uint 64) <- do (_688 : uint 32) <- Daedalus.BEUInt32
                               pure (_688 as uint 64)
        @Many[_689] @GetByte
     @Many[4] @GetByte
     do (_692 : uint 64) <- do (_691 : uint 32) <- do (_690 : uint 32) <- Daedalus.BEUInt32
                                                      pure (2 * _690)
                               pure (_691 as uint 64)
        @Many[_692] @GetByte
     @Many[2] @GetByte
     Daedalus._BEUInt32
     do (_695 : uint 64) <- do (_694 : uint 32) <- Daedalus.BEUInt32
                               pure (_694 as uint 64)
        @Many[_695] @GetByte
     @Many[] @Match {0}
 
ICC._LaxTextType : Grammar {} =
  Choose biased
    { {- uni -} ICC._MultiLocalizedUnicodeType
    | {- desc -} Daedalus._Only ICC.TextDescriptionType ICC._TextDescriptionType
    | {- text -} Daedalus._Only [uint 7] ICC._TextType
    }
 
ICC._S15Fixed16ArrayType : Grammar {} =
  Daedalus._Only [uint 32] do ICC._StartTag "sf32"
                              @Many[] Daedalus._BEUInt32
 
ICC._XYNumber : Grammar {} =
  do Daedalus._BEUInt32
     Daedalus._BEUInt32
 
ICC._ChromaticityType : Grammar {} =
  do ICC._StartTag "chrm"
     (number_of_device_channels : uint 64) <- do (_700 : uint 16) <- Daedalus.BEUInt16
                                                 pure (_700 as uint 64)
     Daedalus._BEUInt16
     @Many[number_of_device_channels] ICC._XYNumber
 
ICC._SpectralViewingConditionsType : Grammar {} =
  do ICC._StartTag "svcn"
     Daedalus._BEUInt32
     Daedalus._Only [uint 8] (@Many[] @GetByte)
 
ICC._XYZType : Grammar {} =
  do ICC._StartTag "XYZ "
     @Many[] do ($$ : ICC.XYZNumber) <- ICC.XYZNumber
                Choose biased
                  { Daedalus._Guard (0 <= ($$.x))
                  | Fail "x value needs to be positive"
                  }
                Choose biased
                  { Daedalus._Guard (0 <= ($$.y))
                  | Fail "y value needs to be positive"
                  }
                Choose biased
                  { Daedalus._Guard (0 <= ($$.z))
                  | Fail "z value needs to be positive"
                  }
 
ICC._Tag (sig : uint 32) : Grammar {} =
  Choose biased
    { case sig is
        { 0s"desc" -> {- case branch  0s"desc" -} ICC._LaxTextType
        ; 0s"A2B0" -> {- case branch  0s"A2B0" -} ICC._LutAB_or_multi
        ; 0s"A2B1" -> {- case branch  0s"A2B1" -} ICC._LutAB_or_multi
        ; 0s"A2B2" -> {- case branch  0s"A2B2" -} ICC._LutAB_or_multi
        ; 0s"A2B3" -> {- case branch  0s"A2B3" -} ICC._LutAB_or_multi
        ; 0s"A2M0" -> {- case branch  0s"A2M0" -} ICC._MultiProcessElementsType
        ; 0s"B2A0" -> {- case branch  0s"B2A0" -} ICC._LutBA_or_multi
        ; 0s"B2A1" -> {- case branch  0s"B2A1" -} ICC._LutBA_or_multi
        ; 0s"B2A2" -> {- case branch  0s"B2A2" -} ICC._LutBA_or_multi
        ; 0s"B2A3" -> {- case branch  0s"B2A3" -} ICC._LutBA_or_multi
        ; 0s"B2D0" -> {- case branch  0s"B2D0" -} ICC._MultiProcessElementsType
        ; 0s"B2D1" -> {- case branch  0s"B2D1" -} ICC._MultiProcessElementsType
        ; 0s"B2D2" -> {- case branch  0s"B2D2" -} ICC._MultiProcessElementsType
        ; 0s"B2D3" -> {- case branch  0s"B2D3" -} ICC._MultiProcessElementsType
        ; 0s"wtpt" -> {- case branch  0s"wtpt" -} Daedalus._Only [ICC.XYZNumber] ICC._XYZType
        ; 0s"cprt" -> {- case branch  0s"cprt" -} ICC._LaxTextType
        ; 0s"c2sp" -> {- case branch  0s"c2sp" -} ICC._MultiProcessElementsType
        ; 0s"s2cp" -> {- case branch  0s"s2cp" -} ICC._MultiProcessElementsType
        ; 0s"svcn" -> {- case branch  0s"svcn" -} ICC._SpectralViewingConditionsType
        ; 0s"rXYZ" -> {- case branch  0s"rXYZ" -} Daedalus._Only [ICC.XYZNumber] ICC._XYZType
        ; 0s"gXYZ" -> {- case branch  0s"gXYZ" -} Daedalus._Only [ICC.XYZNumber] ICC._XYZType
        ; 0s"bXYZ" -> {- case branch  0s"bXYZ" -} Daedalus._Only [ICC.XYZNumber] ICC._XYZType
        ; 0s"rTRC" -> {- case branch  0s"rTRC" -} ICC._CurveOrPCurve
        ; 0s"gTRC" -> {- case branch  0s"gTRC" -} ICC._CurveOrPCurve
        ; 0s"bTRC" -> {- case branch  0s"bTRC" -} ICC._CurveOrPCurve
        ; 0s"dmdd" -> {- case branch  0s"dmdd" -} ICC._LaxTextType
        ; 0s"dmnd" -> {- case branch  0s"dmnd" -} ICC._LaxTextType
        ; 0s"chrm" -> {- case branch  0s"chrm" -} ICC._ChromaticityType
        ; 0s"chad" -> {- case branch  0s"chad" -} ICC._S15Fixed16ArrayType
        ; _ -> pure {}
        }
    | ICC._InvalidTag
    }
 
ICC._TagTable (s : Stream) : Grammar {} =
  do (_734 : uint 64) <- do (_733 : uint 32) <- Daedalus.BEUInt32
                            pure (_733 as uint 64)
     @Many[_734] do (sig : uint 32) <- Daedalus.BEUInt32
                    ICC._Positioned ICC.Tag s (ICC._Tag sig)
 
ICC._Main : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._ProfileHeader
     ICC._TagTable s
 
ICC._Response16Number : Grammar {} =
  do Daedalus._BEUInt16
     ICC._Exactly (uint 16) 0 Daedalus.BEUInt16
     Daedalus._BEUInt32
 
ICC._DateTimeType : Grammar {} =
  do ICC._StartTag "dtim"
     ICC._DateTimeNumber
 
ICC._SignatureType : Grammar {} =
  do ICC._StartTag "sig "
     @Many[4] @GetByte
 
ICC._ColorantOrderType : Grammar {} =
  do ICC._StartTag "clro"
     Daedalus._BEUInt32
     @Many[] @GetByte
 
ICC._Colorant : Grammar {} =
  do Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     @Many[3] Daedalus._BEUInt16
 
ICC._ColorantTableType : Grammar {} =
  do ICC._StartTag "clrt"
     (count_of_colorant : uint 64) <- do (_738 : uint 32) <- Daedalus.BEUInt32
                                         pure (_738 as uint 64)
     @Many[count_of_colorant] ICC._Colorant
 
ICC._ResponseCurve (n : uint 64) : Grammar {} =
  do Daedalus._BEUInt32
     (counts : [uint 32]) <- Many[n] Daedalus.BEUInt32
     @Many[n] ICC._XYNumber
     map ((qi : uint 32) in counts)
       (Many[qi as uint 64] ICC.Response16Number)
     pure {}
 
ICC._ResponseCurveSet16Type : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "rcs2"
     (number_of_channels : uint 64) <- do (_740 : uint 16) <- Daedalus.BEUInt16
                                          pure (_740 as uint 64)
     (count : uint 64) <- do (_741 : uint 16) <- Daedalus.BEUInt16
                             pure (_741 as uint 64)
     @Many[count] do (off : uint 64) <- do (_743 : uint 32) <- Daedalus.BEUInt32
                                           pure (_743 as uint 64)
                     Daedalus._LookAhead ICC.ResponseCurve do Daedalus._SetStreamAt off s
                                                              ICC._ResponseCurve number_of_channels
 
ICC._Lut8Type : Grammar {} =
  do ICC._StartTag "mft1"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {0x00}
     @Many[9] Daedalus._BEUInt32
     Daedalus._Bytes (256 * i)
     Daedalus._Bytes ((ICC.exp (uint 64) (uint 64) g i) * o)
     Daedalus._Bytes (256 * o)
 
ICC._Lut16Type : Grammar {} =
  do ICC._StartTag "mft2"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {0x00}
     @Many[9] Daedalus._BEUInt32
     (number_of_input_table_entries : uint 32) <- Daedalus.BEUInt32
     (n : uint 64) <- pure (number_of_input_table_entries as uint 64)
     (number_of_output_table_entries : uint 32) <- Daedalus.BEUInt32
     (m : uint 64) <- pure (number_of_output_table_entries as uint 64)
     Daedalus._Bytes ((256 * n) * i)
     Daedalus._Bytes ((2 * (ICC.exp (uint 64) (uint 64) g i)) * o)
     Daedalus._Bytes ((2 * m) * o)
 
ICC._LutBToAType : Grammar {} =
  do ICC._StartTag "mBA "
     @GetByte
     @GetByte
     @MatchBytes [0,
                  0]
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
 
ICC._MeasurementType : Grammar {} =
  do ICC._StartTag "meas"
     Daedalus._BEUInt32
     ICC._XYZNumber
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
 
ICC._ColorName (m : uint 64) : Grammar {} =
  do Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     @Many[3] Daedalus._BEUInt16
     @Many[m] Daedalus._BEUInt16
 
ICC._NamedColor2Type : Grammar {} =
  do ICC._StartTag "ncl2"
     Daedalus._BEUInt32
     (count : uint 64) <- do (_748 : uint 32) <- Daedalus.BEUInt32
                             pure (_748 as uint 64)
     (number_of_coords : uint 64) <- do (_749 : uint 32) <- Daedalus.BEUInt32
                                        pure (_749 as uint 64)
     Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     @Many[count] ICC._ColorName number_of_coords
 
ICC._ViewConditionsType : Grammar {} =
  do ICC._StartTag "view"
     ICC._XYZNumber
     ICC._XYZNumber
     Daedalus._BEUInt32
 
ICC._FunOpPop ?a0 (HasStruct ?a0 offset Stream) (op : ?a0) (n : uint 64) (x : ICC.funOpChecker) : Grammar {} =
  ICC._FunOpAssert ?a0 op (n <= (x.stack)) "Not enough arguments for operation"
 
ICC._FunOpArgs ?a0 (HasStruct ?a0 offset Stream) (op : ?a0) (inArgs : uint 64) (calc : ICC.funOpChecker) : Grammar {} =
  ICC._FunOpPop ?a0 op inArgs calc
 
ICC._CheckFunOps (c : ICC.CalcElement) (ops : [ICC.FunOpWithPosition]) (startCalc : ICC.funOpChecker) : Grammar {} =
  do for ((calc : ICC.funOpChecker) = startCalc; (op : ICC.FunOpWithPosition) in ops)
       do SetStream (op.offset)
          ($$ : ICC.funOpChecker) <- case op.op is
                                       { {| data = _ |} -> {- case branch  {| data = _ |} -} pure (ICC.funOpPush 1 calc)
                                       ; {| opIn = p |} -> {- case branch  {| opIn = p |} -} do (n : uint 64) <- pure ((p.t) + 1)
                                                                                                ICC._FunOpAssert ICC.FunOpWithPosition op (if ((p.s) < (c.inputs)) then n <= ((c.inputs) - (p.s)) else false) "Invalid channel in `in`"
                                                                                                ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op 0 n calc
                                                                                                pure $$
                                       ; {| opOut = p |} -> {- case branch  {| opOut = p |} -} do (n : uint 64) <- pure ((p.t) + 1)
                                                                                                  ICC._FunOpAssert ICC.FunOpWithPosition op (if ((p.s) < (c.outputs)) then n <= ((c.outputs) - (p.s)) else false) "Invalid channel in `out`"
                                                                                                  ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op n 0 calc
                                                                                                  pure $$
                                       ; {| opTGet = p |} -> {- case branch  {| opTGet = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op 0 ((p.t) + 1) calc
                                       ; {| opTPut = p |} -> {- case branch  {| opTPut = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op ((p.t) + 1) 0 calc
                                       ; {| opTSave = p |} -> {- case branch  {| opTSave = p |} -} do (n : uint 64) <- pure ((p.t) + 1)
                                                                                                      ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op n n calc
                                                                                                      pure $$
                                       ; {| opEnv = _ |} -> {- case branch  {| opEnv = _ |} -} ICC.FunOpArgs ICC.FunOpWithPosition op 0 2 calc
                                       ; {| curv = n |} -> {- case branch  {| curv = n |} -} do (mpe : ICC.MPElement) <- Choose biased
                                                                                                                           { Index (c.subElements) n
                                                                                                                           | Fail "`curv` sub element index out of bounds"
                                                                                                                           }
                                                                                                Choose biased
                                                                                                  { case mpe.body is
                                                                                                      { {| cvst = _757 |} -> pure {}
                                                                                                      }
                                                                                                  | Fail "`curv` argument is not a curve"
                                                                                                  }
                                                                                                (h : ICC.MPElementHead) <- pure (mpe.head)
                                                                                                ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op (h.inputs) (h.outputs) calc
                                                                                                pure $$
                                       ; {| mtx = n |} -> {- case branch  {| mtx = n |} -} do (mpe : ICC.MPElement) <- Choose biased
                                                                                                                         { Index (c.subElements) n
                                                                                                                         | Fail "`mtx` sub element index out of bounds"
                                                                                                                         }
                                                                                              Choose biased
                                                                                                { case mpe.body is
                                                                                                    { {| matf = _759 |} -> pure {}
                                                                                                    }
                                                                                                | Fail "`mtx` sub element is not a matrix"
                                                                                                }
                                                                                              (h : ICC.MPElementHead) <- pure (mpe.head)
                                                                                              ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op (h.inputs) (h.outputs) calc
                                                                                              pure $$
                                       ; {| clut = n |} -> {- case branch  {| clut = n |} -} do (mpe : ICC.MPElement) <- Choose biased
                                                                                                                           { Index (c.subElements) n
                                                                                                                           | Fail "`clut` sub element index out of bounds"
                                                                                                                           }
                                                                                                (h : ICC.MPElementHead) <- pure (mpe.head)
                                                                                                ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op (h.inputs) (h.outputs) calc
                                                                                                pure $$
                                       ; {| calc = n |} -> {- case branch  {| calc = n |} -} do (mpe : ICC.MPElement) <- Choose biased
                                                                                                                           { Index (c.subElements) n
                                                                                                                           | Fail "`calc` sub element index out of bounds"
                                                                                                                           }
                                                                                                Choose biased
                                                                                                  { case mpe.body is
                                                                                                      { {| calc = _762 |} -> pure {}
                                                                                                      }
                                                                                                  | Fail "`calc` arguemtn is not a calculator"
                                                                                                  }
                                                                                                (h : ICC.MPElementHead) <- pure (mpe.head)
                                                                                                ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op (h.inputs) (h.outputs) calc
                                                                                                pure $$
                                       ; {| tint = n |} -> {- case branch  {| tint = n |} -} do (mpe : ICC.MPElement) <- Choose biased
                                                                                                                           { Index (c.subElements) n
                                                                                                                           | Fail "`tint` sub element index out of bounds"
                                                                                                                           }
                                                                                                (h : ICC.MPElementHead) <- pure (mpe.head)
                                                                                                ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op (h.inputs) (h.outputs) calc
                                                                                                pure $$
                                       ; {| elem = n |} -> {- case branch  {| elem = n |} -} do (mpe : ICC.MPElement) <- Choose biased
                                                                                                                           { Index (c.subElements) n
                                                                                                                           | Fail "`elem` sub element index out of bounds"
                                                                                                                           }
                                                                                                (h : ICC.MPElementHead) <- pure (mpe.head)
                                                                                                ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op (h.inputs) (h.outputs) calc
                                                                                                pure $$
                                       ; {| copy = p |} -> {- case branch  {| copy = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op ((p.s) + 1) (((p.s) + 1) * ((p.t) + 2)) calc
                                       ; {| rotl = p |} -> {- case branch  {| rotl = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op ((p.s) + 1) ((p.s) + 1) calc
                                       ; {| rotr = p |} -> {- case branch  {| rotr = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op ((p.s) + 1) ((p.s) + 1) calc
                                       ; {| posd = p |} -> {- case branch  {| posd = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op ((p.s) + 1) (((p.s) + 1) + ((p.t) + 1)) calc
                                       ; {| flip = s |} -> {- case branch  {| flip = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 2) (s + 2) calc
                                       ; {| pop = s |} -> {- case branch  {| pop = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) 0 calc
                                       ; {| solv = p |} -> {- case branch  {| solv = p |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (((p.s) + 1) * ((p.t) + 2)) ((p.t) + 2) calc
                                       ; {| tran = p |} -> {- case branch  {| tran = p |} -} do (els : uint 64) <- pure (((p.t) + 1) * ((p.s) + 1))
                                                                                                ($$ : ICC.funOpChecker) <- ICC.FunOpArgs ICC.FunOpWithPosition op els els calc
                                                                                                pure $$
                                       ; {| sum = n |} -> {- case branch  {| sum = n |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (n + 2) 1 calc
                                       ; {| prod = n |} -> {- case branch  {| prod = n |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (n + 2) 1 calc
                                       ; {| min = n |} -> {- case branch  {| min = n |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (n + 2) 1 calc
                                       ; {| max = n |} -> {- case branch  {| max = n |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (n + 2) 1 calc
                                       ; {| and = n |} -> {- case branch  {| and = n |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (n + 2) 1 calc
                                       ; {| or = n |} -> {- case branch  {| or = n |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (n + 2) 1 calc
                                       ; {| opPi = _ |} -> {- case branch  {| opPi = _ |} -} ICC.FunOpArgs ICC.FunOpWithPosition op 0 1 calc
                                       ; {| opPosInf = _ |} -> {- case branch  {| opPosInf = _ |} -} ICC.FunOpArgs ICC.FunOpWithPosition op 0 1 calc
                                       ; {| opNegInf = _ |} -> {- case branch  {| opNegInf = _ |} -} ICC.FunOpArgs ICC.FunOpWithPosition op 0 1 calc
                                       ; {| opNaN = _ |} -> {- case branch  {| opNaN = _ |} -} ICC.FunOpArgs ICC.FunOpWithPosition op 0 1 calc
                                       ; {| opAdd = s |} -> {- case branch  {| opAdd = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opSub = s |} -> {- case branch  {| opSub = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opMul = s |} -> {- case branch  {| opMul = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opDiv = s |} -> {- case branch  {| opDiv = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opMod = s |} -> {- case branch  {| opMod = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opPow = s |} -> {- case branch  {| opPow = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opGamma = s |} -> {- case branch  {| opGamma = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 2) (s + 1) calc
                                       ; {| opSAdd = s |} -> {- case branch  {| opSAdd = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 2) (s + 1) calc
                                       ; {| opSSub = s |} -> {- case branch  {| opSSub = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 2) (s + 1) calc
                                       ; {| opSMul = s |} -> {- case branch  {| opSMul = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 2) (s + 1) calc
                                       ; {| opSDiv = s |} -> {- case branch  {| opSDiv = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 2) (s + 1) calc
                                       ; {| opSq = s |} -> {- case branch  {| opSq = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opSqrt = s |} -> {- case branch  {| opSqrt = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opCb = s |} -> {- case branch  {| opCb = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opCbrt = s |} -> {- case branch  {| opCbrt = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opAbs = s |} -> {- case branch  {| opAbs = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opNeg = s |} -> {- case branch  {| opNeg = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opRond = s |} -> {- case branch  {| opRond = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opFlor = s |} -> {- case branch  {| opFlor = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opCeil = s |} -> {- case branch  {| opCeil = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opTrnc = s |} -> {- case branch  {| opTrnc = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opSign = s |} -> {- case branch  {| opSign = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opExp = s |} -> {- case branch  {| opExp = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opLog = s |} -> {- case branch  {| opLog = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opLn = s |} -> {- case branch  {| opLn = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opSin = s |} -> {- case branch  {| opSin = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opCos = s |} -> {- case branch  {| opCos = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opTan = s |} -> {- case branch  {| opTan = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opASin = s |} -> {- case branch  {| opASin = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opACos = s |} -> {- case branch  {| opACos = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opATan = s |} -> {- case branch  {| opATan = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opATn2 = s |} -> {- case branch  {| opATn2 = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opCTop = s |} -> {- case branch  {| opCTop = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (2 * (s + 1)) calc
                                       ; {| opPToc = s |} -> {- case branch  {| opPToc = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (2 * (s + 1)) calc
                                       ; {| opRNum = s |} -> {- case branch  {| opRNum = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (s + 1) (s + 1) calc
                                       ; {| opLT = s |} -> {- case branch  {| opLT = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opLE = s |} -> {- case branch  {| opLE = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opEQ = s |} -> {- case branch  {| opEQ = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opNear = s |} -> {- case branch  {| opNear = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opGE = s |} -> {- case branch  {| opGE = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opGT = s |} -> {- case branch  {| opGT = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opVMin = s |} -> {- case branch  {| opVMin = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opVMax = s |} -> {- case branch  {| opVMax = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opVAnd = s |} -> {- case branch  {| opVAnd = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opVOr = s |} -> {- case branch  {| opVOr = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (2 * (s + 1)) (s + 1) calc
                                       ; {| opTLab = s |} -> {- case branch  {| opTLab = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (3 * (s + 1)) (3 * (s + 1)) calc
                                       ; {| opTXYZ = s |} -> {- case branch  {| opTXYZ = s |} -} ICC.FunOpArgs ICC.FunOpWithPosition op (3 * (s + 1)) (3 * (s + 1)) calc
                                       ; {| opIfThen = thenOps |} -> {- case branch  {| opIfThen = thenOps |} -} do (calc1 : ICC.funOpChecker) <- ICC.FunOpPop ICC.FunOpWithPosition op 1 calc
                                                                                                                    (calc2 : ICC.funOpChecker) <- ICC.CheckFunOps c thenOps calc1
                                                                                                                    ICC._FunOpAssert ICC.FunOpWithPosition op (calc1 == calc2) "`if-then` does not preserve the stack size"
                                                                                                                    ($$ : ICC.funOpChecker) <- pure calc1
                                                                                                                    pure $$
                                       ; {| opIfThenElse = ops |} -> {- case branch  {| opIfThenElse = ops |} -} do (calc1 : ICC.funOpChecker) <- ICC.FunOpPop ICC.FunOpWithPosition op 1 calc
                                                                                                                    (calc2 : ICC.funOpChecker) <- ICC.CheckFunOps c (ops.thenOps) calc1
                                                                                                                    (calc3 : ICC.funOpChecker) <- ICC.CheckFunOps c (ops.elseOps) calc1
                                                                                                                    ICC._FunOpAssert ICC.FunOpWithPosition op (calc2 == calc3) "`if-then-else` branches affect stack differently"
                                                                                                                    ($$ : ICC.funOpChecker) <- pure calc2
                                                                                                                    pure $$
                                       ; {| opSel = ops |} -> {- case branch  {| opSel = ops |} -} do (calc1 : ICC.funOpChecker) <- ICC.FunOpPop ICC.FunOpWithPosition op 1 calc
                                                                                                      (res : ICC.funOpChecker) <- ICC.CheckFunOps c (ops.case1) calc1
                                                                                                      do map ((alt : [ICC.FunOpWithPosition]) in ops.cases)
                                                                                                           do (_770 : bool) <- do (_769 : ICC.funOpChecker) <- ICC.CheckFunOps c alt calc1
                                                                                                                                  pure (_769 == res)
                                                                                                              ICC.FunOpAssert ICC.FunOpWithPosition op _770 "`cases` in `sel` affect stack differently"
                                                                                                         pure {}
                                                                                                      case ops.dflt is
                                                                                                        { nothing -> {- case branch  nothing -} ICC._FunOpAssert ICC.FunOpWithPosition op (res == calc1) "`cases` in `sel` with no default do not preserve stack"
                                                                                                        ; just x -> {- case branch  just x -} do (_772 : bool) <- do (_771 : ICC.funOpChecker) <- ICC.CheckFunOps c x calc1
                                                                                                                                                                     pure (_771 == res)
                                                                                                                                                 ICC._FunOpAssert ICC.FunOpWithPosition op _772 "`dflt` in `case` has different effect from `case`s"
                                                                                                        }
                                                                                                      ($$ : ICC.funOpChecker) <- pure res
                                                                                                      pure $$
                                       }
          pure $$
     pure {}
 
ICC._CheckFunOpsInCalc (c : ICC.CalcElement) : Grammar {} =
  Choose biased
    { do (_775 : bool) <- do (_774 : ICC.funOpChecker) <- ICC.CheckFunOps c (c.main) ICC.funOpChecker
                             pure (_774 == ICC.funOpChecker)
         Daedalus._Guard _775
    | Fail "Left over elements on the stack"
    }
 
ICC._ChunkRelativeTo (s : Stream) (off : uint 64) (sz : uint 64) : Grammar {} =
  do Daedalus._SetStreamAt off s
     Daedalus._Bytes sz
