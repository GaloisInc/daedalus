module Daedalus
 
--- Imports:
 
--- Type defs:
 
--- Rules:
 
Daedalus.joinWords ?a0 ?a1 ?a2 (?a0 + ?a1 = ?a2) (?a1 + ?a0 = ?a2) (_352 : bool) (a : uint ?a0) (b : uint ?a1) : uint ?a2 =
  if _352 then a # b else b # a
 
Daedalus.UInt16 (_353 : bool) : Grammar (uint 16) =
  do (_354 : uint 8) <- GetByte
     (_355 : uint 8) <- GetByte
     pure (Daedalus.joinWords 8 8 16 _353 _354 _355)
 
Daedalus.UInt32 (_356 : bool) : Grammar (uint 32) =
  do (_357 : uint 16) <- Daedalus.UInt16 _356
     (_358 : uint 16) <- Daedalus.UInt16 _356
     pure (Daedalus.joinWords 16 16 32 _356 _357 _358)
 
Daedalus.UInt64 (_359 : bool) : Grammar (uint 64) =
  do (_360 : uint 32) <- Daedalus.UInt32 _359
     (_361 : uint 32) <- Daedalus.UInt32 _359
     pure (Daedalus.joinWords 32 32 64 _359 _360 _361)
 
Daedalus.SInt16 (_362 : bool) : Grammar (sint 16) =
  do (_363 : uint 16) <- Daedalus.UInt16 _362
     pure (_363 as sint 16)
 
Daedalus.SInt32 (_364 : bool) : Grammar (sint 32) =
  do (_365 : uint 32) <- Daedalus.UInt32 _364
     pure (_365 as sint 32)
 
Daedalus.SInt64 (_366 : bool) : Grammar (sint 64) =
  do (_367 : uint 64) <- Daedalus.UInt64 _366
     pure (_367 as sint 64)
 
Daedalus.wordToHalfFloat (w : uint 16) : float =
  let sign = w >> 15 as uint 1 in
  let expo = w >> 10 as uint 5 in
  let mant = w as uint 10 in
  if (expo == 0) then let magic = 126 << 23 in
                      let num = (wordToFloat (magic + (0 # mant))) - (wordToFloat magic) in
                      if (sign == 1) then - num else num else let newExp = if (expo == 0x1F) then 0xFF else (127 - 15) + (0 # expo) in
                                                              wordToFloat (((sign # newExp) # mant) # 0)
 
Daedalus.HalfFloat (_368 : bool) : Grammar float =
  do (_369 : uint 16) <- Daedalus.UInt16 _368
     pure (Daedalus.wordToHalfFloat _369)
 
Daedalus.Float (_370 : bool) : Grammar float =
  do (_371 : uint 32) <- Daedalus.UInt32 _370
     pure (wordToFloat _371)
 
Daedalus.Double (_372 : bool) : Grammar double =
  do (_373 : uint 64) <- Daedalus.UInt64 _372
     pure (wordToDouble _373)
 
Daedalus.BEUInt16 : Grammar (uint 16) =
  do (_374 : bool) <- pure true
     ($$ : uint 16) <- Daedalus.UInt16 _374
     pure $$
 
Daedalus.BEUInt32 : Grammar (uint 32) =
  do (_376 : bool) <- pure true
     ($$ : uint 32) <- Daedalus.UInt32 _376
     pure $$
 
Daedalus.BEUInt64 : Grammar (uint 64) =
  do (_378 : bool) <- pure true
     ($$ : uint 64) <- Daedalus.UInt64 _378
     pure $$
 
Daedalus.BESInt16 : Grammar (sint 16) =
  do (_380 : bool) <- pure true
     ($$ : sint 16) <- Daedalus.SInt16 _380
     pure $$
 
Daedalus.BESInt32 : Grammar (sint 32) =
  do (_382 : bool) <- pure true
     ($$ : sint 32) <- Daedalus.SInt32 _382
     pure $$
 
Daedalus.BESInt64 : Grammar (sint 64) =
  do (_384 : bool) <- pure true
     ($$ : sint 64) <- Daedalus.SInt64 _384
     pure $$
 
Daedalus.BEHalfFloat : Grammar float =
  do (_386 : bool) <- pure true
     ($$ : float) <- Daedalus.HalfFloat _386
     pure $$
 
Daedalus.BEFloat : Grammar float =
  do (_388 : bool) <- pure true
     ($$ : float) <- Daedalus.Float _388
     pure $$
 
Daedalus.BEDouble : Grammar double =
  do (_390 : bool) <- pure true
     ($$ : double) <- Daedalus.Double _390
     pure $$
 
Daedalus.LEUInt16 : Grammar (uint 16) =
  do (_392 : bool) <- pure false
     ($$ : uint 16) <- Daedalus.UInt16 _392
     pure $$
 
Daedalus.LEUInt32 : Grammar (uint 32) =
  do (_394 : bool) <- pure false
     ($$ : uint 32) <- Daedalus.UInt32 _394
     pure $$
 
Daedalus.LEUInt64 : Grammar (uint 64) =
  do (_396 : bool) <- pure false
     ($$ : uint 64) <- Daedalus.UInt64 _396
     pure $$
 
Daedalus.LESInt16 : Grammar (sint 16) =
  do (_398 : bool) <- pure false
     ($$ : sint 16) <- Daedalus.SInt16 _398
     pure $$
 
Daedalus.LESInt32 : Grammar (sint 32) =
  do (_400 : bool) <- pure false
     ($$ : sint 32) <- Daedalus.SInt32 _400
     pure $$
 
Daedalus.LESInt64 : Grammar (sint 64) =
  do (_402 : bool) <- pure false
     ($$ : sint 64) <- Daedalus.SInt64 _402
     pure $$
 
Daedalus.LEHalfFloat : Grammar float =
  do (_404 : bool) <- pure false
     ($$ : float) <- Daedalus.HalfFloat _404
     pure $$
 
Daedalus.LEFloat : Grammar float =
  do (_406 : bool) <- pure false
     ($$ : float) <- Daedalus.Float _406
     pure $$
 
Daedalus.LEDouble : Grammar double =
  do (_408 : bool) <- pure false
     ($$ : double) <- Daedalus.Double _408
     pure $$
 
Daedalus.Guard (b : bool) : Grammar {} =
  case b is
    { true -> pure {}
    }
 
Daedalus.Only ?a0 (P : Grammar ?a0) : Grammar ?a0 =
  do ($$ : ?a0) <- P
     END
     pure $$
 
Daedalus.min ?a0 (x : ?a0) (y : ?a0) : ?a0 =
  if (x < y) then x else y
 
Daedalus.max ?a0 (x : ?a0) (y : ?a0) : ?a0 =
  if (x < y) then y else x
 
Daedalus.SetStreamAt (n : uint 64) (s : Stream) : Grammar {} =
  do (_410 : Stream) <- StreamOff n s
     SetStream _410
 
Daedalus.Skip (n : uint 64) : Grammar {} =
  do (_411 : Stream) <- CurrentStream
     Daedalus.SetStreamAt n _411
 
Daedalus._SetStreamAt (n : uint 64) (s : Stream) : Grammar {} =
  do (_410 : Stream) <- StreamOff n s
     SetStream _410
 
Daedalus.Chunk ?a0 (n : uint 64) (P : Grammar ?a0) : Grammar ?a0 =
  do (s : Stream) <- CurrentStream
     do (_412 : Stream) <- StreamLen n s
        SetStream _412
     ($$ : ?a0) <- P
     Daedalus._SetStreamAt n s
     pure $$
 
Daedalus.Bytes (n : uint 64) : Grammar Stream =
  Daedalus.Chunk Stream n CurrentStream
 
Daedalus.LookAhead ?a0 (P : Grammar ?a0) : Grammar ?a0 =
  do (s : Stream) <- CurrentStream
     ($$ : ?a0) <- P
     SetStream s
     pure $$
 
Daedalus._UInt16 : Grammar {} =
  do @GetByte
     @GetByte
 
Daedalus._UInt32 : Grammar {} =
  do Daedalus._UInt16
     Daedalus._UInt16
 
Daedalus._UInt64 : Grammar {} =
  do Daedalus._UInt32
     Daedalus._UInt32
 
Daedalus._SInt16 : Grammar {} =
  Daedalus._UInt16
 
Daedalus._SInt32 : Grammar {} =
  Daedalus._UInt32
 
Daedalus._SInt64 : Grammar {} =
  Daedalus._UInt64
 
Daedalus._HalfFloat : Grammar {} =
  Daedalus._UInt16
 
Daedalus._Float : Grammar {} =
  Daedalus._UInt32
 
Daedalus._Double : Grammar {} =
  Daedalus._UInt64
 
Daedalus._BEUInt16 : Grammar {} =
  Daedalus._UInt16
 
Daedalus._BEUInt32 : Grammar {} =
  Daedalus._UInt32
 
Daedalus._BEUInt64 : Grammar {} =
  Daedalus._UInt64
 
Daedalus._BESInt16 : Grammar {} =
  Daedalus._SInt16
 
Daedalus._BESInt32 : Grammar {} =
  Daedalus._SInt32
 
Daedalus._BESInt64 : Grammar {} =
  Daedalus._SInt64
 
Daedalus._BEHalfFloat : Grammar {} =
  Daedalus._HalfFloat
 
Daedalus._BEFloat : Grammar {} =
  Daedalus._Float
 
Daedalus._BEDouble : Grammar {} =
  Daedalus._Double
 
Daedalus._LEUInt16 : Grammar {} =
  Daedalus._UInt16
 
Daedalus._LEUInt32 : Grammar {} =
  Daedalus._UInt32
 
Daedalus._LEUInt64 : Grammar {} =
  Daedalus._UInt64
 
Daedalus._LESInt16 : Grammar {} =
  Daedalus._SInt16
 
Daedalus._LESInt32 : Grammar {} =
  Daedalus._SInt32
 
Daedalus._LESInt64 : Grammar {} =
  Daedalus._SInt64
 
Daedalus._LEHalfFloat : Grammar {} =
  Daedalus._HalfFloat
 
Daedalus._LEFloat : Grammar {} =
  Daedalus._Float
 
Daedalus._LEDouble : Grammar {} =
  Daedalus._Double
 
Daedalus._Guard (b : bool) : Grammar {} =
  case b is
    { true -> pure {}
    }
 
Daedalus._Only ?a0 (_P : Grammar {}) : Grammar {} =
  do _P
     END
 
Daedalus._Skip (n : uint 64) : Grammar {} =
  do (_411 : Stream) <- CurrentStream
     Daedalus._SetStreamAt n _411
 
Daedalus._Chunk ?a0 (n : uint 64) (_P : Grammar {}) : Grammar {} =
  do (s : Stream) <- CurrentStream
     do (_412 : Stream) <- StreamLen n s
        SetStream _412
     _P
     Daedalus._SetStreamAt n s
 
Daedalus._Bytes (n : uint 64) : Grammar {} =
  Daedalus._Chunk Stream n (pure {})
 
Daedalus._LookAhead ?a0 (_P : Grammar {}) : Grammar {} =
  do (s : Stream) <- CurrentStream
     _P
     SetStream s
module ICC
 
--- Imports:
import Daedalus
 
--- Type defs:
type ICC.VersionField = { major: uint 8
                        ; minor: uint 4
                        ; bugfix: uint 4
                        }
 
type ICC.ProfileClass = Choose { multiplex_vis: {}
                               ; multiplex_link: {}
                               ; multiplex_id: {}
                               ; color_encoding_space: {}
                               ; named_color_profile: {}
                               ; abstract_profile: {}
                               ; color_space_profile: {}
                               ; device_link_profile: {}
                               ; output_device_profile: {}
                               ; display_device_profile: {}
                               ; input_device_profile: {}
                               }
 
type ICC.DataColorSpace = Choose { n_channel: uint 16
                                 ; none: {}
                                 ; fifteen_colour: {}
                                 ; fourteen_colour: {}
                                 ; thirteen_colour: {}
                                 ; twelve_colour: {}
                                 ; eleven_colour: {}
                                 ; ten_colour: {}
                                 ; nine_colour: {}
                                 ; eight_colour: {}
                                 ; seven_colour: {}
                                 ; six_colour: {}
                                 ; five_colour: {}
                                 ; four_colour: {}
                                 ; three_colour: {}
                                 ; two_colour: {}
                                 ; cmy: {}
                                 ; cmyk: {}
                                 ; hls: {}
                                 ; hsv: {}
                                 ; gray: {}
                                 ; rgb: {}
                                 ; lms: {}
                                 ; cieyxy: {}
                                 ; ycbcr: {}
                                 ; cieluv: {}
                                 ; cielab_or_pcslab: {}
                                 ; nciexyz_or_pcsxyz: {}
                                 }
 
type ICC.PrimaryPlatform = Choose { none: {}
                                  ; sun_microsystems: {}
                                  ; silicon_graphics_inc: {}
                                  ; microsoft_corporation: {}
                                  ; apple_computer_inc: {}
                                  }
 
type ICC.RenderingIntent = Choose { icc_absolute_colorimetric: {}
                                  ; saturation: {}
                                  ; media_relative_colorimetric: {}
                                  ; perceptual: {}
                                  }
 
type ICC.XYZNumber = { x: sint 32
                     ; y: sint 32
                     ; z: sint 32
                     }
 
type ICC.DateTimeNumber = { year: uint 16
                          ; month: uint 16
                          ; day: uint 16
                          ; hour: uint 16
                          ; minute: uint 16
                          ; second: uint 16
                          }
 
type ICC.ProfileHeader = { size: uint 32
                         ; preferred_cmm_type: [uint 8]
                         ; version: ICC.VersionField
                         ; devce_class: ICC.ProfileClass
                         ; color_space: ICC.DataColorSpace
                         ; pcs: ICC.DataColorSpace
                         ; creation_date_time: ICC.DateTimeNumber
                         ; primary_platform: ICC.PrimaryPlatform
                         ; profile_flags: uint 32
                         ; device_manufacturer: [uint 8]
                         ; device_model: [uint 8]
                         ; device_attributes: uint 64
                         ; rendering_intent: ICC.RenderingIntent
                         ; illuminant: ICC.XYZNumber
                         ; creator: [uint 8]
                         ; identifier: [uint 8]
                         ; reserved_data: [uint 8]
                         }
 
type ICC.InvalidTag = { sig: [uint 8]
                      ; data: [uint 8]
                      }
 
type ICC.LutAToBType = { number_of_input_channels: uint 8
                       ; number_of_output_channels: uint 8
                       ; offset_first_B_curve: uint 32
                       ; offset_to_matrix: uint 32
                       ; offset_to_first_M_curve: uint 32
                       ; offset_to_CLUT: uint 32
                       ; offset_to_first_A_curve: uint 32
                       ; data: Stream
                       }
 
type ICC.MPElementHead = { offset: Stream
                         ; tag: uint 32
                         ; inputs: uint 64
                         ; outputs: uint 64
                         }
 
type ICC.OpParams = { s: uint 64
                    ; t: uint 64
                    }
 
rec
  type ICC.FunOpWithPosition = { offset: Stream
                               ; op: ICC.FunOp
                               }
   
  type ICC.Sel = { case1: [ICC.FunOpWithPosition]
                 ; cases: [[ICC.FunOpWithPosition]]
                 ; dflt: Maybe [ICC.FunOpWithPosition]
                 }
   
  type ICC.IfThenElse = { thenOps: [ICC.FunOpWithPosition]
                        ; elseOps: [ICC.FunOpWithPosition]
                        }
   
  type ICC.FunOp = Choose { data: float
                          ; opIn: ICC.OpParams
                          ; opOut: ICC.OpParams
                          ; opTGet: ICC.OpParams
                          ; opTPut: ICC.OpParams
                          ; opTSave: ICC.OpParams
                          ; opEnv: uint 32
                          ; curv: uint 64
                          ; mtx: uint 64
                          ; clut: uint 64
                          ; calc: uint 64
                          ; tint: uint 64
                          ; elem: uint 64
                          ; copy: ICC.OpParams
                          ; rotl: ICC.OpParams
                          ; rotr: ICC.OpParams
                          ; posd: ICC.OpParams
                          ; flip: uint 64
                          ; pop: uint 64
                          ; solv: ICC.OpParams
                          ; tran: ICC.OpParams
                          ; sum: uint 64
                          ; prod: uint 64
                          ; min: uint 64
                          ; max: uint 64
                          ; and: uint 64
                          ; or: uint 64
                          ; opPi: {}
                          ; opPosInf: {}
                          ; opNegInf: {}
                          ; opNaN: {}
                          ; opAdd: uint 64
                          ; opSub: uint 64
                          ; opMul: uint 64
                          ; opDiv: uint 64
                          ; opMod: uint 64
                          ; opPow: uint 64
                          ; opGamma: uint 64
                          ; opSAdd: uint 64
                          ; opSSub: uint 64
                          ; opSMul: uint 64
                          ; opSDiv: uint 64
                          ; opSq: uint 64
                          ; opSqrt: uint 64
                          ; opCb: uint 64
                          ; opCbrt: uint 64
                          ; opAbs: uint 64
                          ; opNeg: uint 64
                          ; opRond: uint 64
                          ; opFlor: uint 64
                          ; opCeil: uint 64
                          ; opTrnc: uint 64
                          ; opSign: uint 64
                          ; opExp: uint 64
                          ; opLog: uint 64
                          ; opLn: uint 64
                          ; opSin: uint 64
                          ; opCos: uint 64
                          ; opTan: uint 64
                          ; opASin: uint 64
                          ; opACos: uint 64
                          ; opATan: uint 64
                          ; opATn2: uint 64
                          ; opCTop: uint 64
                          ; opPToc: uint 64
                          ; opRNum: uint 64
                          ; opLT: uint 64
                          ; opLE: uint 64
                          ; opEQ: uint 64
                          ; opNear: uint 64
                          ; opGE: uint 64
                          ; opGT: uint 64
                          ; opVMin: uint 64
                          ; opVMax: uint 64
                          ; opVAnd: uint 64
                          ; opVOr: uint 64
                          ; opTLab: uint 64
                          ; opTXYZ: uint 64
                          ; opIfThen: [ICC.FunOpWithPosition]
                          ; opIfThenElse: ICC.IfThenElse
                          ; opSel: ICC.Sel
                          }
 
type ICC.SingleSampledCurve = { n: uint 32
                              ; f: uint 32
                              ; l: uint 32
                              ; e: uint 16
                              ; ty: uint 16
                              }
 
type ICC.FormualCurveSegment = { fun: uint 16
                               ; args: [float]
                               }
 
type ICC.CurveSegment = Choose { samf: [float]
                               ; parf: ICC.FormualCurveSegment
                               }
 
type ICC.SegmentedCurve = { breakPoints: [float]
                          ; segments: [ICC.CurveSegment]
                          }
 
type ICC.Curve = Choose { unimplemented: [uint 8]
                        ; curf: ICC.SegmentedCurve
                        ; sngf: ICC.SingleSampledCurve
                        }
 
type ICC.Matrix = { matrix: [[float]]
                  ; vector: [float]
                  }
 
rec
  type ICC.MPElement = { head: ICC.MPElementHead
                       ; body: ICC.MPElementBody
                       }
   
  type ICC.CalcElement = { inputs: uint 64
                         ; outputs: uint 64
                         ; main: [ICC.FunOpWithPosition]
                         ; subElements: [ICC.MPElement]
                         }
   
  type ICC.MPElementBody = Choose { calc: ICC.CalcElement
                                  ; cvst: [ICC.Curve]
                                  ; matf: ICC.Matrix
                                  ; mpet: [ICC.MPElement]
                                  ; unimplemented: [uint 8]
                                  }
 
type ICC.LutAB_or_multi = Choose { lutAB: ICC.LutAToBType
                                 ; mpe: ICC.MPElement
                                 }
 
type ICC.LutBA_or_multi = Choose { lutBA: ICC.LutAToBType
                                 ; mpe: ICC.MPElement
                                 }
 
type ICC.ParametricCurveType = { function: uint 16
                               ; parameters: [uint 32]
                               }
 
type ICC.CurveOrPCurve = Choose { curve: [uint 16]
                                ; pcurve: ICC.ParametricCurveType
                                }
 
type ICC.UnicodeRecord = { language: [uint 8]
                         ; country: [uint 8]
                         ; data: [uint 8]
                         }
 
type ICC.TextDescriptionType = { ascii_data: [uint 8]
                               ; unicode_code: [uint 8]
                               ; unicode_data: [uint 8]
                               ; script_code: [uint 8]
                               ; script_data: [uint 8]
                               }
 
type ICC.LaxTextType = Choose { desc: ICC.TextDescriptionType
                              ; text: [uint 7]
                              ; uni: [ICC.UnicodeRecord]
                              }
 
type ICC.XYNumber = { x: uint 32
                    ; y: uint 32
                    }
 
type ICC.ChromaticityType = { phosphor_or_colorant: uint 16
                            ; cie_coords: [ICC.XYNumber]
                            }
 
type ICC.SpectralViewingConditionsType = { colometric_observer: uint 32
                                         ; xxx: [uint 8]
                                         }
 
type ICC.Tag = Choose { invalid_tag: ICC.InvalidTag
                      ; unimplemented: [uint 8]
                      ; chad: [uint 32]
                      ; chrm: ICC.ChromaticityType
                      ; dmnd: ICC.LaxTextType
                      ; dmdd: ICC.LaxTextType
                      ; bTRC: ICC.CurveOrPCurve
                      ; gTRC: ICC.CurveOrPCurve
                      ; rTRC: ICC.CurveOrPCurve
                      ; bXYZ: [ICC.XYZNumber]
                      ; gXYZ: [ICC.XYZNumber]
                      ; rXYZ: [ICC.XYZNumber]
                      ; svcn: ICC.SpectralViewingConditionsType
                      ; s2cp: ICC.MPElement
                      ; c2sp: ICC.MPElement
                      ; cprt: ICC.LaxTextType
                      ; wtpt: [ICC.XYZNumber]
                      ; B2D3: ICC.MPElement
                      ; B2D2: ICC.MPElement
                      ; B2D1: ICC.MPElement
                      ; B2D0: ICC.MPElement
                      ; B2A3: ICC.LutBA_or_multi
                      ; B2A2: ICC.LutBA_or_multi
                      ; B2A1: ICC.LutBA_or_multi
                      ; B2A0: ICC.LutBA_or_multi
                      ; A2M0: ICC.MPElement
                      ; A2B3: ICC.LutAB_or_multi
                      ; A2B2: ICC.LutAB_or_multi
                      ; A2B1: ICC.LutAB_or_multi
                      ; A2B0: ICC.LutAB_or_multi
                      ; desc: ICC.LaxTextType
                      }
 
type ICC.ICC = { header: ICC.ProfileHeader
               ; tags: [ICC.Tag]
               }
 
type ICC.PositionNumber = { offset: uint 64
                          ; size: uint 64
                          }
 
type ICC.Response16Number = { device: uint 16
                            ; measurement: uint 32
                            }
 
type ICC.Colorant = { name: [uint 7]
                    ; pcs: [uint 16]
                    }
 
type ICC.ResponseCurve = { measurement_unit: uint 32
                         ; pcxyzs: [ICC.XYNumber]
                         ; response_arrays: [[ICC.Response16Number]]
                         }
 
type ICC.Lut8Type = { number_of_input_channels: uint 8
                    ; number_of_output_channels: uint 8
                    ; number_of_clut_grid_points: uint 8
                    ; encoded_e_parameters: [sint 32]
                    ; input_tables: Stream
                    ; clut_values: Stream
                    ; output_tables: Stream
                    }
 
type ICC.Lut16Type = { number_of_input_channels: uint 8
                     ; number_of_output_channels: uint 8
                     ; number_of_clut_grid_points: uint 8
                     ; encoded_e_parameters: [sint 32]
                     ; number_of_input_table_entries: uint 32
                     ; number_of_output_table_entries: uint 32
                     ; input_tables: Stream
                     ; clut_values: Stream
                     ; output_tables: Stream
                     }
 
type ICC.LutBToAType = { number_of_input_channels: uint 8
                       ; number_of_output_channels: uint 8
                       ; offset_first_B_curve: uint 32
                       ; offset_to_matrix: uint 32
                       ; offset_to_first_M_curve: uint 32
                       ; offset_to_CLUT: uint 32
                       ; offset_to_first_A_curve: uint 32
                       ; data: Stream
                       }
 
type ICC.MeasurementType = { standard_observer: uint 32
                           ; nCIEXYZ: ICC.XYZNumber
                           ; geometry: uint 32
                           ; flare: uint 32
                           ; illuminant: uint 32
                           }
 
type ICC.ColorName = { name_root: [uint 7]
                     ; pcs_coords: [uint 16]
                     ; device_coords: [uint 16]
                     }
 
type ICC.NamedColor2Type = { vendor_specific: uint 32
                           ; prefix: [uint 7]
                           ; suffix: [uint 7]
                           ; names: [ICC.ColorName]
                           }
 
type ICC.ViewConditionsType = { illuminantXYZ: ICC.XYZNumber
                              ; surroundXYZ: ICC.XYZNumber
                              ; illuminant: uint 32
                              }
 
--- Rules:
 
ICC.VersionField : Grammar ICC.VersionField =
  do (major : uint 8) <- GetByte
     (min_bf : uint 8) <- GetByte
     (minor : uint 4) <- pure (min_bf >> 4 as uint 4)
     (bugfix : uint 4) <- pure (min_bf as uint 4)
     @MatchBytes [0x00,
                  0x00]
     pure {major = major,
           minor = minor,
           bugfix = bugfix}
 
ICC.ProfileClass : Grammar ICC.ProfileClass =
  do (_413 : uint 32) <- Daedalus.BEUInt32
     case _413 is
       { 0s"scnr" -> {- case branch  0s"scnr" -} pure {input_device_profile: {}}
       ; 0s"mntr" -> {- case branch  0s"mntr" -} pure {display_device_profile: {}}
       ; 0s"prtr" -> {- case branch  0s"prtr" -} pure {output_device_profile: {}}
       ; 0s"link" -> {- case branch  0s"link" -} pure {device_link_profile: {}}
       ; 0s"spac" -> {- case branch  0s"spac" -} pure {color_space_profile: {}}
       ; 0s"abst" -> {- case branch  0s"abst" -} pure {abstract_profile: {}}
       ; 0s"nmcl" -> {- case branch  0s"nmcl" -} pure {named_color_profile: {}}
       ; 0s"cenc" -> {- case branch  0s"cenc" -} pure {color_encoding_space: {}}
       ; 0s"mid " -> {- case branch  0s"mid " -} pure {multiplex_id: {}}
       ; 0s"mlnk" -> {- case branch  0s"mlnk" -} pure {multiplex_link: {}}
       ; 0s"mvis" -> {- case branch  0s"mvis" -} pure {multiplex_vis: {}}
       }
 
ICC.DataColorSpace : Grammar ICC.DataColorSpace =
  do (tag : uint 32) <- Daedalus.BEUInt32
     ($$ : ICC.DataColorSpace) <- case tag is
                                    { 0s"XYZ " -> {- case branch  0s"XYZ " -} pure {nciexyz_or_pcsxyz: {}}
                                    ; 0s"Lab " -> {- case branch  0s"Lab " -} pure {cielab_or_pcslab: {}}
                                    ; 0s"Luv " -> {- case branch  0s"Luv " -} pure {cieluv: {}}
                                    ; 0s"Ycbr" -> {- case branch  0s"Ycbr" -} pure {ycbcr: {}}
                                    ; 0s"Yxy " -> {- case branch  0s"Yxy " -} pure {cieyxy: {}}
                                    ; 0s"LMS " -> {- case branch  0s"LMS " -} pure {lms: {}}
                                    ; 0s"RGB " -> {- case branch  0s"RGB " -} pure {rgb: {}}
                                    ; 0s"GRAY" -> {- case branch  0s"GRAY" -} pure {gray: {}}
                                    ; 0s"HSV " -> {- case branch  0s"HSV " -} pure {hsv: {}}
                                    ; 0s"HLS " -> {- case branch  0s"HLS " -} pure {hls: {}}
                                    ; 0s"CMYK" -> {- case branch  0s"CMYK" -} pure {cmyk: {}}
                                    ; 0s"CMY " -> {- case branch  0s"CMY " -} pure {cmy: {}}
                                    ; 0s"2CLR" -> {- case branch  0s"2CLR" -} pure {two_colour: {}}
                                    ; 0s"3CLR" -> {- case branch  0s"3CLR" -} pure {three_colour: {}}
                                    ; 0s"4CLR" -> {- case branch  0s"4CLR" -} pure {four_colour: {}}
                                    ; 0s"5CLR" -> {- case branch  0s"5CLR" -} pure {five_colour: {}}
                                    ; 0s"6CLR" -> {- case branch  0s"6CLR" -} pure {six_colour: {}}
                                    ; 0s"7CLR" -> {- case branch  0s"7CLR" -} pure {seven_colour: {}}
                                    ; 0s"8CLR" -> {- case branch  0s"8CLR" -} pure {eight_colour: {}}
                                    ; 0s"9CLR" -> {- case branch  0s"9CLR" -} pure {nine_colour: {}}
                                    ; 0s"ACLR" -> {- case branch  0s"ACLR" -} pure {ten_colour: {}}
                                    ; 0s"BCLR" -> {- case branch  0s"BCLR" -} pure {eleven_colour: {}}
                                    ; 0s"CCLR" -> {- case branch  0s"CCLR" -} pure {twelve_colour: {}}
                                    ; 0s"DCLR" -> {- case branch  0s"DCLR" -} pure {thirteen_colour: {}}
                                    ; 0s"ECLR" -> {- case branch  0s"ECLR" -} pure {fourteen_colour: {}}
                                    ; 0s"FCLR" -> {- case branch  0s"FCLR" -} pure {fifteen_colour: {}}
                                    ; 0 -> {- case branch  0 -} pure {none: {}}
                                    ; _ -> do Daedalus._Guard ((tag >> 16) == 0s"ne")
                                              ($$ : ICC.DataColorSpace) <- pure {n_channel: (tag as uint 16)}
                                              pure $$
                                    }
     pure $$
 
ICC.PrimaryPlatform : Grammar ICC.PrimaryPlatform =
  do (_416 : uint 32) <- Daedalus.BEUInt32
     case _416 is
       { 0s"APPL" -> {- case branch  0s"APPL" -} pure {apple_computer_inc: {}}
       ; 0s"MSFT" -> {- case branch  0s"MSFT" -} pure {microsoft_corporation: {}}
       ; 0s"SGI " -> {- case branch  0s"SGI " -} pure {silicon_graphics_inc: {}}
       ; 0s"SUNW" -> {- case branch  0s"SUNW" -} pure {sun_microsystems: {}}
       ; 0 -> {- case branch  0 -} pure {none: {}}
       }
 
ICC.RenderingIntent : Grammar ICC.RenderingIntent =
  do (_417 : uint 32) <- Daedalus.BEUInt32
     case _417 is
       { 0 -> {- case branch  0 -} pure {perceptual: {}}
       ; 1 -> {- case branch  1 -} pure {media_relative_colorimetric: {}}
       ; 2 -> {- case branch  2 -} pure {saturation: {}}
       ; 3 -> {- case branch  3 -} pure {icc_absolute_colorimetric: {}}
       }
 
ICC.XYZNumber : Grammar ICC.XYZNumber =
  do (x : sint 32) <- Daedalus.BESInt32
     (y : sint 32) <- Daedalus.BESInt32
     (z : sint 32) <- Daedalus.BESInt32
     pure {x = x,
           y = y,
           z = z}
 
ICC.DateTimeNumber : Grammar ICC.DateTimeNumber =
  do (year : uint 16) <- Daedalus.BEUInt16
     (month : uint 16) <- Daedalus.BEUInt16
     (day : uint 16) <- Daedalus.BEUInt16
     (hour : uint 16) <- Daedalus.BEUInt16
     (minute : uint 16) <- Daedalus.BEUInt16
     (second : uint 16) <- Daedalus.BEUInt16
     pure {year = year,
           month = month,
           day = day,
           hour = hour,
           minute = minute,
           second = second}
 
ICC.ProfileHeader : Grammar ICC.ProfileHeader =
  do (size : uint 32) <- Daedalus.BEUInt32
     (preferred_cmm_type : [uint 8]) <- Many[4] GetByte
     (version : ICC.VersionField) <- ICC.VersionField
     (devce_class : ICC.ProfileClass) <- ICC.ProfileClass
     (color_space : ICC.DataColorSpace) <- ICC.DataColorSpace
     (pcs : ICC.DataColorSpace) <- ICC.DataColorSpace
     (creation_date_time : ICC.DateTimeNumber) <- ICC.DateTimeNumber
     @MatchBytes "acsp"
     (primary_platform : ICC.PrimaryPlatform) <- ICC.PrimaryPlatform
     (profile_flags : uint 32) <- Daedalus.BEUInt32
     (device_manufacturer : [uint 8]) <- Many[4] GetByte
     (device_model : [uint 8]) <- Many[4] GetByte
     (device_attributes : uint 64) <- Daedalus.BEUInt64
     (rendering_intent : ICC.RenderingIntent) <- ICC.RenderingIntent
     (illuminant : ICC.XYZNumber) <- ICC.XYZNumber
     (creator : [uint 8]) <- Many[4] GetByte
     (identifier : [uint 8]) <- Many[16] GetByte
     (reserved_data : [uint 8]) <- Many[28] GetByte
     pure {size = size,
           preferred_cmm_type = preferred_cmm_type,
           version = version,
           devce_class = devce_class,
           color_space = color_space,
           pcs = pcs,
           creation_date_time = creation_date_time,
           primary_platform = primary_platform,
           profile_flags = profile_flags,
           device_manufacturer = device_manufacturer,
           device_model = device_model,
           device_attributes = device_attributes,
           rendering_intent = rendering_intent,
           illuminant = illuminant,
           creator = creator,
           identifier = identifier,
           reserved_data = reserved_data}
 
ICC.explode32 (sig : uint 32) : [uint 8] =
  [sig >> 24 as uint 8,
   sig >> 16 as uint 8,
   sig >> 8 as uint 8,
   sig as uint 8]
 
ICC.InvalidTag (sig : uint 32) : Grammar ICC.InvalidTag =
  do (sig : [uint 8]) <- pure (ICC.explode32 sig)
     (data : [uint 8]) <- Many[] GetByte
     pure {sig = sig,
           data = data}
 
ICC.MPElementHead : Grammar ICC.MPElementHead =
  do (offset : Stream) <- CurrentStream
     (tag : uint 32) <- Daedalus.BEUInt32
     @MatchBytes [0,
                  0,
                  0,
                  0]
     (inputs : uint 64) <- do (_418 : uint 16) <- Daedalus.BEUInt16
                              pure (_418 as uint 64)
     (outputs : uint 64) <- do (_419 : uint 16) <- Daedalus.BEUInt16
                               pure (_419 as uint 64)
     pure {offset = offset,
           tag = tag,
           inputs = inputs,
           outputs = outputs}
 
ICC.SelCase : Grammar (uint 64) =
  do @MatchBytes "case"
     ($$ : uint 64) <- do (_422 : uint 32) <- Daedalus.BEUInt32
                          pure (_422 as uint 64)
     pure $$
 
ICC._Exactly ?a0 (x : ?a0) (P : Grammar ?a0) : Grammar {} =
  Choose biased
    { do (_424 : bool) <- do (_423 : ?a0) <- P
                             pure (_423 == x)
         Daedalus._Guard _424
    | Fail "Unexpected field value"
    }
 
ICC.NoParams : Grammar {} =
  ICC._Exactly (uint 32) 0 Daedalus.BEUInt32
 
ICC.OpParam : Grammar (uint 64) =
  do ($$ : uint 64) <- do (_426 : uint 16) <- Daedalus.BEUInt16
                          pure (_426 as uint 64)
     ICC._Exactly (uint 16) 0 Daedalus.BEUInt16
     pure $$
 
ICC.OpParams : Grammar ICC.OpParams =
  do (s : uint 64) <- do (_427 : uint 16) <- Daedalus.BEUInt16
                         pure (_427 as uint 64)
     (t : uint 64) <- do (_428 : uint 16) <- Daedalus.BEUInt16
                         pure (_428 as uint 64)
     pure {s = s,
           t = t}
 
ICC._NoParams : Grammar {} =
  ICC._Exactly (uint 32) 0 Daedalus.BEUInt32
 
rec value
  ICC.ManyFunOps (n : uint 64) : Grammar [ICC.FunOpWithPosition] =
    Daedalus.Chunk [ICC.FunOpWithPosition] (8 * n) (Daedalus.Only [ICC.FunOpWithPosition] (Many[] ICC.FunOpWithPosition))
   
  ICC.Sel (alt : uint 64) (alts : [uint 64]) (mbDflt : Maybe (uint 64)) : Grammar ICC.Sel =
    do (case1 : [ICC.FunOpWithPosition]) <- ICC.ManyFunOps alt
       (cases : [[ICC.FunOpWithPosition]]) <- map ((n : uint 64) in alts)
                                                (ICC.ManyFunOps n)
       (dflt : Maybe [ICC.FunOpWithPosition]) <- case mbDflt is
                                                   { nothing -> {- case branch  nothing -} pure nothing
                                                   ; just n -> {- case branch  just n -} do (_429 : [ICC.FunOpWithPosition]) <- ICC.ManyFunOps n
                                                                                            pure (just _429)
                                                   }
       pure {case1 = case1,
             cases = cases,
             dflt = dflt}
   
  ICC.IfThenElse (thenOps : uint 64) (elseOps : uint 64) : Grammar ICC.IfThenElse =
    do (thenOps : [ICC.FunOpWithPosition]) <- ICC.ManyFunOps thenOps
       (elseOps : [ICC.FunOpWithPosition]) <- ICC.ManyFunOps elseOps
       pure {thenOps = thenOps,
             elseOps = elseOps}
   
  ICC.FunOp : Grammar ICC.FunOp =
    do (tag : uint 32) <- Daedalus.BEUInt32
       ($$ : ICC.FunOp) <- case tag is
                             { 0s"data" -> {- case branch  0s"data" -} do (_431 : float) <- Daedalus.BEFloat
                                                                          pure {data: _431}
                             ; 0s"in  " -> {- case branch  0s"in  " -} do (_432 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {opIn: _432}
                             ; 0s"out " -> {- case branch  0s"out " -} do (_433 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {opOut: _433}
                             ; 0s"tget" -> {- case branch  0s"tget" -} do (_434 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {opTGet: _434}
                             ; 0s"tput" -> {- case branch  0s"tput" -} do (_435 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {opTPut: _435}
                             ; 0s"tsav" -> {- case branch  0s"tsav" -} do (_436 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {opTSave: _436}
                             ; 0s"env " -> {- case branch  0s"env " -} do (_437 : uint 32) <- Daedalus.BEUInt32
                                                                          pure {opEnv: _437}
                             ; 0s"curv" -> {- case branch  0s"curv" -} do (_439 : uint 64) <- do (_438 : uint 64) <- ICC.OpParam
                                                                                                 pure (_438 as uint 64)
                                                                          pure {curv: _439}
                             ; 0s"mtx " -> {- case branch  0s"mtx " -} do (_441 : uint 64) <- do (_440 : uint 64) <- ICC.OpParam
                                                                                                 pure (_440 as uint 64)
                                                                          pure {mtx: _441}
                             ; 0s"clut" -> {- case branch  0s"clut" -} do (_443 : uint 64) <- do (_442 : uint 64) <- ICC.OpParam
                                                                                                 pure (_442 as uint 64)
                                                                          pure {clut: _443}
                             ; 0s"calc" -> {- case branch  0s"calc" -} do (_445 : uint 64) <- do (_444 : uint 64) <- ICC.OpParam
                                                                                                 pure (_444 as uint 64)
                                                                          pure {calc: _445}
                             ; 0s"tint" -> {- case branch  0s"tint" -} do (_447 : uint 64) <- do (_446 : uint 64) <- ICC.OpParam
                                                                                                 pure (_446 as uint 64)
                                                                          pure {tint: _447}
                             ; 0s"elem" -> {- case branch  0s"elem" -} do (_449 : uint 64) <- do (_448 : uint 64) <- ICC.OpParam
                                                                                                 pure (_448 as uint 64)
                                                                          pure {elem: _449}
                             ; 0s"copy" -> {- case branch  0s"copy" -} do (_450 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {copy: _450}
                             ; 0s"rotl" -> {- case branch  0s"rotl" -} do (_451 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {rotl: _451}
                             ; 0s"rotr" -> {- case branch  0s"rotr" -} do (_452 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {rotr: _452}
                             ; 0s"posd" -> {- case branch  0s"posd" -} do (_453 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {posd: _453}
                             ; 0s"flip" -> {- case branch  0s"flip" -} do (_454 : uint 64) <- ICC.OpParam
                                                                          pure {flip: _454}
                             ; 0s"pop " -> {- case branch  0s"pop " -} do (_455 : uint 64) <- ICC.OpParam
                                                                          pure {pop: _455}
                             ; 0s"solv" -> {- case branch  0s"solv" -} do (_456 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {solv: _456}
                             ; 0s"tran" -> {- case branch  0s"tran" -} do (_457 : ICC.OpParams) <- ICC.OpParams
                                                                          pure {tran: _457}
                             ; 0s"sum " -> {- case branch  0s"sum " -} do (_458 : uint 64) <- ICC.OpParam
                                                                          pure {sum: _458}
                             ; 0s"prod" -> {- case branch  0s"prod" -} do (_459 : uint 64) <- ICC.OpParam
                                                                          pure {prod: _459}
                             ; 0s"min " -> {- case branch  0s"min " -} do (_460 : uint 64) <- ICC.OpParam
                                                                          pure {min: _460}
                             ; 0s"max " -> {- case branch  0s"max " -} do (_461 : uint 64) <- ICC.OpParam
                                                                          pure {max: _461}
                             ; 0s"and " -> {- case branch  0s"and " -} do (_462 : uint 64) <- ICC.OpParam
                                                                          pure {and: _462}
                             ; 0s"or  " -> {- case branch  0s"or  " -} do (_463 : uint 64) <- ICC.OpParam
                                                                          pure {or: _463}
                             ; 0s"pi  " -> {- case branch  0s"pi  " -} do (_464 : {}) <- ICC.NoParams
                                                                          pure {opPi: _464}
                             ; 0s"+INF" -> {- case branch  0s"+INF" -} do (_465 : {}) <- ICC.NoParams
                                                                          pure {opPosInf: _465}
                             ; 0s"-INF" -> {- case branch  0s"-INF" -} do (_466 : {}) <- ICC.NoParams
                                                                          pure {opNegInf: _466}
                             ; 0s"NaN " -> {- case branch  0s"NaN " -} do (_467 : {}) <- ICC.NoParams
                                                                          pure {opNaN: _467}
                             ; 0s"add " -> {- case branch  0s"add " -} do (_468 : uint 64) <- ICC.OpParam
                                                                          pure {opAdd: _468}
                             ; 0s"sub " -> {- case branch  0s"sub " -} do (_469 : uint 64) <- ICC.OpParam
                                                                          pure {opSub: _469}
                             ; 0s"mul " -> {- case branch  0s"mul " -} do (_470 : uint 64) <- ICC.OpParam
                                                                          pure {opMul: _470}
                             ; 0s"div " -> {- case branch  0s"div " -} do (_471 : uint 64) <- ICC.OpParam
                                                                          pure {opDiv: _471}
                             ; 0s"mod " -> {- case branch  0s"mod " -} do (_472 : uint 64) <- ICC.OpParam
                                                                          pure {opMod: _472}
                             ; 0s"pow " -> {- case branch  0s"pow " -} do (_473 : uint 64) <- ICC.OpParam
                                                                          pure {opPow: _473}
                             ; 0s"gama" -> {- case branch  0s"gama" -} do (_474 : uint 64) <- ICC.OpParam
                                                                          pure {opGamma: _474}
                             ; 0s"sadd" -> {- case branch  0s"sadd" -} do (_475 : uint 64) <- ICC.OpParam
                                                                          pure {opSAdd: _475}
                             ; 0s"ssub" -> {- case branch  0s"ssub" -} do (_476 : uint 64) <- ICC.OpParam
                                                                          pure {opSSub: _476}
                             ; 0s"smul" -> {- case branch  0s"smul" -} do (_477 : uint 64) <- ICC.OpParam
                                                                          pure {opSMul: _477}
                             ; 0s"sdiv" -> {- case branch  0s"sdiv" -} do (_478 : uint 64) <- ICC.OpParam
                                                                          pure {opSDiv: _478}
                             ; 0s"sq  " -> {- case branch  0s"sq  " -} do (_479 : uint 64) <- ICC.OpParam
                                                                          pure {opSq: _479}
                             ; 0s"sqrt" -> {- case branch  0s"sqrt" -} do (_480 : uint 64) <- ICC.OpParam
                                                                          pure {opSqrt: _480}
                             ; 0s"cb  " -> {- case branch  0s"cb  " -} do (_481 : uint 64) <- ICC.OpParam
                                                                          pure {opCb: _481}
                             ; 0s"cbrt" -> {- case branch  0s"cbrt" -} do (_482 : uint 64) <- ICC.OpParam
                                                                          pure {opCbrt: _482}
                             ; 0s"abs " -> {- case branch  0s"abs " -} do (_483 : uint 64) <- ICC.OpParam
                                                                          pure {opAbs: _483}
                             ; 0s"neg " -> {- case branch  0s"neg " -} do (_484 : uint 64) <- ICC.OpParam
                                                                          pure {opNeg: _484}
                             ; 0s"rond" -> {- case branch  0s"rond" -} do (_485 : uint 64) <- ICC.OpParam
                                                                          pure {opRond: _485}
                             ; 0s"flor" -> {- case branch  0s"flor" -} do (_486 : uint 64) <- ICC.OpParam
                                                                          pure {opFlor: _486}
                             ; 0s"ceil" -> {- case branch  0s"ceil" -} do (_487 : uint 64) <- ICC.OpParam
                                                                          pure {opCeil: _487}
                             ; 0s"trnc" -> {- case branch  0s"trnc" -} do (_488 : uint 64) <- ICC.OpParam
                                                                          pure {opTrnc: _488}
                             ; 0s"sign" -> {- case branch  0s"sign" -} do (_489 : uint 64) <- ICC.OpParam
                                                                          pure {opSign: _489}
                             ; 0s"exp " -> {- case branch  0s"exp " -} do (_490 : uint 64) <- ICC.OpParam
                                                                          pure {opExp: _490}
                             ; 0s"log " -> {- case branch  0s"log " -} do (_491 : uint 64) <- ICC.OpParam
                                                                          pure {opLog: _491}
                             ; 0s"ln  " -> {- case branch  0s"ln  " -} do (_492 : uint 64) <- ICC.OpParam
                                                                          pure {opLn: _492}
                             ; 0s"sin " -> {- case branch  0s"sin " -} do (_493 : uint 64) <- ICC.OpParam
                                                                          pure {opSin: _493}
                             ; 0s"cos " -> {- case branch  0s"cos " -} do (_494 : uint 64) <- ICC.OpParam
                                                                          pure {opCos: _494}
                             ; 0s"tan " -> {- case branch  0s"tan " -} do (_495 : uint 64) <- ICC.OpParam
                                                                          pure {opTan: _495}
                             ; 0s"asin" -> {- case branch  0s"asin" -} do (_496 : uint 64) <- ICC.OpParam
                                                                          pure {opASin: _496}
                             ; 0s"acos" -> {- case branch  0s"acos" -} do (_497 : uint 64) <- ICC.OpParam
                                                                          pure {opACos: _497}
                             ; 0s"atan" -> {- case branch  0s"atan" -} do (_498 : uint 64) <- ICC.OpParam
                                                                          pure {opATan: _498}
                             ; 0s"atn2" -> {- case branch  0s"atn2" -} do (_499 : uint 64) <- ICC.OpParam
                                                                          pure {opATn2: _499}
                             ; 0s"ctop" -> {- case branch  0s"ctop" -} do (_500 : uint 64) <- ICC.OpParam
                                                                          pure {opCTop: _500}
                             ; 0s"ptoc" -> {- case branch  0s"ptoc" -} do (_501 : uint 64) <- ICC.OpParam
                                                                          pure {opPToc: _501}
                             ; 0s"rnum" -> {- case branch  0s"rnum" -} do (_502 : uint 64) <- ICC.OpParam
                                                                          pure {opRNum: _502}
                             ; 0s"lt  " -> {- case branch  0s"lt  " -} do (_503 : uint 64) <- ICC.OpParam
                                                                          pure {opLT: _503}
                             ; 0s"le  " -> {- case branch  0s"le  " -} do (_504 : uint 64) <- ICC.OpParam
                                                                          pure {opLE: _504}
                             ; 0s"eq  " -> {- case branch  0s"eq  " -} do (_505 : uint 64) <- ICC.OpParam
                                                                          pure {opEQ: _505}
                             ; 0s"near" -> {- case branch  0s"near" -} do (_506 : uint 64) <- ICC.OpParam
                                                                          pure {opNear: _506}
                             ; 0s"ge  " -> {- case branch  0s"ge  " -} do (_507 : uint 64) <- ICC.OpParam
                                                                          pure {opGE: _507}
                             ; 0s"gt  " -> {- case branch  0s"gt  " -} do (_508 : uint 64) <- ICC.OpParam
                                                                          pure {opGT: _508}
                             ; 0s"vmin" -> {- case branch  0s"vmin" -} do (_509 : uint 64) <- ICC.OpParam
                                                                          pure {opVMin: _509}
                             ; 0s"vmax" -> {- case branch  0s"vmax" -} do (_510 : uint 64) <- ICC.OpParam
                                                                          pure {opVMax: _510}
                             ; 0s"vand" -> {- case branch  0s"vand" -} do (_511 : uint 64) <- ICC.OpParam
                                                                          pure {opVAnd: _511}
                             ; 0s"vor " -> {- case branch  0s"vor " -} do (_512 : uint 64) <- ICC.OpParam
                                                                          pure {opVOr: _512}
                             ; 0s"tLab" -> {- case branch  0s"tLab" -} do (_513 : uint 64) <- ICC.OpParam
                                                                          pure {opTLab: _513}
                             ; 0s"tXYZ" -> {- case branch  0s"tXYZ" -} do (_514 : uint 64) <- ICC.OpParam
                                                                          pure {opTXYZ: _514}
                             ; 0s"if  " -> {- case branch  0s"if  " -} do (thenOps : uint 64) <- do (_515 : uint 32) <- Daedalus.BEUInt32
                                                                                                    pure (_515 as uint 64)
                                                                          ($$ : ICC.FunOp) <- do (_517 : Maybe [uint 8]) <- Optional (MatchBytes "else")
                                                                                                 case _517 is
                                                                                                   { nothing -> {- case branch  nothing -} do (_518 : [ICC.FunOpWithPosition]) <- ICC.ManyFunOps thenOps
                                                                                                                                              pure {opIfThen: _518}
                                                                                                   ; just _ -> {- case branch  just _ -} do (_521 : ICC.IfThenElse) <- do (_520 : uint 64) <- do (_519 : uint 32) <- Daedalus.BEUInt32
                                                                                                                                                                                                 pure (_519 as uint 64)
                                                                                                                                                                          ICC.IfThenElse thenOps _520
                                                                                                                                            pure {opIfThenElse: _521}
                                                                                                   }
                                                                          pure $$
                             ; 0s"else" -> {- case branch  0s"else" -} Fail "`else` with no `if"
                             ; 0s"sel " -> {- case branch  0s"sel " -} do ICC._NoParams
                                                                          (c1 : uint 64) <- ICC.SelCase
                                                                          (cs : [uint 64]) <- Many[] ICC.SelCase
                                                                          (d : Maybe (uint 64)) <- Optional do @MatchBytes "dflt"
                                                                                                               ($$ : uint 64) <- do (_523 : uint 32) <- Daedalus.BEUInt32
                                                                                                                                    pure (_523 as uint 64)
                                                                                                               pure $$
                                                                          ($$ : ICC.FunOp) <- do (_525 : ICC.Sel) <- ICC.Sel c1 cs d
                                                                                                 pure {opSel: _525}
                                                                          pure $$
                             ; 0s"case" -> {- case branch  0s"case" -} Fail "`case` with no `sel`"
                             ; 0s"dflt" -> {- case branch  0s"dflt" -} Fail "`dflt` with no `sel`"
                             ; _ -> Fail (concat ["invalid tag: ",
                                                  ICC.explode32 tag])
                             }
       pure $$
   
  ICC.FunOpWithPosition : Grammar ICC.FunOpWithPosition =
    do (offset : Stream) <- CurrentStream
       (op : ICC.FunOp) <- ICC.FunOp
       pure {offset = offset,
             op = op}
 
ICC._StartTag (x : [uint 8]) : Grammar {} =
  do @MatchBytes x
     @MatchBytes [0,
                  0,
                  0,
                  0]
 
ICC.CalcFun : Grammar [ICC.FunOpWithPosition] =
  do ICC._StartTag "func"
     ($$ : [ICC.FunOpWithPosition]) <- do (_528 : uint 64) <- do (_527 : uint 32) <- Daedalus.BEUInt32
                                                                 pure (_527 as uint 64)
                                          ICC.ManyFunOps _528
     pure $$
 
ICC.PositionNumber : Grammar ICC.PositionNumber =
  do (offset : uint 64) <- do (_529 : uint 32) <- Daedalus.BEUInt32
                              pure (_529 as uint 64)
     (size : uint 64) <- do (_530 : uint 32) <- Daedalus.BEUInt32
                            pure (_530 as uint 64)
     pure {offset = offset,
           size = size}
 
ICC.Positioned ?a0 (s : Stream) (P : Grammar ?a0) : Grammar ?a0 =
  do (p : ICC.PositionNumber) <- ICC.PositionNumber
     ($$ : ?a0) <- Daedalus.LookAhead ?a0 do Daedalus._SetStreamAt (p.offset) s
                                             ($$ : ?a0) <- Daedalus.Chunk ?a0 (p.size) P
                                             pure $$
     pure $$
 
ICC.SingleSampledCurve : Grammar ICC.SingleSampledCurve =
  do (n : uint 32) <- Daedalus.BEUInt32
     (f : uint 32) <- Daedalus.BEUInt32
     (l : uint 32) <- Daedalus.BEUInt32
     (e : uint 16) <- Daedalus.BEUInt16
     (ty : uint 16) <- Daedalus.BEUInt16
     pure {n = n,
           f = f,
           l = l,
           e = e,
           ty = ty}
 
ICC.FormualCurveSegment : Grammar ICC.FormualCurveSegment =
  do (fun : uint 16) <- Daedalus.BEUInt16
     do (_534 : bool) <- do (_533 : uint 16) <- Daedalus.BEUInt16
                            pure (_533 == 0)
        Daedalus._Guard _534
     ($$ : ICC.FormualCurveSegment) <- case fun is
                                         { 0 -> {- case branch  0 -} do (fun : uint 16) <- pure fun
                                                                        (args : [float]) <- Many[4] Daedalus.BEFloat
                                                                        pure {fun = fun,
                                                                              args = args}
                                         ; 1 -> {- case branch  1 -} do (fun : uint 16) <- pure fun
                                                                        (args : [float]) <- Many[5] Daedalus.BEFloat
                                                                        pure {fun = fun,
                                                                              args = args}
                                         ; 2 -> {- case branch  2 -} do (fun : uint 16) <- pure fun
                                                                        (args : [float]) <- Many[5] Daedalus.BEFloat
                                                                        pure {fun = fun,
                                                                              args = args}
                                         ; 3 -> {- case branch  3 -} do (fun : uint 16) <- pure fun
                                                                        (args : [float]) <- Many[4] Daedalus.BEFloat
                                                                        pure {fun = fun,
                                                                              args = args}
                                         }
     pure $$
 
ICC.CurveSegment : Grammar ICC.CurveSegment =
  do (tag : uint 32) <- Daedalus.BEUInt32
     ICC._Exactly (uint 32) 0 Daedalus.BEUInt32
     ($$ : ICC.CurveSegment) <- case tag is
                                  { 0s"parf" -> {- case branch  0s"parf" -} do (_537 : ICC.FormualCurveSegment) <- ICC.FormualCurveSegment
                                                                               pure {parf: _537}
                                  ; 0s"samf" -> {- case branch  0s"samf" -} do (_540 : [float]) <- do (_539 : uint 64) <- do (_538 : uint 32) <- Daedalus.BEUInt32
                                                                                                                             pure (_538 as uint 64)
                                                                                                      Many[_539] Daedalus.BEFloat
                                                                               pure {samf: _540}
                                  }
     pure $$
 
ICC.SegmentedCurve : Grammar ICC.SegmentedCurve =
  do (n : uint 64) <- do (_541 : uint 16) <- Daedalus.BEUInt16
                         pure (_541 as uint 64)
     Choose biased
       { Daedalus._Guard (1 <= n)
       | Fail "Need at least one curve segment"
       }
     ICC._Exactly (uint 16) 0 Daedalus.BEUInt16
     (bnum : uint 64) <- pure (n - 1)
     (breakPoints : [float]) <- Many[bnum] Daedalus.BEFloat
     (segments : [ICC.CurveSegment]) <- Many[n] ICC.CurveSegment
     pure {breakPoints = breakPoints,
           segments = segments}
 
ICC.Curve : Grammar ICC.Curve =
  do (tag : uint 32) <- Daedalus.BEUInt32
     ICC._Exactly (uint 32) 0 Daedalus.BEUInt32
     ($$ : ICC.Curve) <- case tag is
                           { 0s"sngf" -> {- case branch  0s"sngf" -} do (_543 : ICC.SingleSampledCurve) <- ICC.SingleSampledCurve
                                                                        pure {sngf: _543}
                           ; 0s"curf" -> {- case branch  0s"curf" -} do (_544 : ICC.SegmentedCurve) <- ICC.SegmentedCurve
                                                                        pure {curf: _544}
                           ; _ -> pure {unimplemented: (ICC.explode32 tag)}
                           }
     pure $$
 
ICC.Matrix (p : uint 64) (q : uint 64) : Grammar ICC.Matrix =
  do (matrix : [[float]]) <- Many[q] Many[p] Daedalus.BEFloat
     (vector : [float]) <- Many[q] Daedalus.BEFloat
     pure {matrix = matrix,
           vector = vector}
 
rec value
  ICC.MPElement : Grammar ICC.MPElement =
    do (head : ICC.MPElementHead) <- ICC.MPElementHead
       (body : ICC.MPElementBody) <- ICC.MPElementBody head
       pure {head = head,
             body = body}
   
  ICC.CalcElement (head : ICC.MPElementHead) : Grammar ICC.CalcElement =
    do (subElNum : uint 64) <- do (_545 : uint 32) <- Daedalus.BEUInt32
                                  pure (_545 as uint 64)
       (inputs : uint 64) <- pure (head.inputs)
       (outputs : uint 64) <- pure (head.outputs)
       (main : [ICC.FunOpWithPosition]) <- ICC.Positioned [ICC.FunOpWithPosition] (head.offset) ICC.CalcFun
       (subElements : [ICC.MPElement]) <- Many[subElNum] ICC.Positioned ICC.MPElement (head.offset) ICC.MPElement
       pure {inputs = inputs,
             outputs = outputs,
             main = main,
             subElements = subElements}
   
  ICC.MPElementBody (head : ICC.MPElementHead) : Grammar ICC.MPElementBody =
    case head.tag is
      { 0s"calc" -> {- case branch  0s"calc" -} do (_546 : ICC.CalcElement) <- ICC.CalcElement head
                                                   pure {calc: _546}
      ; 0s"cvst" -> {- case branch  0s"cvst" -} do (_547 : [ICC.Curve]) <- Many[head.inputs] ICC.Positioned ICC.Curve (head.offset) ICC.Curve
                                                   pure {cvst: _547}
      ; 0s"matf" -> {- case branch  0s"matf" -} do (_548 : ICC.Matrix) <- ICC.Matrix (head.inputs) (head.outputs)
                                                   pure {matf: _548}
      ; 0s"mpet" -> {- case branch  0s"mpet" -} do (_551 : [ICC.MPElement]) <- do (n : uint 64) <- do (_549 : uint 32) <- Daedalus.BEUInt32
                                                                                                      pure (_549 as uint 64)
                                                                                  Choose biased
                                                                                    { Daedalus._Guard (1 <= n)
                                                                                    | Fail "Need at least one MPE"
                                                                                    }
                                                                                  ($$ : [ICC.MPElement]) <- Many[n] ICC.Positioned ICC.MPElement (head.offset) ICC.MPElement
                                                                                  pure $$
                                                   pure {mpet: _551}
      ; _ -> pure {unimplemented: (ICC.explode32 (head.tag))}
      }
 
ICC.MultiProcessElementsType : Grammar ICC.MPElement =
  ICC.MPElement
 
ICC.LutAToBType : Grammar ICC.LutAToBType =
  do ICC._StartTag "mAB "
     (number_of_input_channels : uint 8) <- GetByte
     (number_of_output_channels : uint 8) <- GetByte
     @MatchBytes [0,
                  0]
     (offset_first_B_curve : uint 32) <- Daedalus.BEUInt32
     (offset_to_matrix : uint 32) <- Daedalus.BEUInt32
     (offset_to_first_M_curve : uint 32) <- Daedalus.BEUInt32
     (offset_to_CLUT : uint 32) <- Daedalus.BEUInt32
     (offset_to_first_A_curve : uint 32) <- Daedalus.BEUInt32
     (data : Stream) <- CurrentStream
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           offset_first_B_curve = offset_first_B_curve,
           offset_to_matrix = offset_to_matrix,
           offset_to_first_M_curve = offset_to_first_M_curve,
           offset_to_CLUT = offset_to_CLUT,
           offset_to_first_A_curve = offset_to_first_A_curve,
           data = data}
 
ICC.LutAB_or_multi : Grammar ICC.LutAB_or_multi =
  Choose biased
    { {- lutAB -} do (_552 : ICC.LutAToBType) <- ICC.LutAToBType
                     pure {lutAB: _552}
    | {- mpe -} do (_553 : ICC.MPElement) <- ICC.MultiProcessElementsType
                   pure {mpe: _553}
    }
 
ICC.LutBA_or_multi : Grammar ICC.LutBA_or_multi =
  Choose biased
    { {- lutBA -} do (_554 : ICC.LutAToBType) <- ICC.LutAToBType
                     pure {lutBA: _554}
    | {- mpe -} do (_555 : ICC.MPElement) <- ICC.MultiProcessElementsType
                   pure {mpe: _555}
    }
 
ICC.CurveType : Grammar [uint 16] =
  do ICC._StartTag "curv"
     (n : uint 64) <- do (_556 : uint 32) <- Daedalus.BEUInt32
                         pure (_556 as uint 64)
     ($$ : [uint 16]) <- Many[n] Daedalus.BEUInt16
     pure $$
 
ICC.ParametricCurveType : Grammar ICC.ParametricCurveType =
  do ICC._StartTag "para"
     (function : uint 16) <- Daedalus.BEUInt16
     @MatchBytes [0,
                  0]
     (parameters : [uint 32]) <- Many[] Daedalus.BEUInt32
     pure {function = function,
           parameters = parameters}
 
ICC.CurveOrPCurve : Grammar ICC.CurveOrPCurve =
  Choose biased
    { {- curve -} do (_558 : [uint 16]) <- ICC.CurveType
                     pure {curve: _558}
    | {- pcurve -} do (_559 : ICC.ParametricCurveType) <- ICC.ParametricCurveType
                      pure {pcurve: _559}
    }
 
ICC.ASCII7 : Grammar [uint 7] =
  do ($$ : [uint 7]) <- Many[] do (_560 : uint 8) <- Match (1 .. 255)
                                  _560 AS uint 7
     Choose biased
       { @Many[ 1 .. ] @Match {0}
       | Fail "Non 0 string terminator"
       }
     pure $$
 
ICC.TextType : Grammar [uint 7] =
  do ICC._StartTag "text"
     ($$ : [uint 7]) <- ICC.ASCII7
     pure $$
 
ICC.UnicodeRecord (s : Stream) : Grammar ICC.UnicodeRecord =
  do (language : [uint 8]) <- Many[2] GetByte
     (country : [uint 8]) <- Many[2] GetByte
     (data : [uint 8]) <- ICC.Positioned [uint 8] s (Many[] GetByte)
     pure {language = language,
           country = country,
           data = data}
 
ICC.MultiLocalizedUnicodeType : Grammar [ICC.UnicodeRecord] =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "mluc"
     (record_number : uint 32) <- Daedalus.BEUInt32
     ICC._Exactly (uint 32) 12 Daedalus.BEUInt32
     ($$ : [ICC.UnicodeRecord]) <- Many[record_number as uint 64] ICC.UnicodeRecord s
     pure $$
 
ICC.TextDescriptionType : Grammar ICC.TextDescriptionType =
  do ICC._StartTag "desc"
     (ascii_data : [uint 8]) <- do (_564 : uint 64) <- do (_563 : uint 32) <- Daedalus.BEUInt32
                                                          pure (_563 as uint 64)
                                   Many[_564] GetByte
     (unicode_code : [uint 8]) <- Many[4] GetByte
     (unicode_data : [uint 8]) <- do (_567 : uint 64) <- do (_566 : uint 32) <- do (_565 : uint 32) <- Daedalus.BEUInt32
                                                                                   pure (2 * _565)
                                                            pure (_566 as uint 64)
                                     Many[_567] GetByte
     (script_code : [uint 8]) <- Many[2] GetByte
     Daedalus._BEUInt32
     (script_data : [uint 8]) <- do (_570 : uint 64) <- do (_569 : uint 32) <- Daedalus.BEUInt32
                                                           pure (_569 as uint 64)
                                    Many[_570] GetByte
     @Many[] @Match {0}
     pure {ascii_data = ascii_data,
           unicode_code = unicode_code,
           unicode_data = unicode_data,
           script_code = script_code,
           script_data = script_data}
 
ICC.LaxTextType : Grammar ICC.LaxTextType =
  Choose biased
    { {- uni -} do (_571 : [ICC.UnicodeRecord]) <- ICC.MultiLocalizedUnicodeType
                   pure {uni: _571}
    | {- desc -} do (_572 : ICC.TextDescriptionType) <- Daedalus.Only ICC.TextDescriptionType ICC.TextDescriptionType
                    pure {desc: _572}
    | {- text -} do (_573 : [uint 7]) <- Daedalus.Only [uint 7] ICC.TextType
                    pure {text: _573}
    }
 
ICC.S15Fixed16ArrayType : Grammar [uint 32] =
  Daedalus.Only [uint 32] do ICC._StartTag "sf32"
                             ($$ : [uint 32]) <- Many[] Daedalus.BEUInt32
                             pure $$
 
ICC.XYNumber : Grammar ICC.XYNumber =
  do (x : uint 32) <- Daedalus.BEUInt32
     (y : uint 32) <- Daedalus.BEUInt32
     pure {x = x,
           y = y}
 
ICC.ChromaticityType : Grammar ICC.ChromaticityType =
  do ICC._StartTag "chrm"
     (number_of_device_channels : uint 64) <- do (_575 : uint 16) <- Daedalus.BEUInt16
                                                 pure (_575 as uint 64)
     (phosphor_or_colorant : uint 16) <- Daedalus.BEUInt16
     (cie_coords : [ICC.XYNumber]) <- Many[number_of_device_channels] ICC.XYNumber
     pure {phosphor_or_colorant = phosphor_or_colorant,
           cie_coords = cie_coords}
 
ICC.SpectralViewingConditionsType : Grammar ICC.SpectralViewingConditionsType =
  do ICC._StartTag "svcn"
     (colometric_observer : uint 32) <- Daedalus.BEUInt32
     (xxx : [uint 8]) <- Daedalus.Only [uint 8] (Many[] GetByte)
     pure {colometric_observer = colometric_observer,
           xxx = xxx}
 
ICC.XYZType : Grammar [ICC.XYZNumber] =
  do ICC._StartTag "XYZ "
     ($$ : [ICC.XYZNumber]) <- Many[] do ($$ : ICC.XYZNumber) <- ICC.XYZNumber
                                         Choose biased
                                           { Daedalus._Guard (0 <= ($$.x))
                                           | Fail "x value needs to be positive"
                                           }
                                         Choose biased
                                           { Daedalus._Guard (0 <= ($$.y))
                                           | Fail "y value needs to be positive"
                                           }
                                         Choose biased
                                           { Daedalus._Guard (0 <= ($$.z))
                                           | Fail "z value needs to be positive"
                                           }
                                         pure $$
     pure $$
 
ICC.Tag (sig : uint 32) : Grammar ICC.Tag =
  Choose biased
    { case sig is
        { 0s"desc" -> {- case branch  0s"desc" -} do (_577 : ICC.LaxTextType) <- ICC.LaxTextType
                                                     pure {desc: _577}
        ; 0s"A2B0" -> {- case branch  0s"A2B0" -} do (_578 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                                                     pure {A2B0: _578}
        ; 0s"A2B1" -> {- case branch  0s"A2B1" -} do (_579 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                                                     pure {A2B1: _579}
        ; 0s"A2B2" -> {- case branch  0s"A2B2" -} do (_580 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                                                     pure {A2B2: _580}
        ; 0s"A2B3" -> {- case branch  0s"A2B3" -} do (_581 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                                                     pure {A2B3: _581}
        ; 0s"A2M0" -> {- case branch  0s"A2M0" -} do (_582 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {A2M0: _582}
        ; 0s"B2A0" -> {- case branch  0s"B2A0" -} do (_583 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                                                     pure {B2A0: _583}
        ; 0s"B2A1" -> {- case branch  0s"B2A1" -} do (_584 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                                                     pure {B2A1: _584}
        ; 0s"B2A2" -> {- case branch  0s"B2A2" -} do (_585 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                                                     pure {B2A2: _585}
        ; 0s"B2A3" -> {- case branch  0s"B2A3" -} do (_586 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                                                     pure {B2A3: _586}
        ; 0s"B2D0" -> {- case branch  0s"B2D0" -} do (_587 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {B2D0: _587}
        ; 0s"B2D1" -> {- case branch  0s"B2D1" -} do (_588 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {B2D1: _588}
        ; 0s"B2D2" -> {- case branch  0s"B2D2" -} do (_589 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {B2D2: _589}
        ; 0s"B2D3" -> {- case branch  0s"B2D3" -} do (_590 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {B2D3: _590}
        ; 0s"wtpt" -> {- case branch  0s"wtpt" -} do (_591 : [ICC.XYZNumber]) <- Daedalus.Only [ICC.XYZNumber] ICC.XYZType
                                                     pure {wtpt: _591}
        ; 0s"cprt" -> {- case branch  0s"cprt" -} do (_592 : ICC.LaxTextType) <- ICC.LaxTextType
                                                     pure {cprt: _592}
        ; 0s"c2sp" -> {- case branch  0s"c2sp" -} do (_593 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {c2sp: _593}
        ; 0s"s2cp" -> {- case branch  0s"s2cp" -} do (_594 : ICC.MPElement) <- ICC.MultiProcessElementsType
                                                     pure {s2cp: _594}
        ; 0s"svcn" -> {- case branch  0s"svcn" -} do (_595 : ICC.SpectralViewingConditionsType) <- ICC.SpectralViewingConditionsType
                                                     pure {svcn: _595}
        ; 0s"rXYZ" -> {- case branch  0s"rXYZ" -} do (_596 : [ICC.XYZNumber]) <- Daedalus.Only [ICC.XYZNumber] ICC.XYZType
                                                     pure {rXYZ: _596}
        ; 0s"gXYZ" -> {- case branch  0s"gXYZ" -} do (_597 : [ICC.XYZNumber]) <- Daedalus.Only [ICC.XYZNumber] ICC.XYZType
                                                     pure {gXYZ: _597}
        ; 0s"bXYZ" -> {- case branch  0s"bXYZ" -} do (_598 : [ICC.XYZNumber]) <- Daedalus.Only [ICC.XYZNumber] ICC.XYZType
                                                     pure {bXYZ: _598}
        ; 0s"rTRC" -> {- case branch  0s"rTRC" -} do (_599 : ICC.CurveOrPCurve) <- ICC.CurveOrPCurve
                                                     pure {rTRC: _599}
        ; 0s"gTRC" -> {- case branch  0s"gTRC" -} do (_600 : ICC.CurveOrPCurve) <- ICC.CurveOrPCurve
                                                     pure {gTRC: _600}
        ; 0s"bTRC" -> {- case branch  0s"bTRC" -} do (_601 : ICC.CurveOrPCurve) <- ICC.CurveOrPCurve
                                                     pure {bTRC: _601}
        ; 0s"dmdd" -> {- case branch  0s"dmdd" -} do (_602 : ICC.LaxTextType) <- ICC.LaxTextType
                                                     pure {dmdd: _602}
        ; 0s"dmnd" -> {- case branch  0s"dmnd" -} do (_603 : ICC.LaxTextType) <- ICC.LaxTextType
                                                     pure {dmnd: _603}
        ; 0s"chrm" -> {- case branch  0s"chrm" -} do (_604 : ICC.ChromaticityType) <- ICC.ChromaticityType
                                                     pure {chrm: _604}
        ; 0s"chad" -> {- case branch  0s"chad" -} do (_605 : [uint 32]) <- ICC.S15Fixed16ArrayType
                                                     pure {chad: _605}
        ; _ -> pure {unimplemented: (ICC.explode32 sig)}
        }
    | do (_606 : ICC.InvalidTag) <- ICC.InvalidTag sig
         pure {invalid_tag: _606}
    }
 
ICC.TagTable (s : Stream) : Grammar [ICC.Tag] =
  do (_609 : uint 64) <- do (_608 : uint 32) <- Daedalus.BEUInt32
                            pure (_608 as uint 64)
     Many[_609] do (sig : uint 32) <- Daedalus.BEUInt32
                   ($$ : ICC.Tag) <- ICC.Positioned ICC.Tag s (ICC.Tag sig)
                   pure $$
 
ICC.ICC : Grammar ICC.ICC =
  do (s : Stream) <- CurrentStream
     (header : ICC.ProfileHeader) <- ICC.ProfileHeader
     (tags : [ICC.Tag]) <- ICC.TagTable s
     pure {header = header,
           tags = tags}
 
ICC.Response16Number : Grammar ICC.Response16Number =
  do (device : uint 16) <- Daedalus.BEUInt16
     ICC._Exactly (uint 16) 0 Daedalus.BEUInt16
     (measurement : uint 32) <- Daedalus.BEUInt32
     pure {device = device,
           measurement = measurement}
 
ICC.StartTag (x : [uint 8]) : Grammar [uint 8] =
  do @MatchBytes x
     ($$ : [uint 8]) <- MatchBytes [0,
                                    0,
                                    0,
                                    0]
     pure $$
 
ICC.DateTimeType : Grammar ICC.DateTimeNumber =
  do ICC._StartTag "dtim"
     ($$ : ICC.DateTimeNumber) <- ICC.DateTimeNumber
     pure $$
 
ICC.SignatureType : Grammar [uint 8] =
  do ICC._StartTag "sig "
     ($$ : [uint 8]) <- Many[4] GetByte
     pure $$
 
ICC.ColorantOrderType : Grammar [uint 8] =
  do ICC._StartTag "clro"
     Daedalus._BEUInt32
     ($$ : [uint 8]) <- Many[] GetByte
     pure $$
 
ICC.Colorant : Grammar ICC.Colorant =
  do (name : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (pcs : [uint 16]) <- Many[3] Daedalus.BEUInt16
     pure {name = name,
           pcs = pcs}
 
ICC.ColorantTableType : Grammar [ICC.Colorant] =
  do ICC._StartTag "clrt"
     (count_of_colorant : uint 64) <- do (_613 : uint 32) <- Daedalus.BEUInt32
                                         pure (_613 as uint 64)
     ($$ : [ICC.Colorant]) <- Many[count_of_colorant] ICC.Colorant
     pure $$
 
ICC.ResponseCurve (n : uint 64) : Grammar ICC.ResponseCurve =
  do (measurement_unit : uint 32) <- Daedalus.BEUInt32
     (counts : [uint 32]) <- Many[n] Daedalus.BEUInt32
     (pcxyzs : [ICC.XYNumber]) <- Many[n] ICC.XYNumber
     (response_arrays : [[ICC.Response16Number]]) <- map ((qi : uint 32) in counts)
                                                       (Many[qi as uint 64] ICC.Response16Number)
     pure {measurement_unit = measurement_unit,
           pcxyzs = pcxyzs,
           response_arrays = response_arrays}
 
ICC.ResponseCurveSet16Type : Grammar [ICC.ResponseCurve] =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "rcs2"
     (number_of_channels : uint 64) <- do (_615 : uint 16) <- Daedalus.BEUInt16
                                          pure (_615 as uint 64)
     (count : uint 64) <- do (_616 : uint 16) <- Daedalus.BEUInt16
                             pure (_616 as uint 64)
     ($$ : [ICC.ResponseCurve]) <- Many[count] do (off : uint 64) <- do (_618 : uint 32) <- Daedalus.BEUInt32
                                                                        pure (_618 as uint 64)
                                                  ($$ : ICC.ResponseCurve) <- Daedalus.LookAhead ICC.ResponseCurve do Daedalus._SetStreamAt off s
                                                                                                                      ($$ : ICC.ResponseCurve) <- ICC.ResponseCurve number_of_channels
                                                                                                                      pure $$
                                                  pure $$
     pure $$
 
ICC.exp ?a0 ?a1 (Arith ?a0) (Integral ?a1) (Literal 1 ?a1) (Literal 0 ?a1) (Literal 1 ?a0) (b : ?a0) (e : ?a1) : ?a0 =
  for ((x : ?a0) = 1; (i : ?a1) in rangeUp 0 e 1)
    (x * b)
 
ICC.Lut8Type : Grammar ICC.Lut8Type =
  do ICC._StartTag "mft1"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {0x00}
     (encoded_e_parameters : [sint 32]) <- Many[9] do (_621 : uint 32) <- Daedalus.BEUInt32
                                                      pure (_621 as sint 32)
     (input_tables : Stream) <- Daedalus.Bytes (256 * i)
     (clut_values : Stream) <- Daedalus.Bytes ((ICC.exp (uint 64) (uint 64) g i) * o)
     (output_tables : Stream) <- Daedalus.Bytes (256 * o)
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           number_of_clut_grid_points = number_of_clut_grid_points,
           encoded_e_parameters = encoded_e_parameters,
           input_tables = input_tables,
           clut_values = clut_values,
           output_tables = output_tables}
 
ICC.Lut16Type : Grammar ICC.Lut16Type =
  do ICC._StartTag "mft2"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {0x00}
     (encoded_e_parameters : [sint 32]) <- Many[9] do (_622 : uint 32) <- Daedalus.BEUInt32
                                                      pure (_622 as sint 32)
     (number_of_input_table_entries : uint 32) <- Daedalus.BEUInt32
     (n : uint 64) <- pure (number_of_input_table_entries as uint 64)
     (number_of_output_table_entries : uint 32) <- Daedalus.BEUInt32
     (m : uint 64) <- pure (number_of_output_table_entries as uint 64)
     (input_tables : Stream) <- Daedalus.Bytes ((256 * n) * i)
     (clut_values : Stream) <- Daedalus.Bytes ((2 * (ICC.exp (uint 64) (uint 64) g i)) * o)
     (output_tables : Stream) <- Daedalus.Bytes ((2 * m) * o)
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           number_of_clut_grid_points = number_of_clut_grid_points,
           encoded_e_parameters = encoded_e_parameters,
           number_of_input_table_entries = number_of_input_table_entries,
           number_of_output_table_entries = number_of_output_table_entries,
           input_tables = input_tables,
           clut_values = clut_values,
           output_tables = output_tables}
 
ICC.LutBToAType : Grammar ICC.LutBToAType =
  do ICC._StartTag "mBA "
     (number_of_input_channels : uint 8) <- GetByte
     (number_of_output_channels : uint 8) <- GetByte
     @MatchBytes [0,
                  0]
     (offset_first_B_curve : uint 32) <- Daedalus.BEUInt32
     (offset_to_matrix : uint 32) <- Daedalus.BEUInt32
     (offset_to_first_M_curve : uint 32) <- Daedalus.BEUInt32
     (offset_to_CLUT : uint 32) <- Daedalus.BEUInt32
     (offset_to_first_A_curve : uint 32) <- Daedalus.BEUInt32
     (data : Stream) <- CurrentStream
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           offset_first_B_curve = offset_first_B_curve,
           offset_to_matrix = offset_to_matrix,
           offset_to_first_M_curve = offset_to_first_M_curve,
           offset_to_CLUT = offset_to_CLUT,
           offset_to_first_A_curve = offset_to_first_A_curve,
           data = data}
 
ICC.MeasurementType : Grammar ICC.MeasurementType =
  do ICC._StartTag "meas"
     (standard_observer : uint 32) <- Daedalus.BEUInt32
     (nCIEXYZ : ICC.XYZNumber) <- ICC.XYZNumber
     (geometry : uint 32) <- Daedalus.BEUInt32
     (flare : uint 32) <- Daedalus.BEUInt32
     (illuminant : uint 32) <- Daedalus.BEUInt32
     pure {standard_observer = standard_observer,
           nCIEXYZ = nCIEXYZ,
           geometry = geometry,
           flare = flare,
           illuminant = illuminant}
 
ICC.ColorName (m : uint 64) : Grammar ICC.ColorName =
  do (name_root : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (pcs_coords : [uint 16]) <- Many[3] Daedalus.BEUInt16
     (device_coords : [uint 16]) <- Many[m] Daedalus.BEUInt16
     pure {name_root = name_root,
           pcs_coords = pcs_coords,
           device_coords = device_coords}
 
ICC.NamedColor2Type : Grammar ICC.NamedColor2Type =
  do ICC._StartTag "ncl2"
     (vendor_specific : uint 32) <- Daedalus.BEUInt32
     (count : uint 64) <- do (_623 : uint 32) <- Daedalus.BEUInt32
                             pure (_623 as uint 64)
     (number_of_coords : uint 64) <- do (_624 : uint 32) <- Daedalus.BEUInt32
                                        pure (_624 as uint 64)
     (prefix : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (suffix : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (names : [ICC.ColorName]) <- Many[count] ICC.ColorName number_of_coords
     pure {vendor_specific = vendor_specific,
           prefix = prefix,
           suffix = suffix,
           names = names}
 
ICC.ViewConditionsType : Grammar ICC.ViewConditionsType =
  do ICC._StartTag "view"
     (illuminantXYZ : ICC.XYZNumber) <- ICC.XYZNumber
     (surroundXYZ : ICC.XYZNumber) <- ICC.XYZNumber
     (illuminant : uint 32) <- Daedalus.BEUInt32
     pure {illuminantXYZ = illuminantXYZ,
           surroundXYZ = surroundXYZ,
           illuminant = illuminant}
 
ICC.Exactly ?a0 (x : ?a0) (P : Grammar ?a0) : Grammar {} =
  Choose biased
    { do (_424 : bool) <- do (_423 : ?a0) <- P
                             pure (_423 == x)
         Daedalus.Guard _424
    | Fail "Unexpected field value"
    }
 
ICC.ChunkRelativeTo (s : Stream) (off : uint 64) (sz : uint 64) : Grammar Stream =
  do Daedalus._SetStreamAt off s
     ($$ : Stream) <- Daedalus.Bytes sz
     pure $$
 
ICC._VersionField : Grammar {} =
  do @GetByte
     @GetByte
     @MatchBytes [0x00,
                  0x00]
 
ICC._ProfileClass : Grammar {} =
  do (_413 : uint 32) <- Daedalus.BEUInt32
     case _413 is
       { 0s"scnr" -> {- case branch  0s"scnr" -} pure {}
       ; 0s"mntr" -> {- case branch  0s"mntr" -} pure {}
       ; 0s"prtr" -> {- case branch  0s"prtr" -} pure {}
       ; 0s"link" -> {- case branch  0s"link" -} pure {}
       ; 0s"spac" -> {- case branch  0s"spac" -} pure {}
       ; 0s"abst" -> {- case branch  0s"abst" -} pure {}
       ; 0s"nmcl" -> {- case branch  0s"nmcl" -} pure {}
       ; 0s"cenc" -> {- case branch  0s"cenc" -} pure {}
       ; 0s"mid " -> {- case branch  0s"mid " -} pure {}
       ; 0s"mlnk" -> {- case branch  0s"mlnk" -} pure {}
       ; 0s"mvis" -> {- case branch  0s"mvis" -} pure {}
       }
 
ICC._DataColorSpace : Grammar {} =
  do (tag : uint 32) <- Daedalus.BEUInt32
     case tag is
       { 0s"XYZ " -> {- case branch  0s"XYZ " -} pure {}
       ; 0s"Lab " -> {- case branch  0s"Lab " -} pure {}
       ; 0s"Luv " -> {- case branch  0s"Luv " -} pure {}
       ; 0s"Ycbr" -> {- case branch  0s"Ycbr" -} pure {}
       ; 0s"Yxy " -> {- case branch  0s"Yxy " -} pure {}
       ; 0s"LMS " -> {- case branch  0s"LMS " -} pure {}
       ; 0s"RGB " -> {- case branch  0s"RGB " -} pure {}
       ; 0s"GRAY" -> {- case branch  0s"GRAY" -} pure {}
       ; 0s"HSV " -> {- case branch  0s"HSV " -} pure {}
       ; 0s"HLS " -> {- case branch  0s"HLS " -} pure {}
       ; 0s"CMYK" -> {- case branch  0s"CMYK" -} pure {}
       ; 0s"CMY " -> {- case branch  0s"CMY " -} pure {}
       ; 0s"2CLR" -> {- case branch  0s"2CLR" -} pure {}
       ; 0s"3CLR" -> {- case branch  0s"3CLR" -} pure {}
       ; 0s"4CLR" -> {- case branch  0s"4CLR" -} pure {}
       ; 0s"5CLR" -> {- case branch  0s"5CLR" -} pure {}
       ; 0s"6CLR" -> {- case branch  0s"6CLR" -} pure {}
       ; 0s"7CLR" -> {- case branch  0s"7CLR" -} pure {}
       ; 0s"8CLR" -> {- case branch  0s"8CLR" -} pure {}
       ; 0s"9CLR" -> {- case branch  0s"9CLR" -} pure {}
       ; 0s"ACLR" -> {- case branch  0s"ACLR" -} pure {}
       ; 0s"BCLR" -> {- case branch  0s"BCLR" -} pure {}
       ; 0s"CCLR" -> {- case branch  0s"CCLR" -} pure {}
       ; 0s"DCLR" -> {- case branch  0s"DCLR" -} pure {}
       ; 0s"ECLR" -> {- case branch  0s"ECLR" -} pure {}
       ; 0s"FCLR" -> {- case branch  0s"FCLR" -} pure {}
       ; 0 -> {- case branch  0 -} pure {}
       ; _ -> Daedalus._Guard ((tag >> 16) == 0s"ne")
       }
 
ICC._PrimaryPlatform : Grammar {} =
  do (_416 : uint 32) <- Daedalus.BEUInt32
     case _416 is
       { 0s"APPL" -> {- case branch  0s"APPL" -} pure {}
       ; 0s"MSFT" -> {- case branch  0s"MSFT" -} pure {}
       ; 0s"SGI " -> {- case branch  0s"SGI " -} pure {}
       ; 0s"SUNW" -> {- case branch  0s"SUNW" -} pure {}
       ; 0 -> {- case branch  0 -} pure {}
       }
 
ICC._RenderingIntent : Grammar {} =
  do (_417 : uint 32) <- Daedalus.BEUInt32
     case _417 is
       { 0 -> {- case branch  0 -} pure {}
       ; 1 -> {- case branch  1 -} pure {}
       ; 2 -> {- case branch  2 -} pure {}
       ; 3 -> {- case branch  3 -} pure {}
       }
 
ICC._XYZNumber : Grammar {} =
  do Daedalus._BESInt32
     Daedalus._BESInt32
     Daedalus._BESInt32
 
ICC._DateTimeNumber : Grammar {} =
  do Daedalus._BEUInt16
     Daedalus._BEUInt16
     Daedalus._BEUInt16
     Daedalus._BEUInt16
     Daedalus._BEUInt16
     Daedalus._BEUInt16
 
ICC._ProfileHeader : Grammar {} =
  do Daedalus._BEUInt32
     @Many[4] @GetByte
     ICC._VersionField
     ICC._ProfileClass
     ICC._DataColorSpace
     ICC._DataColorSpace
     ICC._DateTimeNumber
     @MatchBytes "acsp"
     ICC._PrimaryPlatform
     Daedalus._BEUInt32
     @Many[4] @GetByte
     @Many[4] @GetByte
     Daedalus._BEUInt64
     ICC._RenderingIntent
     ICC._XYZNumber
     @Many[4] @GetByte
     @Many[16] @GetByte
     @Many[28] @GetByte
 
ICC._InvalidTag : Grammar {} =
  @Many[] @GetByte
 
ICC._MPElementHead : Grammar {} =
  do Daedalus._BEUInt32
     @MatchBytes [0,
                  0,
                  0,
                  0]
     Daedalus._BEUInt16
     Daedalus._BEUInt16
 
ICC._SelCase : Grammar {} =
  do @MatchBytes "case"
     Daedalus._BEUInt32
 
ICC._OpParam : Grammar {} =
  do Daedalus._BEUInt16
     ICC._Exactly (uint 16) 0 Daedalus.BEUInt16
 
ICC._OpParams : Grammar {} =
  do Daedalus._BEUInt16
     Daedalus._BEUInt16
 
ICC._ManyFunOps (n : uint 64) : Grammar {} =
  Daedalus._Chunk [ICC.FunOpWithPosition] (8 * n) (Daedalus._Only [ICC.FunOpWithPosition] (@Many[] do ICC.FunOpWithPosition
                                                                                                      pure {}))
 
ICC._Sel (alt : uint 64) (alts : [uint 64]) (mbDflt : Maybe (uint 64)) : Grammar {} =
  do ICC._ManyFunOps alt
     do map ((n : uint 64) in alts)
          (ICC.ManyFunOps n)
        pure {}
     case mbDflt is
       { nothing -> {- case branch  nothing -} pure {}
       ; just n -> {- case branch  just n -} ICC._ManyFunOps n
       }
 
ICC._IfThenElse (thenOps : uint 64) (elseOps : uint 64) : Grammar {} =
  do ICC._ManyFunOps thenOps
     ICC._ManyFunOps elseOps
 
ICC._FunOp : Grammar {} =
  do (tag : uint 32) <- Daedalus.BEUInt32
     case tag is
       { 0s"data" -> {- case branch  0s"data" -} Daedalus._BEFloat
       ; 0s"in  " -> {- case branch  0s"in  " -} ICC._OpParams
       ; 0s"out " -> {- case branch  0s"out " -} ICC._OpParams
       ; 0s"tget" -> {- case branch  0s"tget" -} ICC._OpParams
       ; 0s"tput" -> {- case branch  0s"tput" -} ICC._OpParams
       ; 0s"tsav" -> {- case branch  0s"tsav" -} ICC._OpParams
       ; 0s"env " -> {- case branch  0s"env " -} Daedalus._BEUInt32
       ; 0s"curv" -> {- case branch  0s"curv" -} ICC._OpParam
       ; 0s"mtx " -> {- case branch  0s"mtx " -} ICC._OpParam
       ; 0s"clut" -> {- case branch  0s"clut" -} ICC._OpParam
       ; 0s"calc" -> {- case branch  0s"calc" -} ICC._OpParam
       ; 0s"tint" -> {- case branch  0s"tint" -} ICC._OpParam
       ; 0s"elem" -> {- case branch  0s"elem" -} ICC._OpParam
       ; 0s"copy" -> {- case branch  0s"copy" -} ICC._OpParams
       ; 0s"rotl" -> {- case branch  0s"rotl" -} ICC._OpParams
       ; 0s"rotr" -> {- case branch  0s"rotr" -} ICC._OpParams
       ; 0s"posd" -> {- case branch  0s"posd" -} ICC._OpParams
       ; 0s"flip" -> {- case branch  0s"flip" -} ICC._OpParam
       ; 0s"pop " -> {- case branch  0s"pop " -} ICC._OpParam
       ; 0s"solv" -> {- case branch  0s"solv" -} ICC._OpParams
       ; 0s"tran" -> {- case branch  0s"tran" -} ICC._OpParams
       ; 0s"sum " -> {- case branch  0s"sum " -} ICC._OpParam
       ; 0s"prod" -> {- case branch  0s"prod" -} ICC._OpParam
       ; 0s"min " -> {- case branch  0s"min " -} ICC._OpParam
       ; 0s"max " -> {- case branch  0s"max " -} ICC._OpParam
       ; 0s"and " -> {- case branch  0s"and " -} ICC._OpParam
       ; 0s"or  " -> {- case branch  0s"or  " -} ICC._OpParam
       ; 0s"pi  " -> {- case branch  0s"pi  " -} ICC._NoParams
       ; 0s"+INF" -> {- case branch  0s"+INF" -} ICC._NoParams
       ; 0s"-INF" -> {- case branch  0s"-INF" -} ICC._NoParams
       ; 0s"NaN " -> {- case branch  0s"NaN " -} ICC._NoParams
       ; 0s"add " -> {- case branch  0s"add " -} ICC._OpParam
       ; 0s"sub " -> {- case branch  0s"sub " -} ICC._OpParam
       ; 0s"mul " -> {- case branch  0s"mul " -} ICC._OpParam
       ; 0s"div " -> {- case branch  0s"div " -} ICC._OpParam
       ; 0s"mod " -> {- case branch  0s"mod " -} ICC._OpParam
       ; 0s"pow " -> {- case branch  0s"pow " -} ICC._OpParam
       ; 0s"gama" -> {- case branch  0s"gama" -} ICC._OpParam
       ; 0s"sadd" -> {- case branch  0s"sadd" -} ICC._OpParam
       ; 0s"ssub" -> {- case branch  0s"ssub" -} ICC._OpParam
       ; 0s"smul" -> {- case branch  0s"smul" -} ICC._OpParam
       ; 0s"sdiv" -> {- case branch  0s"sdiv" -} ICC._OpParam
       ; 0s"sq  " -> {- case branch  0s"sq  " -} ICC._OpParam
       ; 0s"sqrt" -> {- case branch  0s"sqrt" -} ICC._OpParam
       ; 0s"cb  " -> {- case branch  0s"cb  " -} ICC._OpParam
       ; 0s"cbrt" -> {- case branch  0s"cbrt" -} ICC._OpParam
       ; 0s"abs " -> {- case branch  0s"abs " -} ICC._OpParam
       ; 0s"neg " -> {- case branch  0s"neg " -} ICC._OpParam
       ; 0s"rond" -> {- case branch  0s"rond" -} ICC._OpParam
       ; 0s"flor" -> {- case branch  0s"flor" -} ICC._OpParam
       ; 0s"ceil" -> {- case branch  0s"ceil" -} ICC._OpParam
       ; 0s"trnc" -> {- case branch  0s"trnc" -} ICC._OpParam
       ; 0s"sign" -> {- case branch  0s"sign" -} ICC._OpParam
       ; 0s"exp " -> {- case branch  0s"exp " -} ICC._OpParam
       ; 0s"log " -> {- case branch  0s"log " -} ICC._OpParam
       ; 0s"ln  " -> {- case branch  0s"ln  " -} ICC._OpParam
       ; 0s"sin " -> {- case branch  0s"sin " -} ICC._OpParam
       ; 0s"cos " -> {- case branch  0s"cos " -} ICC._OpParam
       ; 0s"tan " -> {- case branch  0s"tan " -} ICC._OpParam
       ; 0s"asin" -> {- case branch  0s"asin" -} ICC._OpParam
       ; 0s"acos" -> {- case branch  0s"acos" -} ICC._OpParam
       ; 0s"atan" -> {- case branch  0s"atan" -} ICC._OpParam
       ; 0s"atn2" -> {- case branch  0s"atn2" -} ICC._OpParam
       ; 0s"ctop" -> {- case branch  0s"ctop" -} ICC._OpParam
       ; 0s"ptoc" -> {- case branch  0s"ptoc" -} ICC._OpParam
       ; 0s"rnum" -> {- case branch  0s"rnum" -} ICC._OpParam
       ; 0s"lt  " -> {- case branch  0s"lt  " -} ICC._OpParam
       ; 0s"le  " -> {- case branch  0s"le  " -} ICC._OpParam
       ; 0s"eq  " -> {- case branch  0s"eq  " -} ICC._OpParam
       ; 0s"near" -> {- case branch  0s"near" -} ICC._OpParam
       ; 0s"ge  " -> {- case branch  0s"ge  " -} ICC._OpParam
       ; 0s"gt  " -> {- case branch  0s"gt  " -} ICC._OpParam
       ; 0s"vmin" -> {- case branch  0s"vmin" -} ICC._OpParam
       ; 0s"vmax" -> {- case branch  0s"vmax" -} ICC._OpParam
       ; 0s"vand" -> {- case branch  0s"vand" -} ICC._OpParam
       ; 0s"vor " -> {- case branch  0s"vor " -} ICC._OpParam
       ; 0s"tLab" -> {- case branch  0s"tLab" -} ICC._OpParam
       ; 0s"tXYZ" -> {- case branch  0s"tXYZ" -} ICC._OpParam
       ; 0s"if  " -> {- case branch  0s"if  " -} do (thenOps : uint 64) <- do (_515 : uint 32) <- Daedalus.BEUInt32
                                                                              pure (_515 as uint 64)
                                                    (_517 : Maybe [uint 8]) <- Optional (MatchBytes "else")
                                                    case _517 is
                                                      { nothing -> {- case branch  nothing -} ICC._ManyFunOps thenOps
                                                      ; just _ -> {- case branch  just _ -} do (_520 : uint 64) <- do (_519 : uint 32) <- Daedalus.BEUInt32
                                                                                                                      pure (_519 as uint 64)
                                                                                               ICC._IfThenElse thenOps _520
                                                      }
       ; 0s"else" -> {- case branch  0s"else" -} Fail "`else` with no `if"
       ; 0s"sel " -> {- case branch  0s"sel " -} do ICC._NoParams
                                                    (c1 : uint 64) <- ICC.SelCase
                                                    (cs : [uint 64]) <- Many[] ICC.SelCase
                                                    (d : Maybe (uint 64)) <- Optional do @MatchBytes "dflt"
                                                                                         ($$ : uint 64) <- do (_523 : uint 32) <- Daedalus.BEUInt32
                                                                                                              pure (_523 as uint 64)
                                                                                         pure $$
                                                    ICC._Sel c1 cs d
       ; 0s"case" -> {- case branch  0s"case" -} Fail "`case` with no `sel`"
       ; 0s"dflt" -> {- case branch  0s"dflt" -} Fail "`dflt` with no `sel`"
       ; _ -> Fail (concat ["invalid tag: ",
                            ICC.explode32 tag])
       }
 
ICC._FunOpWithPosition : Grammar {} =
  ICC._FunOp
 
ICC._CalcFun : Grammar {} =
  do ICC._StartTag "func"
     (_528 : uint 64) <- do (_527 : uint 32) <- Daedalus.BEUInt32
                            pure (_527 as uint 64)
     ICC._ManyFunOps _528
 
ICC._PositionNumber : Grammar {} =
  do Daedalus._BEUInt32
     Daedalus._BEUInt32
 
ICC._Positioned ?a0 (s : Stream) (_P : Grammar {}) : Grammar {} =
  do (p : ICC.PositionNumber) <- ICC.PositionNumber
     Daedalus._LookAhead ?a0 do Daedalus._SetStreamAt (p.offset) s
                                Daedalus._Chunk ?a0 (p.size) _P
 
ICC._SingleSampledCurve : Grammar {} =
  do Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt16
     Daedalus._BEUInt16
 
ICC._FormualCurveSegment : Grammar {} =
  do (fun : uint 16) <- Daedalus.BEUInt16
     do (_534 : bool) <- do (_533 : uint 16) <- Daedalus.BEUInt16
                            pure (_533 == 0)
        Daedalus._Guard _534
     case fun is
       { 0 -> {- case branch  0 -} @Many[4] Daedalus._BEFloat
       ; 1 -> {- case branch  1 -} @Many[5] Daedalus._BEFloat
       ; 2 -> {- case branch  2 -} @Many[5] Daedalus._BEFloat
       ; 3 -> {- case branch  3 -} @Many[4] Daedalus._BEFloat
       }
 
ICC._CurveSegment : Grammar {} =
  do (tag : uint 32) <- Daedalus.BEUInt32
     ICC._Exactly (uint 32) 0 Daedalus.BEUInt32
     case tag is
       { 0s"parf" -> {- case branch  0s"parf" -} ICC._FormualCurveSegment
       ; 0s"samf" -> {- case branch  0s"samf" -} do (_539 : uint 64) <- do (_538 : uint 32) <- Daedalus.BEUInt32
                                                                           pure (_538 as uint 64)
                                                    @Many[_539] Daedalus._BEFloat
       }
 
ICC._SegmentedCurve : Grammar {} =
  do (n : uint 64) <- do (_541 : uint 16) <- Daedalus.BEUInt16
                         pure (_541 as uint 64)
     Choose biased
       { Daedalus._Guard (1 <= n)
       | Fail "Need at least one curve segment"
       }
     ICC._Exactly (uint 16) 0 Daedalus.BEUInt16
     (bnum : uint 64) <- pure (n - 1)
     @Many[bnum] Daedalus._BEFloat
     @Many[n] ICC._CurveSegment
 
ICC._Curve : Grammar {} =
  do (tag : uint 32) <- Daedalus.BEUInt32
     ICC._Exactly (uint 32) 0 Daedalus.BEUInt32
     case tag is
       { 0s"sngf" -> {- case branch  0s"sngf" -} ICC._SingleSampledCurve
       ; 0s"curf" -> {- case branch  0s"curf" -} ICC._SegmentedCurve
       ; _ -> pure {}
       }
 
ICC._Matrix (p : uint 64) (q : uint 64) : Grammar {} =
  do @Many[q] @Many[p] Daedalus._BEFloat
     @Many[q] Daedalus._BEFloat
 
ICC._MPElement : Grammar {} =
  do (head : ICC.MPElementHead) <- ICC.MPElementHead
     ICC.MPElementBody head
     pure {}
 
ICC._CalcElement (head : ICC.MPElementHead) : Grammar {} =
  do (subElNum : uint 64) <- do (_545 : uint 32) <- Daedalus.BEUInt32
                                pure (_545 as uint 64)
     ICC._Positioned [ICC.FunOpWithPosition] (head.offset) ICC._CalcFun
     @Many[subElNum] ICC._Positioned ICC.MPElement (head.offset) ICC._MPElement
 
ICC._MPElementBody (head : ICC.MPElementHead) : Grammar {} =
  case head.tag is
    { 0s"calc" -> {- case branch  0s"calc" -} ICC._CalcElement head
    ; 0s"cvst" -> {- case branch  0s"cvst" -} @Many[head.inputs] ICC._Positioned ICC.Curve (head.offset) ICC._Curve
    ; 0s"matf" -> {- case branch  0s"matf" -} ICC._Matrix (head.inputs) (head.outputs)
    ; 0s"mpet" -> {- case branch  0s"mpet" -} do (n : uint 64) <- do (_549 : uint 32) <- Daedalus.BEUInt32
                                                                     pure (_549 as uint 64)
                                                 Choose biased
                                                   { Daedalus._Guard (1 <= n)
                                                   | Fail "Need at least one MPE"
                                                   }
                                                 @Many[n] ICC._Positioned ICC.MPElement (head.offset) ICC._MPElement
    ; _ -> pure {}
    }
 
ICC._MultiProcessElementsType : Grammar {} =
  ICC._MPElement
 
ICC._LutAToBType : Grammar {} =
  do ICC._StartTag "mAB "
     @GetByte
     @GetByte
     @MatchBytes [0,
                  0]
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
 
ICC._LutAB_or_multi : Grammar {} =
  Choose biased
    { {- lutAB -} ICC._LutAToBType
    | {- mpe -} ICC._MultiProcessElementsType
    }
 
ICC._LutBA_or_multi : Grammar {} =
  Choose biased
    { {- lutBA -} ICC._LutAToBType
    | {- mpe -} ICC._MultiProcessElementsType
    }
 
ICC._CurveType : Grammar {} =
  do ICC._StartTag "curv"
     (n : uint 64) <- do (_556 : uint 32) <- Daedalus.BEUInt32
                         pure (_556 as uint 64)
     @Many[n] Daedalus._BEUInt16
 
ICC._ParametricCurveType : Grammar {} =
  do ICC._StartTag "para"
     Daedalus._BEUInt16
     @MatchBytes [0,
                  0]
     @Many[] Daedalus._BEUInt32
 
ICC._CurveOrPCurve : Grammar {} =
  Choose biased
    { {- curve -} ICC._CurveType
    | {- pcurve -} ICC._ParametricCurveType
    }
 
ICC._ASCII7 : Grammar {} =
  do @Many[] do (_560 : uint 8) <- Match (1 .. 255)
                @(_560 AS uint 7)
     Choose biased
       { @Many[ 1 .. ] @Match {0}
       | Fail "Non 0 string terminator"
       }
 
ICC._TextType : Grammar {} =
  do ICC._StartTag "text"
     ICC._ASCII7
 
ICC._UnicodeRecord (s : Stream) : Grammar {} =
  do @Many[2] @GetByte
     @Many[2] @GetByte
     ICC._Positioned [uint 8] s (@Many[] @GetByte)
 
ICC._MultiLocalizedUnicodeType : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "mluc"
     (record_number : uint 32) <- Daedalus.BEUInt32
     ICC._Exactly (uint 32) 12 Daedalus.BEUInt32
     @Many[record_number as uint 64] ICC._UnicodeRecord s
 
ICC._TextDescriptionType : Grammar {} =
  do ICC._StartTag "desc"
     do (_564 : uint 64) <- do (_563 : uint 32) <- Daedalus.BEUInt32
                               pure (_563 as uint 64)
        @Many[_564] @GetByte
     @Many[4] @GetByte
     do (_567 : uint 64) <- do (_566 : uint 32) <- do (_565 : uint 32) <- Daedalus.BEUInt32
                                                      pure (2 * _565)
                               pure (_566 as uint 64)
        @Many[_567] @GetByte
     @Many[2] @GetByte
     Daedalus._BEUInt32
     do (_570 : uint 64) <- do (_569 : uint 32) <- Daedalus.BEUInt32
                               pure (_569 as uint 64)
        @Many[_570] @GetByte
     @Many[] @Match {0}
 
ICC._LaxTextType : Grammar {} =
  Choose biased
    { {- uni -} ICC._MultiLocalizedUnicodeType
    | {- desc -} Daedalus._Only ICC.TextDescriptionType ICC._TextDescriptionType
    | {- text -} Daedalus._Only [uint 7] ICC._TextType
    }
 
ICC._S15Fixed16ArrayType : Grammar {} =
  Daedalus._Only [uint 32] do ICC._StartTag "sf32"
                              @Many[] Daedalus._BEUInt32
 
ICC._XYNumber : Grammar {} =
  do Daedalus._BEUInt32
     Daedalus._BEUInt32
 
ICC._ChromaticityType : Grammar {} =
  do ICC._StartTag "chrm"
     (number_of_device_channels : uint 64) <- do (_575 : uint 16) <- Daedalus.BEUInt16
                                                 pure (_575 as uint 64)
     Daedalus._BEUInt16
     @Many[number_of_device_channels] ICC._XYNumber
 
ICC._SpectralViewingConditionsType : Grammar {} =
  do ICC._StartTag "svcn"
     Daedalus._BEUInt32
     Daedalus._Only [uint 8] (@Many[] @GetByte)
 
ICC._XYZType : Grammar {} =
  do ICC._StartTag "XYZ "
     @Many[] do ($$ : ICC.XYZNumber) <- ICC.XYZNumber
                Choose biased
                  { Daedalus._Guard (0 <= ($$.x))
                  | Fail "x value needs to be positive"
                  }
                Choose biased
                  { Daedalus._Guard (0 <= ($$.y))
                  | Fail "y value needs to be positive"
                  }
                Choose biased
                  { Daedalus._Guard (0 <= ($$.z))
                  | Fail "z value needs to be positive"
                  }
 
ICC._Tag (sig : uint 32) : Grammar {} =
  Choose biased
    { case sig is
        { 0s"desc" -> {- case branch  0s"desc" -} ICC._LaxTextType
        ; 0s"A2B0" -> {- case branch  0s"A2B0" -} ICC._LutAB_or_multi
        ; 0s"A2B1" -> {- case branch  0s"A2B1" -} ICC._LutAB_or_multi
        ; 0s"A2B2" -> {- case branch  0s"A2B2" -} ICC._LutAB_or_multi
        ; 0s"A2B3" -> {- case branch  0s"A2B3" -} ICC._LutAB_or_multi
        ; 0s"A2M0" -> {- case branch  0s"A2M0" -} ICC._MultiProcessElementsType
        ; 0s"B2A0" -> {- case branch  0s"B2A0" -} ICC._LutBA_or_multi
        ; 0s"B2A1" -> {- case branch  0s"B2A1" -} ICC._LutBA_or_multi
        ; 0s"B2A2" -> {- case branch  0s"B2A2" -} ICC._LutBA_or_multi
        ; 0s"B2A3" -> {- case branch  0s"B2A3" -} ICC._LutBA_or_multi
        ; 0s"B2D0" -> {- case branch  0s"B2D0" -} ICC._MultiProcessElementsType
        ; 0s"B2D1" -> {- case branch  0s"B2D1" -} ICC._MultiProcessElementsType
        ; 0s"B2D2" -> {- case branch  0s"B2D2" -} ICC._MultiProcessElementsType
        ; 0s"B2D3" -> {- case branch  0s"B2D3" -} ICC._MultiProcessElementsType
        ; 0s"wtpt" -> {- case branch  0s"wtpt" -} Daedalus._Only [ICC.XYZNumber] ICC._XYZType
        ; 0s"cprt" -> {- case branch  0s"cprt" -} ICC._LaxTextType
        ; 0s"c2sp" -> {- case branch  0s"c2sp" -} ICC._MultiProcessElementsType
        ; 0s"s2cp" -> {- case branch  0s"s2cp" -} ICC._MultiProcessElementsType
        ; 0s"svcn" -> {- case branch  0s"svcn" -} ICC._SpectralViewingConditionsType
        ; 0s"rXYZ" -> {- case branch  0s"rXYZ" -} Daedalus._Only [ICC.XYZNumber] ICC._XYZType
        ; 0s"gXYZ" -> {- case branch  0s"gXYZ" -} Daedalus._Only [ICC.XYZNumber] ICC._XYZType
        ; 0s"bXYZ" -> {- case branch  0s"bXYZ" -} Daedalus._Only [ICC.XYZNumber] ICC._XYZType
        ; 0s"rTRC" -> {- case branch  0s"rTRC" -} ICC._CurveOrPCurve
        ; 0s"gTRC" -> {- case branch  0s"gTRC" -} ICC._CurveOrPCurve
        ; 0s"bTRC" -> {- case branch  0s"bTRC" -} ICC._CurveOrPCurve
        ; 0s"dmdd" -> {- case branch  0s"dmdd" -} ICC._LaxTextType
        ; 0s"dmnd" -> {- case branch  0s"dmnd" -} ICC._LaxTextType
        ; 0s"chrm" -> {- case branch  0s"chrm" -} ICC._ChromaticityType
        ; 0s"chad" -> {- case branch  0s"chad" -} ICC._S15Fixed16ArrayType
        ; _ -> pure {}
        }
    | ICC._InvalidTag
    }
 
ICC._TagTable (s : Stream) : Grammar {} =
  do (_609 : uint 64) <- do (_608 : uint 32) <- Daedalus.BEUInt32
                            pure (_608 as uint 64)
     @Many[_609] do (sig : uint 32) <- Daedalus.BEUInt32
                    ICC._Positioned ICC.Tag s (ICC._Tag sig)
 
ICC._ICC : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._ProfileHeader
     ICC._TagTable s
 
ICC._Response16Number : Grammar {} =
  do Daedalus._BEUInt16
     ICC._Exactly (uint 16) 0 Daedalus.BEUInt16
     Daedalus._BEUInt32
 
ICC._DateTimeType : Grammar {} =
  do ICC._StartTag "dtim"
     ICC._DateTimeNumber
 
ICC._SignatureType : Grammar {} =
  do ICC._StartTag "sig "
     @Many[4] @GetByte
 
ICC._ColorantOrderType : Grammar {} =
  do ICC._StartTag "clro"
     Daedalus._BEUInt32
     @Many[] @GetByte
 
ICC._Colorant : Grammar {} =
  do Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     @Many[3] Daedalus._BEUInt16
 
ICC._ColorantTableType : Grammar {} =
  do ICC._StartTag "clrt"
     (count_of_colorant : uint 64) <- do (_613 : uint 32) <- Daedalus.BEUInt32
                                         pure (_613 as uint 64)
     @Many[count_of_colorant] ICC._Colorant
 
ICC._ResponseCurve (n : uint 64) : Grammar {} =
  do Daedalus._BEUInt32
     (counts : [uint 32]) <- Many[n] Daedalus.BEUInt32
     @Many[n] ICC._XYNumber
     map ((qi : uint 32) in counts)
       (Many[qi as uint 64] ICC.Response16Number)
     pure {}
 
ICC._ResponseCurveSet16Type : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "rcs2"
     (number_of_channels : uint 64) <- do (_615 : uint 16) <- Daedalus.BEUInt16
                                          pure (_615 as uint 64)
     (count : uint 64) <- do (_616 : uint 16) <- Daedalus.BEUInt16
                             pure (_616 as uint 64)
     @Many[count] do (off : uint 64) <- do (_618 : uint 32) <- Daedalus.BEUInt32
                                           pure (_618 as uint 64)
                     Daedalus._LookAhead ICC.ResponseCurve do Daedalus._SetStreamAt off s
                                                              ICC._ResponseCurve number_of_channels
 
ICC._Lut8Type : Grammar {} =
  do ICC._StartTag "mft1"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {0x00}
     @Many[9] Daedalus._BEUInt32
     Daedalus._Bytes (256 * i)
     Daedalus._Bytes ((ICC.exp (uint 64) (uint 64) g i) * o)
     Daedalus._Bytes (256 * o)
 
ICC._Lut16Type : Grammar {} =
  do ICC._StartTag "mft2"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {0x00}
     @Many[9] Daedalus._BEUInt32
     (number_of_input_table_entries : uint 32) <- Daedalus.BEUInt32
     (n : uint 64) <- pure (number_of_input_table_entries as uint 64)
     (number_of_output_table_entries : uint 32) <- Daedalus.BEUInt32
     (m : uint 64) <- pure (number_of_output_table_entries as uint 64)
     Daedalus._Bytes ((256 * n) * i)
     Daedalus._Bytes ((2 * (ICC.exp (uint 64) (uint 64) g i)) * o)
     Daedalus._Bytes ((2 * m) * o)
 
ICC._LutBToAType : Grammar {} =
  do ICC._StartTag "mBA "
     @GetByte
     @GetByte
     @MatchBytes [0,
                  0]
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
 
ICC._MeasurementType : Grammar {} =
  do ICC._StartTag "meas"
     Daedalus._BEUInt32
     ICC._XYZNumber
     Daedalus._BEUInt32
     Daedalus._BEUInt32
     Daedalus._BEUInt32
 
ICC._ColorName (m : uint 64) : Grammar {} =
  do Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     @Many[3] Daedalus._BEUInt16
     @Many[m] Daedalus._BEUInt16
 
ICC._NamedColor2Type : Grammar {} =
  do ICC._StartTag "ncl2"
     Daedalus._BEUInt32
     (count : uint 64) <- do (_623 : uint 32) <- Daedalus.BEUInt32
                             pure (_623 as uint 64)
     (number_of_coords : uint 64) <- do (_624 : uint 32) <- Daedalus.BEUInt32
                                        pure (_624 as uint 64)
     Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     @Many[count] ICC._ColorName number_of_coords
 
ICC._ViewConditionsType : Grammar {} =
  do ICC._StartTag "view"
     ICC._XYZNumber
     ICC._XYZNumber
     Daedalus._BEUInt32
 
ICC._ChunkRelativeTo (s : Stream) (off : uint 64) (sz : uint 64) : Grammar {} =
  do Daedalus._SetStreamAt off s
     Daedalus._Bytes sz
