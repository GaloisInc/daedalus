module Daedalus
 
--- Imports:
 
--- Type defs:
 
--- Rules:
 
Daedalus.joinWords ?a0 ?a1 ?a2 (?a0 + ?a1 = ?a2) (?a1 + ?a0 = ?a2) (_60 : bool) (a : uint ?a0) (b : uint ?a1) : uint ?a2 =
  if _60 then a # b else b # a
 
Daedalus.UInt16 (_61 : bool) : Grammar (uint 16) =
  do (_62 : uint 8) <- GetByte
     (_63 : uint 8) <- GetByte
     pure (Daedalus.joinWords 8 8 16 _61 _62 _63)
 
Daedalus.UInt32 (_64 : bool) : Grammar (uint 32) =
  do (_65 : uint 16) <- Daedalus.UInt16 _64
     (_66 : uint 16) <- Daedalus.UInt16 _64
     pure (Daedalus.joinWords 16 16 32 _64 _65 _66)
 
Daedalus.UInt64 (_67 : bool) : Grammar (uint 64) =
  do (_68 : uint 32) <- Daedalus.UInt32 _67
     (_69 : uint 32) <- Daedalus.UInt32 _67
     pure (Daedalus.joinWords 32 32 64 _67 _68 _69)
 
Daedalus.wordToHalfFloat (w : uint 16) : float =
  let sign = w >> 15 as uint 1 in
  let expo = w >> 10 as uint 5 in
  let mant = w as uint 10 in
  if (expo == 0) then let magic = 126 << 23 in
                      let num = (wordToFloat (magic + (0 # mant))) - (wordToFloat magic) in
                      if (sign == 1) then - num else num else let newExp = if (expo == 31) then 255 else (127 - 15) + (0 # expo) in
                                                              wordToFloat (((sign # newExp) # mant) # 0)
 
Daedalus.HalfFloat (_70 : bool) : Grammar float =
  do (_71 : uint 16) <- Daedalus.UInt16 _70
     pure (Daedalus.wordToHalfFloat _71)
 
Daedalus.Float (_72 : bool) : Grammar float =
  do (_73 : uint 32) <- Daedalus.UInt32 _72
     pure (wordToFloat _73)
 
Daedalus.Double (_74 : bool) : Grammar double =
  do (_75 : uint 64) <- Daedalus.UInt64 _74
     pure (wordToDouble _75)
 
Daedalus.BE16 : Grammar (uint 16) =
  do (_76 : bool) <- pure true
     ($$ : uint 16) <- Daedalus.UInt16 _76
     pure $$
 
Daedalus.BE32 : Grammar (uint 32) =
  do (_78 : bool) <- pure true
     ($$ : uint 32) <- Daedalus.UInt32 _78
     pure $$
 
Daedalus.BE64 : Grammar (uint 64) =
  do (_80 : bool) <- pure true
     ($$ : uint 64) <- Daedalus.UInt64 _80
     pure $$
 
Daedalus.BEHalfFloat : Grammar float =
  do (_82 : bool) <- pure true
     ($$ : float) <- Daedalus.HalfFloat _82
     pure $$
 
Daedalus.BEFloat : Grammar float =
  do (_84 : bool) <- pure true
     ($$ : float) <- Daedalus.Float _84
     pure $$
 
Daedalus.BEDouble : Grammar double =
  do (_86 : bool) <- pure true
     ($$ : double) <- Daedalus.Double _86
     pure $$
 
Daedalus.LE16 : Grammar (uint 16) =
  do (_88 : bool) <- pure false
     ($$ : uint 16) <- Daedalus.UInt16 _88
     pure $$
 
Daedalus.LE32 : Grammar (uint 32) =
  do (_90 : bool) <- pure false
     ($$ : uint 32) <- Daedalus.UInt32 _90
     pure $$
 
Daedalus.LE64 : Grammar (uint 64) =
  do (_92 : bool) <- pure false
     ($$ : uint 64) <- Daedalus.UInt64 _92
     pure $$
 
Daedalus.LEHalfFloat : Grammar float =
  do (_94 : bool) <- pure false
     ($$ : float) <- Daedalus.HalfFloat _94
     pure $$
 
Daedalus.LEFloat : Grammar float =
  do (_96 : bool) <- pure false
     ($$ : float) <- Daedalus.Float _96
     pure $$
 
Daedalus.LEDouble : Grammar double =
  do (_98 : bool) <- pure false
     ($$ : double) <- Daedalus.Double _98
     pure $$
 
Daedalus.Guard (b : bool) : Grammar {} =
  case b is
    { true -> pure {}
    }
 
Daedalus.Only ?a0 (P : Grammar ?a0) : Grammar ?a0 =
  do ($$ : ?a0) <- P
     END
     pure $$
 
Daedalus.SetStreamAt (n : uint 64) (s : Stream) : Grammar {} =
  do (_100 : Stream) <- StreamOff n s
     SetStream _100
 
Daedalus.Skip (n : uint 64) : Grammar {} =
  do (_101 : Stream) <- CurrentStream
     Daedalus.SetStreamAt n _101
 
Daedalus._SetStreamAt (n : uint 64) (s : Stream) : Grammar {} =
  do (_100 : Stream) <- StreamOff n s
     SetStream _100
 
Daedalus.Chunk ?a0 (n : uint 64) (P : Grammar ?a0) : Grammar ?a0 =
  do (s : Stream) <- CurrentStream
     do (_102 : Stream) <- StreamLen n s
        SetStream _102
     ($$ : ?a0) <- P
     Daedalus._SetStreamAt n s
     pure $$
 
Daedalus.Bytes (n : uint 64) : Grammar Stream =
  Daedalus.Chunk Stream n CurrentStream
 
Daedalus.LookAhead ?a0 (P : Grammar ?a0) : Grammar ?a0 =
  do (s : Stream) <- CurrentStream
     ($$ : ?a0) <- P
     SetStream s
     pure $$
 
Daedalus._UInt16 : Grammar {} =
  do @GetByte
     @GetByte
 
Daedalus._UInt32 : Grammar {} =
  do Daedalus._UInt16
     Daedalus._UInt16
 
Daedalus._UInt64 : Grammar {} =
  do Daedalus._UInt32
     Daedalus._UInt32
 
Daedalus._HalfFloat : Grammar {} =
  Daedalus._UInt16
 
Daedalus._Float : Grammar {} =
  Daedalus._UInt32
 
Daedalus._Double : Grammar {} =
  Daedalus._UInt64
 
Daedalus._BE16 : Grammar {} =
  Daedalus._UInt16
 
Daedalus._BE32 : Grammar {} =
  Daedalus._UInt32
 
Daedalus._BE64 : Grammar {} =
  Daedalus._UInt64
 
Daedalus._BEHalfFloat : Grammar {} =
  Daedalus._HalfFloat
 
Daedalus._BEFloat : Grammar {} =
  Daedalus._Float
 
Daedalus._BEDouble : Grammar {} =
  Daedalus._Double
 
Daedalus._LE16 : Grammar {} =
  Daedalus._UInt16
 
Daedalus._LE32 : Grammar {} =
  Daedalus._UInt32
 
Daedalus._LE64 : Grammar {} =
  Daedalus._UInt64
 
Daedalus._LEHalfFloat : Grammar {} =
  Daedalus._HalfFloat
 
Daedalus._LEFloat : Grammar {} =
  Daedalus._Float
 
Daedalus._LEDouble : Grammar {} =
  Daedalus._Double
 
Daedalus._Guard (b : bool) : Grammar {} =
  case b is
    { true -> pure {}
    }
 
Daedalus._Only ?a0 (_P : Grammar {}) : Grammar {} =
  do _P
     END
 
Daedalus._Skip (n : uint 64) : Grammar {} =
  do (_101 : Stream) <- CurrentStream
     Daedalus._SetStreamAt n _101
 
Daedalus._Chunk ?a0 (n : uint 64) (_P : Grammar {}) : Grammar {} =
  do (s : Stream) <- CurrentStream
     do (_102 : Stream) <- StreamLen n s
        SetStream _102
     _P
     Daedalus._SetStreamAt n s
 
Daedalus._Bytes (n : uint 64) : Grammar {} =
  Daedalus._Chunk Stream n (pure {})
 
Daedalus._LookAhead ?a0 (_P : Grammar {}) : Grammar {} =
  do (s : Stream) <- CurrentStream
     _P
     SetStream s
module T074
 
--- Imports:
import Daedalus
 
--- Type defs:
type T074.Check = { value: float
                  ; isNan: bool
                  ; isNZ: bool
                  ; isInf: bool
                  ; isDen: bool
                  }
 
type T074.Main = { ex1: T074.Check
                 ; ex2: T074.Check
                 }
 
--- Rules:
 
T074.Check (xs : uint 32) : Grammar T074.Check =
  do (value : float) <- pure (wordToFloat xs)
     (isNan : bool) <- pure (isNaN value)
     (isNZ : bool) <- pure (isNegativeZero value)
     (isInf : bool) <- pure (isInfinit value)
     (isDen : bool) <- pure (isDenormalized value)
     pure {value = value,
           isNan = isNan,
           isNZ = isNZ,
           isInf = isInf,
           isDen = isDen}
 
T074.Main : Grammar T074.Main =
  do (ex1 : T074.Check) <- T074.Check 0
     (ex2 : T074.Check) <- T074.Check (1 # 0)
     pure {ex1 = ex1,
           ex2 = ex2}
 
T074._Check : Grammar {} =
  pure {}
 
T074._Main : Grammar {} =
  do T074._Check
     T074._Check
