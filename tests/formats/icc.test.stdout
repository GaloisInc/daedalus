module Daedalus
 
--- Imports:
 
--- Type defs:
 
--- Rules:
 
Daedalus.joinWords ?a0 ?a1 ?a2 (?a0 + ?a1 = ?a2) (?a1 + ?a0 = ?a2) (_330 : bool) (a : uint ?a0) (b : uint ?a1) : uint ?a2 =
  if _330 then a # b else b # a
 
Daedalus.UInt16 (_331 : bool) : Grammar (uint 16) =
  do (_332 : uint 8) <- GetByte
     (_333 : uint 8) <- GetByte
     pure (Daedalus.joinWords 8 8 16 _331 _332 _333)
 
Daedalus.UInt32 (_334 : bool) : Grammar (uint 32) =
  do (_335 : uint 16) <- Daedalus.UInt16 _334
     (_336 : uint 16) <- Daedalus.UInt16 _334
     pure (Daedalus.joinWords 16 16 32 _334 _335 _336)
 
Daedalus.UInt64 (_337 : bool) : Grammar (uint 64) =
  do (_338 : uint 32) <- Daedalus.UInt32 _337
     (_339 : uint 32) <- Daedalus.UInt32 _337
     pure (Daedalus.joinWords 32 32 64 _337 _338 _339)
 
Daedalus.wordToHalfFloat (w : uint 16) : float =
  let sign = w >> 15 as uint 1 in
  let expo = w >> 10 as uint 5 in
  let mant = w as uint 10 in
  if (expo == 0) then let magic = 126 << 23 in
                      let num = (wordToFloat (magic + (0 # mant))) - (wordToFloat magic) in
                      if (sign == 1) then - num else num else let newExp = if (expo == 31) then 255 else (127 - 15) + (0 # expo) in
                                                              wordToFloat (((sign # newExp) # mant) # 0)
 
Daedalus.HalfFloat (_340 : bool) : Grammar float =
  do (_341 : uint 16) <- Daedalus.UInt16 _340
     pure (Daedalus.wordToHalfFloat _341)
 
Daedalus.Float (_342 : bool) : Grammar float =
  do (_343 : uint 32) <- Daedalus.UInt32 _342
     pure (wordToFloat _343)
 
Daedalus.Double (_344 : bool) : Grammar double =
  do (_345 : uint 64) <- Daedalus.UInt64 _344
     pure (wordToDouble _345)
 
Daedalus.BE16 : Grammar (uint 16) =
  do (_346 : bool) <- pure true
     ($$ : uint 16) <- Daedalus.UInt16 _346
     pure $$
 
Daedalus.BE32 : Grammar (uint 32) =
  do (_348 : bool) <- pure true
     ($$ : uint 32) <- Daedalus.UInt32 _348
     pure $$
 
Daedalus.BE64 : Grammar (uint 64) =
  do (_350 : bool) <- pure true
     ($$ : uint 64) <- Daedalus.UInt64 _350
     pure $$
 
Daedalus.BEHalfFloat : Grammar float =
  do (_352 : bool) <- pure true
     ($$ : float) <- Daedalus.HalfFloat _352
     pure $$
 
Daedalus.BEFloat : Grammar float =
  do (_354 : bool) <- pure true
     ($$ : float) <- Daedalus.Float _354
     pure $$
 
Daedalus.BEDouble : Grammar double =
  do (_356 : bool) <- pure true
     ($$ : double) <- Daedalus.Double _356
     pure $$
 
Daedalus.LE16 : Grammar (uint 16) =
  do (_358 : bool) <- pure false
     ($$ : uint 16) <- Daedalus.UInt16 _358
     pure $$
 
Daedalus.LE32 : Grammar (uint 32) =
  do (_360 : bool) <- pure false
     ($$ : uint 32) <- Daedalus.UInt32 _360
     pure $$
 
Daedalus.LE64 : Grammar (uint 64) =
  do (_362 : bool) <- pure false
     ($$ : uint 64) <- Daedalus.UInt64 _362
     pure $$
 
Daedalus.LEHalfFloat : Grammar float =
  do (_364 : bool) <- pure false
     ($$ : float) <- Daedalus.HalfFloat _364
     pure $$
 
Daedalus.LEFloat : Grammar float =
  do (_366 : bool) <- pure false
     ($$ : float) <- Daedalus.Float _366
     pure $$
 
Daedalus.LEDouble : Grammar double =
  do (_368 : bool) <- pure false
     ($$ : double) <- Daedalus.Double _368
     pure $$
 
Daedalus.Guard (b : bool) : Grammar {} =
  case b is
    { true -> pure {}
    }
 
Daedalus.Only ?a0 (P : Grammar ?a0) : Grammar ?a0 =
  do ($$ : ?a0) <- P
     END
     pure $$
 
Daedalus.SetStreamAt (n : uint 64) (s : Stream) : Grammar {} =
  do (_370 : Stream) <- StreamOff n s
     SetStream _370
 
Daedalus.Skip (n : uint 64) : Grammar {} =
  do (_371 : Stream) <- CurrentStream
     Daedalus.SetStreamAt n _371
 
Daedalus._SetStreamAt (n : uint 64) (s : Stream) : Grammar {} =
  do (_370 : Stream) <- StreamOff n s
     SetStream _370
 
Daedalus.Chunk ?a0 (n : uint 64) (P : Grammar ?a0) : Grammar ?a0 =
  do (s : Stream) <- CurrentStream
     do (_372 : Stream) <- StreamLen n s
        SetStream _372
     ($$ : ?a0) <- P
     Daedalus._SetStreamAt n s
     pure $$
 
Daedalus.Bytes (n : uint 64) : Grammar Stream =
  Daedalus.Chunk Stream n CurrentStream
 
Daedalus.LookAhead ?a0 (P : Grammar ?a0) : Grammar ?a0 =
  do (s : Stream) <- CurrentStream
     ($$ : ?a0) <- P
     SetStream s
     pure $$
 
Daedalus._UInt16 : Grammar {} =
  do @GetByte
     @GetByte
 
Daedalus._UInt32 : Grammar {} =
  do Daedalus._UInt16
     Daedalus._UInt16
 
Daedalus._UInt64 : Grammar {} =
  do Daedalus._UInt32
     Daedalus._UInt32
 
Daedalus._HalfFloat : Grammar {} =
  Daedalus._UInt16
 
Daedalus._Float : Grammar {} =
  Daedalus._UInt32
 
Daedalus._Double : Grammar {} =
  Daedalus._UInt64
 
Daedalus._BE16 : Grammar {} =
  Daedalus._UInt16
 
Daedalus._BE32 : Grammar {} =
  Daedalus._UInt32
 
Daedalus._BE64 : Grammar {} =
  Daedalus._UInt64
 
Daedalus._BEHalfFloat : Grammar {} =
  Daedalus._HalfFloat
 
Daedalus._BEFloat : Grammar {} =
  Daedalus._Float
 
Daedalus._BEDouble : Grammar {} =
  Daedalus._Double
 
Daedalus._LE16 : Grammar {} =
  Daedalus._UInt16
 
Daedalus._LE32 : Grammar {} =
  Daedalus._UInt32
 
Daedalus._LE64 : Grammar {} =
  Daedalus._UInt64
 
Daedalus._LEHalfFloat : Grammar {} =
  Daedalus._HalfFloat
 
Daedalus._LEFloat : Grammar {} =
  Daedalus._Float
 
Daedalus._LEDouble : Grammar {} =
  Daedalus._Double
 
Daedalus._Guard (b : bool) : Grammar {} =
  case b is
    { true -> pure {}
    }
 
Daedalus._Only ?a0 (_P : Grammar {}) : Grammar {} =
  do _P
     END
 
Daedalus._Skip (n : uint 64) : Grammar {} =
  do (_371 : Stream) <- CurrentStream
     Daedalus._SetStreamAt n _371
 
Daedalus._Chunk ?a0 (n : uint 64) (_P : Grammar {}) : Grammar {} =
  do (s : Stream) <- CurrentStream
     do (_372 : Stream) <- StreamLen n s
        SetStream _372
     _P
     Daedalus._SetStreamAt n s
 
Daedalus._Bytes (n : uint 64) : Grammar {} =
  Daedalus._Chunk Stream n (pure {})
 
Daedalus._LookAhead ?a0 (_P : Grammar {}) : Grammar {} =
  do (s : Stream) <- CurrentStream
     _P
     SetStream s
module ICC
 
--- Imports:
import Daedalus
 
--- Type defs:
type ICC.FunOp83 = { tag: [uint 8]
                   ; param: uint 32
                   }
 
type ICC.VersionField = { major: uint 8
                        ; minor: uint 4
                        ; bugfix: uint 4
                        }
 
type ICC.ProfileClass = Choose { multiplex_vis: {}
                               ; multiplex_link: {}
                               ; multiplex_id: {}
                               ; color_encoding_space: {}
                               ; named_color_profile: {}
                               ; abstract_profile: {}
                               ; color_space_profile: {}
                               ; device_link_profile: {}
                               ; output_device_profile: {}
                               ; display_device_profile: {}
                               ; input_device_profile: {}
                               }
 
type ICC.DataColorSpace = Choose { n_channel: uint 16
                                 ; none: {}
                                 ; fifteen_colour: {}
                                 ; fourteen_colour: {}
                                 ; thirteen_colour: {}
                                 ; twelve_colour: {}
                                 ; eleven_colour: {}
                                 ; ten_colour: {}
                                 ; nine_colour: {}
                                 ; eight_colour: {}
                                 ; seven_colour: {}
                                 ; six_colour: {}
                                 ; five_colour: {}
                                 ; four_colour: {}
                                 ; three_colour: {}
                                 ; two_colour: {}
                                 ; cmy: {}
                                 ; cmyk: {}
                                 ; hls: {}
                                 ; hsv: {}
                                 ; gray: {}
                                 ; rgb: {}
                                 ; lms: {}
                                 ; cieyxy: {}
                                 ; ycbcr: {}
                                 ; cieluv: {}
                                 ; cielab_or_pcslab: {}
                                 ; nciexyz_or_pcsxyz: {}
                                 }
 
type ICC.PrimaryPlatform = Choose { none: {}
                                  ; sun_microsystems: {}
                                  ; silicon_graphics_inc: {}
                                  ; microsoft_corporation: {}
                                  ; apple_computer_inc: {}
                                  }
 
type ICC.RenderingIntent = Choose { icc_absolute_colorimetric: {}
                                  ; saturation: {}
                                  ; media_relative_colorimetric: {}
                                  ; perceptual: {}
                                  }
 
type ICC.XYZNumber = { x: uint 32
                     ; y: uint 32
                     ; z: uint 32
                     }
 
type ICC.DateTimeNumber = { year: uint 16
                          ; month: uint 16
                          ; day: uint 16
                          ; hour: uint 16
                          ; minute: uint 16
                          ; second: uint 16
                          }
 
type ICC.ProfileHeader = { size: uint 32
                         ; preferred_cmm_type: [uint 8]
                         ; version: ICC.VersionField
                         ; devce_class: ICC.ProfileClass
                         ; color_space: ICC.DataColorSpace
                         ; pcs: ICC.DataColorSpace
                         ; creation_date_time: ICC.DateTimeNumber
                         ; primary_platform: ICC.PrimaryPlatform
                         ; profile_flags: uint 32
                         ; device_manufacturer: [uint 8]
                         ; device_model: [uint 8]
                         ; device_attributes: uint 64
                         ; rendering_intent: ICC.RenderingIntent
                         ; illuminant: ICC.XYZNumber
                         ; creator: [uint 8]
                         ; identifier: [uint 8]
                         ; reserved_data: [uint 8]
                         }
 
type ICC.LutAToBType = { number_of_input_channels: uint 8
                       ; number_of_output_channels: uint 8
                       ; offset_first_B_curve: uint 32
                       ; offset_to_matrix: uint 32
                       ; offset_to_first_M_curve: uint 32
                       ; offset_to_CLUT: uint 32
                       ; offset_to_first_A_curve: uint 32
                       ; data: Stream
                       }
 
type ICC.OpParams = { s: uint 16
                    ; t: uint 16
                    }
 
type ICC.FunOp = Choose { unknown: ICC.FunOp83
                        ; opDflt: uint 64
                        ; opCase: uint 64
                        ; opSel: {}
                        ; opElse: uint 64
                        ; opIf: uint 64
                        ; opTXYZ: uint 16
                        ; opTLab: uint 16
                        ; opVOr: uint 16
                        ; opVAnd: uint 16
                        ; opVMax: uint 16
                        ; opVMin: uint 16
                        ; opGT: uint 16
                        ; opGE: uint 16
                        ; opNer: uint 16
                        ; opEQ: uint 16
                        ; opLE: uint 16
                        ; opLT: uint 16
                        ; opRNum: uint 16
                        ; opPToc: uint 16
                        ; opCTop: uint 16
                        ; opATn2: uint 16
                        ; opATan: uint 16
                        ; opACos: uint 16
                        ; opASin: uint 16
                        ; opTan: uint 16
                        ; opCos: uint 16
                        ; opSin: uint 16
                        ; opLn: uint 16
                        ; opLog: uint 16
                        ; opExp: uint 16
                        ; opSign: uint 16
                        ; opTrnc: uint 16
                        ; opCeil: uint 16
                        ; opFlor: uint 16
                        ; opRond: uint 16
                        ; opNeg: uint 16
                        ; opAbs: uint 16
                        ; opCbrt: uint 16
                        ; opCb: uint 16
                        ; opSqrt: uint 16
                        ; opSq: uint 16
                        ; opSDiv: uint 16
                        ; opSMul: uint 16
                        ; opSSub: uint 16
                        ; opSAdd: uint 16
                        ; opGamma: uint 16
                        ; opPow: uint 16
                        ; opMod: uint 16
                        ; opDiv: uint 16
                        ; opMul: uint 16
                        ; opSub: uint 16
                        ; opAdd: uint 16
                        ; opNAN: uint 16
                        ; opNegInf: uint 16
                        ; opPosInf: uint 16
                        ; opPi: uint 16
                        ; or: uint 16
                        ; and: uint 16
                        ; max: uint 16
                        ; min: uint 16
                        ; prod: uint 16
                        ; sum: uint 16
                        ; tran: ICC.OpParams
                        ; solv: ICC.OpParams
                        ; pop: ICC.OpParams
                        ; flip: ICC.OpParams
                        ; posd: ICC.OpParams
                        ; rotr: ICC.OpParams
                        ; rotl: ICC.OpParams
                        ; copy: ICC.OpParams
                        ; elem: uint 32
                        ; tint: uint 32
                        ; calc: uint 32
                        ; clut: uint 32
                        ; mtx: uint 32
                        ; curv: uint 32
                        ; opEnv: uint 32
                        ; opTSave: ICC.OpParams
                        ; opTPut: ICC.OpParams
                        ; opTGet: ICC.OpParams
                        ; opOut: ICC.OpParams
                        ; opIn: ICC.OpParams
                        ; data: float
                        }
 
type ICC.SingleSampledCurve = { n: uint 32
                              ; f: uint 32
                              ; l: uint 32
                              ; e: uint 16
                              ; ty: uint 16
                              }
 
type ICC.FunParams_g_a_b_c = { g: float
                             ; a: float
                             ; b: float
                             ; c: float
                             }
 
type ICC.FunParams_g_a_b_c_d = { g: float
                               ; a: float
                               ; b: float
                               ; c: float
                               ; d: float
                               }
 
type ICC.FunParams_a_b_c_d_e = { a: float
                               ; b: float
                               ; c: float
                               ; d: float
                               ; e: float
                               }
 
type ICC.FormualCurveSegment = Choose { fun3: ICC.FunParams_g_a_b_c
                                      ; fun2: ICC.FunParams_a_b_c_d_e
                                      ; fun1: ICC.FunParams_g_a_b_c_d
                                      ; fun0: ICC.FunParams_g_a_b_c
                                      }
 
type ICC.CurveSegment = Choose { samf: [float]
                               ; parf: ICC.FormualCurveSegment
                               }
 
type ICC.SegmentedCurve = { breakPoints: [float]
                          ; segements: [ICC.CurveSegment]
                          }
 
type ICC.Curve = Choose { unknown: [uint 8]
                        ; curf: ICC.SegmentedCurve
                        ; sngf: ICC.SingleSampledCurve
                        }
 
type ICC.Matrix = { matrix: [[float]]
                  ; vector: [float]
                  }
 
rec
  type ICC.MPElement = Choose { unknown: [uint 8]
                              ; matf: ICC.Matrix
                              ; cvst: [ICC.Curve]
                              ; calc: ICC.CalcElement
                              }
   
  type ICC.CalcElement = { inputs: uint 64
                         ; outputs: uint 64
                         ; main: [ICC.FunOp]
                         ; subElements: [ICC.MPElement]
                         }
 
type ICC.MultiProcessElementsType = { number_of_input_channels: uint 16
                                    ; number_of_output_channels: uint 16
                                    ; number_of_processing_elements: uint 32
                                    ; elements: [ICC.MPElement]
                                    }
 
type ICC.LutAB_or_multi = Choose { lutAB: ICC.LutAToBType
                                 ; mpe: ICC.MultiProcessElementsType
                                 }
 
type ICC.LutBA_or_multi = Choose { lutBA: ICC.LutAToBType
                                 ; mpe: ICC.MultiProcessElementsType
                                 }
 
type ICC.UnicodeRecord = { language: [uint 8]
                         ; country: [uint 8]
                         ; data: [uint 8]
                         }
 
type ICC.SpectralViewingConditionsType = { colometric_observer: uint 32
                                         }
 
type ICC.Tag = Choose { unknown: [uint 8]
                      ; svcn: ICC.SpectralViewingConditionsType
                      ; s2sp: ICC.MultiProcessElementsType
                      ; c2sp: ICC.MultiProcessElementsType
                      ; cprt: [ICC.UnicodeRecord]
                      ; wtpt: [ICC.XYZNumber]
                      ; B2D3: ICC.MultiProcessElementsType
                      ; B2D2: ICC.MultiProcessElementsType
                      ; B2D1: ICC.MultiProcessElementsType
                      ; B2D0: ICC.MultiProcessElementsType
                      ; B2A3: ICC.LutBA_or_multi
                      ; B2A2: ICC.LutBA_or_multi
                      ; B2A1: ICC.LutBA_or_multi
                      ; B2A0: ICC.LutBA_or_multi
                      ; A2Mo: ICC.MultiProcessElementsType
                      ; A2B3: ICC.LutAB_or_multi
                      ; A2B2: ICC.LutAB_or_multi
                      ; A2B1: ICC.LutAB_or_multi
                      ; A2B0: ICC.LutAB_or_multi
                      ; desc: [ICC.UnicodeRecord]
                      }
 
type ICC.Main = { profileHeader: ICC.ProfileHeader
                ; tags: [ICC.Tag]
                }
 
type ICC.TagEntry = { tag_signature: uint 32
                    ; offset_to_data_element: uint 64
                    ; size_of_data_element: uint 64
                    }
 
type ICC.XYNumber = { x: uint 32
                    ; y: uint 32
                    }
 
type ICC.PositionNumber = { offset: uint 64
                          ; size: uint 64
                          }
 
type ICC.Response16Number = { device: uint 16
                            ; measurement: uint 32
                            }
 
type ICC.Lut8Type = { number_of_input_channels: uint 8
                    ; number_of_output_channels: uint 8
                    ; number_of_clut_grid_points: uint 8
                    ; encoded_e_parameters: [sint 32]
                    ; input_tables: Stream
                    ; clut_values: Stream
                    ; output_tables: Stream
                    }
 
type ICC.Lut16Type = { number_of_input_channels: uint 8
                     ; number_of_output_channels: uint 8
                     ; number_of_clut_grid_points: uint 8
                     ; encoded_e_parameters: [sint 32]
                     ; number_of_input_table_entries: uint 32
                     ; number_of_output_table_entries: uint 32
                     ; input_tables: Stream
                     ; clut_values: Stream
                     ; output_tables: Stream
                     }
 
type ICC.LutBToAType = { number_of_input_channels: uint 8
                       ; number_of_output_channels: uint 8
                       ; offset_first_B_curve: uint 32
                       ; offset_to_matrix: uint 32
                       ; offset_to_first_M_curve: uint 32
                       ; offset_to_CLUT: uint 32
                       ; offset_to_first_A_curve: uint 32
                       ; data: Stream
                       }
 
type ICC.Lut_8_16_AB_BA = Choose { lut16: ICC.Lut16Type
                                 ; lut8: ICC.Lut8Type
                                 ; lutAB: ICC.LutAToBType
                                 ; lutBA: ICC.LutBToAType
                                 }
 
type ICC.Lut_8_16_AB = Choose { lut16: ICC.Lut16Type
                              ; lut8: ICC.Lut8Type
                              ; lutAB: ICC.LutAToBType
                              }
 
type ICC.Lut_8_16_BA = Choose { lut16: ICC.Lut16Type
                              ; lut8: ICC.Lut8Type
                              ; lutBA: ICC.LutBToAType
                              }
 
type ICC.ParametricCurveType = { function: uint 16
                               ; parameters: [uint 32]
                               }
 
type ICC.SomeCurve = Choose { curve: [uint 16]
                            ; parametric_curve: ICC.ParametricCurveType
                            }
 
type ICC.ChromaticityType = { phosphor_or_colorant: uint 16
                            ; cie_coords: [ICC.XYNumber]
                            }
 
type ICC.Colorant = { name: [uint 7]
                    ; pcs: [uint 16]
                    }
 
type ICC.ResponseCurve = { measurement_unit: uint 32
                         ; pcxyzs: [ICC.XYNumber]
                         ; response_arrays: [[ICC.Response16Number]]
                         }
 
type ICC.MeasurementType = { standard_observer: uint 32
                           ; nCIEXYZ: ICC.XYZNumber
                           ; geometry: uint 32
                           ; flare: uint 32
                           ; illuminant: uint 32
                           }
 
type ICC.ColorName = { name_root: [uint 7]
                     ; pcs_coords: [uint 16]
                     ; device_coords: [uint 16]
                     }
 
type ICC.NamedColor2Type = { vendor_specific: uint 32
                           ; prefix: [uint 7]
                           ; suffix: [uint 7]
                           ; names: [ICC.ColorName]
                           }
 
type ICC.ViewConditionsType = { illuminantXYZ: ICC.XYZNumber
                              ; surroundXYZ: ICC.XYZNumber
                              ; illuminant: uint 32
                              }
 
type ICC.TagStructType = { struct_type_id: [uint 8]
                         }
 
--- Rules:
 
ICC.VersionField : Grammar ICC.VersionField =
  do (major : uint 8) <- GetByte
     (min_bf : uint 8) <- GetByte
     (minor : uint 4) <- pure (min_bf >> 4 as uint 4)
     (bugfix : uint 4) <- pure (min_bf as uint 4)
     @MatchBytes [0,
                  0]
     pure {major = major,
           minor = minor,
           bugfix = bugfix}
 
ICC.ProfileClass : Grammar ICC.ProfileClass =
  do (_373 : uint 32) <- Daedalus.BE32
     case _373 is
       { 1935896178 -> pure {input_device_profile: {}}
       ; 1835955314 -> pure {display_device_profile: {}}
       ; 1886549106 -> pure {output_device_profile: {}}
       ; 1818848875 -> pure {device_link_profile: {}}
       ; 1936744803 -> pure {color_space_profile: {}}
       ; 1633842036 -> pure {abstract_profile: {}}
       ; 1852662636 -> pure {named_color_profile: {}}
       ; 1667591779 -> pure {color_encoding_space: {}}
       ; 1835623456 -> pure {multiplex_id: {}}
       ; 1835822699 -> pure {multiplex_link: {}}
       ; 1836476787 -> pure {multiplex_vis: {}}
       }
 
ICC.DataColorSpace : Grammar ICC.DataColorSpace =
  do (tag : uint 32) <- Daedalus.BE32
     ($$ : ICC.DataColorSpace) <- case tag is
                                    { 1482250784 -> pure {nciexyz_or_pcsxyz: {}}
                                    ; 1281450528 -> pure {cielab_or_pcslab: {}}
                                    ; 1282766368 -> pure {cieluv: {}}
                                    ; 1499685490 -> pure {ycbcr: {}}
                                    ; 1501067552 -> pure {cieyxy: {}}
                                    ; 1280135968 -> pure {lms: {}}
                                    ; 1380401696 -> pure {rgb: {}}
                                    ; 1196573017 -> pure {gray: {}}
                                    ; 1213421088 -> pure {hsv: {}}
                                    ; 1212961568 -> pure {hls: {}}
                                    ; 1129142603 -> pure {cmyk: {}}
                                    ; 1129142560 -> pure {cmy: {}}
                                    ; 843271250 -> pure {two_colour: {}}
                                    ; 860048466 -> pure {three_colour: {}}
                                    ; 876825682 -> pure {four_colour: {}}
                                    ; 893602898 -> pure {five_colour: {}}
                                    ; 910380114 -> pure {six_colour: {}}
                                    ; 927157330 -> pure {seven_colour: {}}
                                    ; 943934546 -> pure {eight_colour: {}}
                                    ; 960711762 -> pure {nine_colour: {}}
                                    ; 1094929490 -> pure {ten_colour: {}}
                                    ; 1111706706 -> pure {eleven_colour: {}}
                                    ; 1128483922 -> pure {twelve_colour: {}}
                                    ; 1145261138 -> pure {thirteen_colour: {}}
                                    ; 1162038354 -> pure {fourteen_colour: {}}
                                    ; 1178815570 -> pure {fifteen_colour: {}}
                                    ; 0 -> pure {none: {}}
                                    ; _ -> do Daedalus._Guard ((tag >> 16) == 28261)
                                              ($$ : ICC.DataColorSpace) <- pure {n_channel: (tag as uint 16)}
                                              pure $$
                                    }
     pure $$
 
ICC.PrimaryPlatform : Grammar ICC.PrimaryPlatform =
  do (_376 : uint 32) <- Daedalus.BE32
     case _376 is
       { 1095782476 -> pure {apple_computer_inc: {}}
       ; 1297303124 -> pure {microsoft_corporation: {}}
       ; 1397180704 -> pure {silicon_graphics_inc: {}}
       ; 1398099543 -> pure {sun_microsystems: {}}
       ; 0 -> pure {none: {}}
       }
 
ICC.RenderingIntent : Grammar ICC.RenderingIntent =
  do (_377 : uint 32) <- Daedalus.BE32
     case _377 is
       { 0 -> pure {perceptual: {}}
       ; 1 -> pure {media_relative_colorimetric: {}}
       ; 2 -> pure {saturation: {}}
       ; 3 -> pure {icc_absolute_colorimetric: {}}
       }
 
ICC.XYZNumber : Grammar ICC.XYZNumber =
  do (x : uint 32) <- Daedalus.BE32
     (y : uint 32) <- Daedalus.BE32
     (z : uint 32) <- Daedalus.BE32
     pure {x = x,
           y = y,
           z = z}
 
ICC.DateTimeNumber : Grammar ICC.DateTimeNumber =
  do (year : uint 16) <- Daedalus.BE16
     (month : uint 16) <- Daedalus.BE16
     (day : uint 16) <- Daedalus.BE16
     (hour : uint 16) <- Daedalus.BE16
     (minute : uint 16) <- Daedalus.BE16
     (second : uint 16) <- Daedalus.BE16
     pure {year = year,
           month = month,
           day = day,
           hour = hour,
           minute = minute,
           second = second}
 
ICC.ProfileHeader : Grammar ICC.ProfileHeader =
  do (size : uint 32) <- Daedalus.BE32
     (preferred_cmm_type : [uint 8]) <- Many[4] GetByte
     (version : ICC.VersionField) <- ICC.VersionField
     (devce_class : ICC.ProfileClass) <- ICC.ProfileClass
     (color_space : ICC.DataColorSpace) <- ICC.DataColorSpace
     (pcs : ICC.DataColorSpace) <- ICC.DataColorSpace
     (creation_date_time : ICC.DateTimeNumber) <- ICC.DateTimeNumber
     @MatchBytes "acsp"
     (primary_platform : ICC.PrimaryPlatform) <- ICC.PrimaryPlatform
     (profile_flags : uint 32) <- Daedalus.BE32
     (device_manufacturer : [uint 8]) <- Many[4] GetByte
     (device_model : [uint 8]) <- Many[4] GetByte
     (device_attributes : uint 64) <- Daedalus.BE64
     (rendering_intent : ICC.RenderingIntent) <- ICC.RenderingIntent
     (illuminant : ICC.XYZNumber) <- ICC.XYZNumber
     (creator : [uint 8]) <- Many[4] GetByte
     (identifier : [uint 8]) <- Many[16] GetByte
     (reserved_data : [uint 8]) <- Many[28] GetByte
     pure {size = size,
           preferred_cmm_type = preferred_cmm_type,
           version = version,
           devce_class = devce_class,
           color_space = color_space,
           pcs = pcs,
           creation_date_time = creation_date_time,
           primary_platform = primary_platform,
           profile_flags = profile_flags,
           device_manufacturer = device_manufacturer,
           device_model = device_model,
           device_attributes = device_attributes,
           rendering_intent = rendering_intent,
           illuminant = illuminant,
           creator = creator,
           identifier = identifier,
           reserved_data = reserved_data}
 
ICC.TagEntry : Grammar ICC.TagEntry =
  do (tag_signature : uint 32) <- Daedalus.BE32
     (offset_to_data_element : uint 64) <- do (_378 : uint 32) <- Daedalus.BE32
                                              pure (_378 as uint 64)
     (size_of_data_element : uint 64) <- do (_379 : uint 32) <- Daedalus.BE32
                                            pure (_379 as uint 64)
     pure {tag_signature = tag_signature,
           offset_to_data_element = offset_to_data_element,
           size_of_data_element = size_of_data_element}
 
ICC.TagTable : Grammar [ICC.TagEntry] =
  do (_381 : uint 64) <- do (_380 : uint 32) <- Daedalus.BE32
                            pure (_380 as uint 64)
     Many[_381] ICC.TagEntry
 
ICC._StartTag (x : [uint 8]) : Grammar {} =
  do @MatchBytes x
     @MatchBytes [0,
                  0,
                  0,
                  0]
 
ICC.LutAToBType : Grammar ICC.LutAToBType =
  do ICC._StartTag "mAB "
     (number_of_input_channels : uint 8) <- GetByte
     (number_of_output_channels : uint 8) <- GetByte
     @MatchBytes [0,
                  0]
     (offset_first_B_curve : uint 32) <- Daedalus.BE32
     (offset_to_matrix : uint 32) <- Daedalus.BE32
     (offset_to_first_M_curve : uint 32) <- Daedalus.BE32
     (offset_to_CLUT : uint 32) <- Daedalus.BE32
     (offset_to_first_A_curve : uint 32) <- Daedalus.BE32
     (data : Stream) <- CurrentStream
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           offset_first_B_curve = offset_first_B_curve,
           offset_to_matrix = offset_to_matrix,
           offset_to_first_M_curve = offset_to_first_M_curve,
           offset_to_CLUT = offset_to_CLUT,
           offset_to_first_A_curve = offset_to_first_A_curve,
           data = data}
 
ICC.Exactly ?a0 (x : ?a0) (P : Grammar ?a0) : Grammar {} =
  Choose biased
    { do (_384 : bool) <- do (_383 : ?a0) <- P
                             pure (_383 == x)
         Daedalus.Guard _384
    | Fail "Unexpected field value"
    }
 
ICC.NoParams : Grammar {} =
  ICC.Exactly (uint 32) 0 Daedalus.BE32
 
ICC._Exactly ?a0 (x : ?a0) (P : Grammar ?a0) : Grammar {} =
  Choose biased
    { do (_384 : bool) <- do (_383 : ?a0) <- P
                             pure (_383 == x)
         Daedalus._Guard _384
    | Fail "Unexpected field value"
    }
 
ICC.OpParam : Grammar (uint 16) =
  do ($$ : uint 16) <- Daedalus.BE16
     ICC._Exactly (uint 16) 0 Daedalus.BE16
     pure $$
 
ICC.OpParams : Grammar ICC.OpParams =
  do (s : uint 16) <- Daedalus.BE16
     (t : uint 16) <- Daedalus.BE16
     pure {s = s,
           t = t}
 
ICC.explode32 (sig : uint 32) : [uint 8] =
  [sig >> 24 as uint 8,
   sig >> 16 as uint 8,
   sig >> 8 as uint 8,
   sig as uint 8]
 
ICC.FunOp : Grammar ICC.FunOp =
  do (tag : uint 32) <- Daedalus.BE32
     ($$ : ICC.FunOp) <- case tag is
                           { 1684108385 -> do (_386 : float) <- Daedalus.BEFloat
                                              pure {data: _386}
                           ; 1768824864 -> do (_387 : ICC.OpParams) <- ICC.OpParams
                                              pure {opIn: _387}
                           ; 1869968416 -> do (_388 : ICC.OpParams) <- ICC.OpParams
                                              pure {opOut: _388}
                           ; 1952933236 -> do (_389 : ICC.OpParams) <- ICC.OpParams
                                              pure {opTGet: _389}
                           ; 1953527156 -> do (_390 : ICC.OpParams) <- ICC.OpParams
                                              pure {opTPut: _390}
                           ; 1953718646 -> do (_391 : ICC.OpParams) <- ICC.OpParams
                                              pure {opTSave: _391}
                           ; 1701738016 -> do (_392 : uint 32) <- Daedalus.BE32
                                              pure {opEnv: _392}
                           ; 1668641398 -> do (_393 : uint 32) <- Daedalus.BE32
                                              pure {curv: _393}
                           ; 1836349472 -> do (_394 : uint 32) <- Daedalus.BE32
                                              pure {mtx: _394}
                           ; 1668052340 -> do (_395 : uint 32) <- Daedalus.BE32
                                              pure {clut: _395}
                           ; 1667329123 -> do (_396 : uint 32) <- Daedalus.BE32
                                              pure {calc: _396}
                           ; 1953066612 -> do (_397 : uint 32) <- Daedalus.BE32
                                              pure {tint: _397}
                           ; 1701602669 -> do (_398 : uint 32) <- Daedalus.BE32
                                              pure {elem: _398}
                           ; 1668247673 -> do (_399 : ICC.OpParams) <- ICC.OpParams
                                              pure {copy: _399}
                           ; 1919906924 -> do (_400 : ICC.OpParams) <- ICC.OpParams
                                              pure {rotl: _400}
                           ; 1919906930 -> do (_401 : ICC.OpParams) <- ICC.OpParams
                                              pure {rotr: _401}
                           ; 1886352228 -> do (_402 : ICC.OpParams) <- ICC.OpParams
                                              pure {posd: _402}
                           ; 1718380912 -> do (_403 : ICC.OpParams) <- ICC.OpParams
                                              pure {flip: _403}
                           ; 1886351392 -> do (_404 : ICC.OpParams) <- ICC.OpParams
                                              pure {pop: _404}
                           ; 1936682102 -> do (_405 : ICC.OpParams) <- ICC.OpParams
                                              pure {solv: _405}
                           ; 1953653102 -> do (_406 : ICC.OpParams) <- ICC.OpParams
                                              pure {tran: _406}
                           ; 1937075488 -> do (_407 : uint 16) <- ICC.OpParam
                                              pure {sum: _407}
                           ; 1886547812 -> do (_408 : uint 16) <- ICC.OpParam
                                              pure {prod: _408}
                           ; 1835626016 -> do (_409 : uint 16) <- ICC.OpParam
                                              pure {min: _409}
                           ; 1835104288 -> do (_410 : uint 16) <- ICC.OpParam
                                              pure {max: _410}
                           ; 1634624544 -> do (_411 : uint 16) <- ICC.OpParam
                                              pure {and: _411}
                           ; 1869750304 -> do (_412 : uint 16) <- ICC.OpParam
                                              pure {or: _412}
                           ; 1885937696 -> do (_413 : uint 16) <- ICC.OpParam
                                              pure {opPi: _413}
                           ; 726224454 -> do (_414 : uint 16) <- ICC.OpParam
                                             pure {opPosInf: _414}
                           ; 759778886 -> do (_415 : uint 16) <- ICC.OpParam
                                             pure {opNegInf: _415}
                           ; 1312902688 -> do (_416 : uint 16) <- ICC.OpParam
                                              pure {opNAN: _416}
                           ; 1633969184 -> do (_417 : uint 16) <- ICC.OpParam
                                              pure {opAdd: _417}
                           ; 1937072672 -> do (_418 : uint 16) <- ICC.OpParam
                                              pure {opSub: _418}
                           ; 1836411936 -> do (_419 : uint 16) <- ICC.OpParam
                                              pure {opMul: _419}
                           ; 1684633120 -> do (_420 : uint 16) <- ICC.OpParam
                                              pure {opDiv: _420}
                           ; 1836016672 -> do (_421 : uint 16) <- ICC.OpParam
                                              pure {opMod: _421}
                           ; 1886353184 -> do (_422 : uint 16) <- ICC.OpParam
                                              pure {opPow: _422}
                           ; 1734438241 -> do (_423 : uint 16) <- ICC.OpParam
                                              pure {opGamma: _423}
                           ; 1935762532 -> do (_424 : uint 16) <- ICC.OpParam
                                              pure {opSAdd: _424}
                           ; 1936946530 -> do (_425 : uint 16) <- ICC.OpParam
                                              pure {opSSub: _425}
                           ; 1936553324 -> do (_426 : uint 16) <- ICC.OpParam
                                              pure {opSMul: _426}
                           ; 1935960438 -> do (_427 : uint 16) <- ICC.OpParam
                                              pure {opSDiv: _427}
                           ; 1936793632 -> do (_428 : uint 16) <- ICC.OpParam
                                              pure {opSq: _428}
                           ; 1936814708 -> do (_429 : uint 16) <- ICC.OpParam
                                              pure {opSqrt: _429}
                           ; 1667375136 -> do (_430 : uint 16) <- ICC.OpParam
                                              pure {opCb: _430}
                           ; 1667396212 -> do (_431 : uint 16) <- ICC.OpParam
                                              pure {opCbrt: _431}
                           ; 1633841952 -> do (_432 : uint 16) <- ICC.OpParam
                                              pure {opAbs: _432}
                           ; 1852139296 -> do (_433 : uint 16) <- ICC.OpParam
                                              pure {opNeg: _433}
                           ; 1919905380 -> do (_434 : uint 16) <- ICC.OpParam
                                              pure {opRond: _434}
                           ; 1718382450 -> do (_435 : uint 16) <- ICC.OpParam
                                              pure {opFlor: _435}
                           ; 1667590508 -> do (_436 : uint 16) <- ICC.OpParam
                                              pure {opCeil: _436}
                           ; 1953656419 -> do (_437 : uint 16) <- ICC.OpParam
                                              pure {opTrnc: _437}
                           ; 1936287598 -> do (_438 : uint 16) <- ICC.OpParam
                                              pure {opSign: _438}
                           ; 1702391840 -> do (_439 : uint 16) <- ICC.OpParam
                                              pure {opExp: _439}
                           ; 1819240224 -> do (_440 : uint 16) <- ICC.OpParam
                                              pure {opLog: _440}
                           ; 1819156512 -> do (_441 : uint 16) <- ICC.OpParam
                                              pure {opLn: _441}
                           ; 1936289312 -> do (_442 : uint 16) <- ICC.OpParam
                                              pure {opSin: _442}
                           ; 1668248352 -> do (_443 : uint 16) <- ICC.OpParam
                                              pure {opCos: _443}
                           ; 1952542240 -> do (_444 : uint 16) <- ICC.OpParam
                                              pure {opTan: _444}
                           ; 1634953582 -> do (_445 : uint 16) <- ICC.OpParam
                                              pure {opASin: _445}
                           ; 1633906547 -> do (_446 : uint 16) <- ICC.OpParam
                                              pure {opACos: _446}
                           ; 1635017070 -> do (_447 : uint 16) <- ICC.OpParam
                                              pure {opATan: _447}
                           ; 1635020338 -> do (_448 : uint 16) <- ICC.OpParam
                                              pure {opATn2: _448}
                           ; 1668575088 -> do (_449 : uint 16) <- ICC.OpParam
                                              pure {opCTop: _449}
                           ; 1886678883 -> do (_450 : uint 16) <- ICC.OpParam
                                              pure {opPToc: _450}
                           ; 1919841645 -> do (_451 : uint 16) <- ICC.OpParam
                                              pure {opRNum: _451}
                           ; 1819549728 -> do (_452 : uint 16) <- ICC.OpParam
                                              pure {opLT: _452}
                           ; 1818566688 -> do (_453 : uint 16) <- ICC.OpParam
                                              pure {opLE: _453}
                           ; 1701912608 -> do (_454 : uint 16) <- ICC.OpParam
                                              pure {opEQ: _454}
                           ; 1852137842 -> do (_455 : uint 16) <- ICC.OpParam
                                              pure {opNer: _455}
                           ; 1734680608 -> do (_456 : uint 16) <- ICC.OpParam
                                              pure {opGE: _456}
                           ; 1735663648 -> do (_457 : uint 16) <- ICC.OpParam
                                              pure {opGT: _457}
                           ; 1986881902 -> do (_458 : uint 16) <- ICC.OpParam
                                              pure {opVMin: _458}
                           ; 1986879864 -> do (_459 : uint 16) <- ICC.OpParam
                                              pure {opVMax: _459}
                           ; 1986096740 -> do (_460 : uint 16) <- ICC.OpParam
                                              pure {opVAnd: _460}
                           ; 1987015200 -> do (_461 : uint 16) <- ICC.OpParam
                                              pure {opVOr: _461}
                           ; 1951162722 -> do (_462 : uint 16) <- ICC.OpParam
                                              pure {opTLab: _462}
                           ; 1951947098 -> do (_463 : uint 16) <- ICC.OpParam
                                              pure {opTXYZ: _463}
                           ; 1768300576 -> do (_465 : uint 64) <- do (_464 : uint 32) <- Daedalus.BE32
                                                                     pure (_464 as uint 64)
                                              pure {opIf: _465}
                           ; 1701606245 -> do (_467 : uint 64) <- do (_466 : uint 32) <- Daedalus.BE32
                                                                     pure (_466 as uint 64)
                                              pure {opElse: _467}
                           ; 1936026656 -> do (_468 : {}) <- ICC.NoParams
                                              pure {opSel: _468}
                           ; 1667330917 -> do (_470 : uint 64) <- do (_469 : uint 32) <- Daedalus.BE32
                                                                     pure (_469 as uint 64)
                                              pure {opCase: _470}
                           ; 1684434036 -> do (_472 : uint 64) <- do (_471 : uint 32) <- Daedalus.BE32
                                                                     pure (_471 as uint 64)
                                              pure {opDflt: _472}
                           ; _ -> do (_473 : ICC.FunOp83) <- do (tag : [uint 8]) <- pure (ICC.explode32 tag)
                                                                (param : uint 32) <- Daedalus.BE32
                                                                pure {tag = tag,
                                                                      param = param}
                                     pure {unknown: _473}
                           }
     pure $$
 
ICC.CalcFun : Grammar [ICC.FunOp] =
  do ICC._StartTag "func"
     ($$ : [ICC.FunOp]) <- do (_476 : uint 64) <- do (_475 : uint 32) <- Daedalus.BE32
                                                     pure (_475 as uint 64)
                              Many[_476] ICC.FunOp
     pure $$
 
ICC.PositionNumber : Grammar ICC.PositionNumber =
  do (offset : uint 64) <- do (_477 : uint 32) <- Daedalus.BE32
                              pure (_477 as uint 64)
     (size : uint 64) <- do (_478 : uint 32) <- Daedalus.BE32
                            pure (_478 as uint 64)
     pure {offset = offset,
           size = size}
 
ICC.Positioned ?a0 (s : Stream) (P : Grammar ?a0) : Grammar ?a0 =
  do (p : ICC.PositionNumber) <- ICC.PositionNumber
     ($$ : ?a0) <- Daedalus.LookAhead ?a0 do Daedalus._SetStreamAt (p.offset) s
                                             ($$ : ?a0) <- Daedalus.Chunk ?a0 (p.size) P
                                             pure $$
     pure $$
 
ICC.SingleSampledCurve : Grammar ICC.SingleSampledCurve =
  do (n : uint 32) <- Daedalus.BE32
     (f : uint 32) <- Daedalus.BE32
     (l : uint 32) <- Daedalus.BE32
     (e : uint 16) <- Daedalus.BE16
     (ty : uint 16) <- Daedalus.BE16
     pure {n = n,
           f = f,
           l = l,
           e = e,
           ty = ty}
 
ICC.FunParams_g_a_b_c : Grammar ICC.FunParams_g_a_b_c =
  do (g : float) <- Daedalus.BEFloat
     (a : float) <- Daedalus.BEFloat
     (b : float) <- Daedalus.BEFloat
     (c : float) <- Daedalus.BEFloat
     pure {g = g,
           a = a,
           b = b,
           c = c}
 
ICC.FunParams_g_a_b_c_d : Grammar ICC.FunParams_g_a_b_c_d =
  do (g : float) <- Daedalus.BEFloat
     (a : float) <- Daedalus.BEFloat
     (b : float) <- Daedalus.BEFloat
     (c : float) <- Daedalus.BEFloat
     (d : float) <- Daedalus.BEFloat
     pure {g = g,
           a = a,
           b = b,
           c = c,
           d = d}
 
ICC.FunParams_a_b_c_d_e : Grammar ICC.FunParams_a_b_c_d_e =
  do (a : float) <- Daedalus.BEFloat
     (b : float) <- Daedalus.BEFloat
     (c : float) <- Daedalus.BEFloat
     (d : float) <- Daedalus.BEFloat
     (e : float) <- Daedalus.BEFloat
     pure {a = a,
           b = b,
           c = c,
           d = d,
           e = e}
 
ICC.FormualCurveSegment : Grammar ICC.FormualCurveSegment =
  do (fun : uint 16) <- Daedalus.BE16
     do (_482 : bool) <- do (_481 : uint 16) <- Daedalus.BE16
                            pure (_481 == 0)
        Daedalus._Guard _482
     ($$ : ICC.FormualCurveSegment) <- case fun is
                                         { 0 -> do (_484 : ICC.FunParams_g_a_b_c) <- ICC.FunParams_g_a_b_c
                                                   pure {fun0: _484}
                                         ; 1 -> do (_485 : ICC.FunParams_g_a_b_c_d) <- ICC.FunParams_g_a_b_c_d
                                                   pure {fun1: _485}
                                         ; 2 -> do (_486 : ICC.FunParams_a_b_c_d_e) <- ICC.FunParams_a_b_c_d_e
                                                   pure {fun2: _486}
                                         ; 3 -> do (_487 : ICC.FunParams_g_a_b_c) <- ICC.FunParams_g_a_b_c
                                                   pure {fun3: _487}
                                         }
     pure $$
 
ICC.CurveSegment : Grammar ICC.CurveSegment =
  do (tag : uint 32) <- Daedalus.BE32
     ICC._Exactly (uint 32) 0 Daedalus.BE32
     ($$ : ICC.CurveSegment) <- case tag is
                                  { 1885434470 -> do (_489 : ICC.FormualCurveSegment) <- ICC.FormualCurveSegment
                                                     pure {parf: _489}
                                  ; 1935764838 -> do (_492 : [float]) <- do (_491 : uint 64) <- do (_490 : uint 32) <- Daedalus.BE32
                                                                                                   pure (_490 as uint 64)
                                                                            Many[_491] Daedalus.BEFloat
                                                     pure {samf: _492}
                                  }
     pure $$
 
ICC.SegmentedCurve : Grammar ICC.SegmentedCurve =
  do (n : uint 64) <- do (_493 : uint 16) <- Daedalus.BE16
                         pure (_493 as uint 64)
     Choose biased
       { Daedalus._Guard (1 <= n)
       | Fail "Need at least one curve segment"
       }
     ICC._Exactly (uint 16) 0 Daedalus.BE16
     (bnum : uint 64) <- pure (n - 1)
     (breakPoints : [float]) <- Many[bnum] Daedalus.BEFloat
     (segements : [ICC.CurveSegment]) <- Many[n] ICC.CurveSegment
     pure {breakPoints = breakPoints,
           segements = segements}
 
ICC.Curve : Grammar ICC.Curve =
  do (tag : uint 32) <- Daedalus.BE32
     ICC._Exactly (uint 32) 0 Daedalus.BE32
     ($$ : ICC.Curve) <- case tag is
                           { 1936615270 -> do (_495 : ICC.SingleSampledCurve) <- ICC.SingleSampledCurve
                                              pure {sngf: _495}
                           ; 1668641382 -> do (_496 : ICC.SegmentedCurve) <- ICC.SegmentedCurve
                                              pure {curf: _496}
                           ; _ -> pure {unknown: (ICC.explode32 tag)}
                           }
     pure $$
 
ICC.Matrix (p : uint 64) (q : uint 64) : Grammar ICC.Matrix =
  do (matrix : [[float]]) <- Many[q] Many[p] Daedalus.BEFloat
     (vector : [float]) <- Many[q] Daedalus.BEFloat
     pure {matrix = matrix,
           vector = vector}
 
rec value
  ICC.MPElement : Grammar ICC.MPElement =
    do (s : Stream) <- CurrentStream
       (tag : uint 32) <- Daedalus.BE32
       @MatchBytes [0,
                    0,
                    0,
                    0]
       (inputs : uint 64) <- do (_497 : uint 16) <- Daedalus.BE16
                                pure (_497 as uint 64)
       (outputs : uint 64) <- do (_498 : uint 16) <- Daedalus.BE16
                                 pure (_498 as uint 64)
       ($$ : ICC.MPElement) <- case tag is
                                 { 1667329123 -> do (_500 : ICC.CalcElement) <- ICC.CalcElement s inputs outputs
                                                    pure {calc: _500}
                                 ; 1668707188 -> do (_501 : [ICC.Curve]) <- Many[inputs] ICC.Positioned ICC.Curve s ICC.Curve
                                                    pure {cvst: _501}
                                 ; 1835103334 -> do (_502 : ICC.Matrix) <- ICC.Matrix inputs outputs
                                                    pure {matf: _502}
                                 ; _ -> pure {unknown: (ICC.explode32 tag)}
                                 }
       pure $$
   
  ICC.CalcElement (s : Stream) (inputs : uint 64) (outputs : uint 64) : Grammar ICC.CalcElement =
    do (subElNum : uint 64) <- do (_503 : uint 32) <- Daedalus.BE32
                                  pure (_503 as uint 64)
       (inputs : uint 64) <- pure inputs
       (outputs : uint 64) <- pure outputs
       (main : [ICC.FunOp]) <- ICC.Positioned [ICC.FunOp] s ICC.CalcFun
       (subElements : [ICC.MPElement]) <- Many[subElNum] ICC.Positioned ICC.MPElement s ICC.MPElement
       pure {inputs = inputs,
             outputs = outputs,
             main = main,
             subElements = subElements}
 
ICC.MultiProcessElementsType : Grammar ICC.MultiProcessElementsType =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "mpet"
     (number_of_input_channels : uint 16) <- Daedalus.BE16
     (number_of_output_channels : uint 16) <- Daedalus.BE16
     (number_of_processing_elements : uint 32) <- Daedalus.BE32
     (n : uint 64) <- pure (number_of_processing_elements as uint 64)
     Choose biased
       { Daedalus._Guard (1 <= n)
       | Fail "Need at least one MPE"
       }
     (elements : [ICC.MPElement]) <- Many[n] ICC.Positioned ICC.MPElement s ICC.MPElement
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           number_of_processing_elements = number_of_processing_elements,
           elements = elements}
 
ICC.LutAB_or_multi : Grammar ICC.LutAB_or_multi =
  Choose biased
    { {- lutAB -} do (_504 : ICC.LutAToBType) <- ICC.LutAToBType
                     pure {lutAB: _504}
    | {- mpe -} do (_505 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                   pure {mpe: _505}
    }
 
ICC.LutBA_or_multi : Grammar ICC.LutBA_or_multi =
  Choose biased
    { {- lutBA -} do (_506 : ICC.LutAToBType) <- ICC.LutAToBType
                     pure {lutBA: _506}
    | {- mpe -} do (_507 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                   pure {mpe: _507}
    }
 
ICC.UnicodeRecord (s : Stream) : Grammar ICC.UnicodeRecord =
  do (language : [uint 8]) <- Many[2] GetByte
     (country : [uint 8]) <- Many[2] GetByte
     (size : uint 64) <- do (_508 : uint 32) <- Daedalus.BE32
                            pure (_508 as uint 64)
     (offset : uint 64) <- do (_509 : uint 32) <- Daedalus.BE32
                              pure (_509 as uint 64)
     (data : [uint 8]) <- Daedalus.LookAhead [uint 8] do Daedalus._SetStreamAt offset s
                                                         ($$ : [uint 8]) <- Many[size] GetByte
                                                         pure $$
     pure {language = language,
           country = country,
           data = data}
 
ICC.MultiLocalizedUnicodeType : Grammar [ICC.UnicodeRecord] =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "mluc"
     (record_number : uint 32) <- Daedalus.BE32
     ICC._Exactly (uint 32) 12 Daedalus.BE32
     ($$ : [ICC.UnicodeRecord]) <- Many[record_number as uint 64] ICC.UnicodeRecord s
     pure $$
 
ICC.SpectralViewingConditionsType : Grammar ICC.SpectralViewingConditionsType =
  do ICC._StartTag "svcn"
     (colometric_observer : uint 32) <- Daedalus.BE32
     pure {colometric_observer = colometric_observer}
 
ICC.XYZType : Grammar [ICC.XYZNumber] =
  do ICC._StartTag "XYZ "
     ($$ : [ICC.XYZNumber]) <- Many[] ICC.XYZNumber
     pure $$
 
ICC.Tag (sig : uint 32) : Grammar ICC.Tag =
  case sig is
    { 1684370275 -> do (_513 : [ICC.UnicodeRecord]) <- ICC.MultiLocalizedUnicodeType
                       pure {desc: _513}
    ; 1093812784 -> do (_514 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                       pure {A2B0: _514}
    ; 1093812785 -> do (_515 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                       pure {A2B1: _515}
    ; 1093812786 -> do (_516 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                       pure {A2B2: _516}
    ; 1093812787 -> do (_517 : ICC.LutAB_or_multi) <- ICC.LutAB_or_multi
                       pure {A2B3: _517}
    ; 1093815600 -> do (_518 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {A2Mo: _518}
    ; 1110589744 -> do (_519 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                       pure {B2A0: _519}
    ; 1110589745 -> do (_520 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                       pure {B2A1: _520}
    ; 1110589746 -> do (_521 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                       pure {B2A2: _521}
    ; 1110589747 -> do (_522 : ICC.LutBA_or_multi) <- ICC.LutBA_or_multi
                       pure {B2A3: _522}
    ; 1110590512 -> do (_523 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {B2D0: _523}
    ; 1110590513 -> do (_524 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {B2D1: _524}
    ; 1110590514 -> do (_525 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {B2D2: _525}
    ; 1110590515 -> do (_526 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {B2D3: _526}
    ; 2004119668 -> do (_527 : [ICC.XYZNumber]) <- ICC.XYZType
                       pure {wtpt: _527}
    ; 1668313716 -> do (_528 : [ICC.UnicodeRecord]) <- ICC.MultiLocalizedUnicodeType
                       pure {cprt: _528}
    ; 1664250736 -> do (_529 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {c2sp: _529}
    ; 1932682096 -> do (_530 : ICC.MultiProcessElementsType) <- ICC.MultiProcessElementsType
                       pure {s2sp: _530}
    ; 1937138542 -> do (_531 : ICC.SpectralViewingConditionsType) <- ICC.SpectralViewingConditionsType
                       pure {svcn: _531}
    ; _ -> pure {unknown: (ICC.explode32 sig)}
    }
 
ICC.ParseTagIn (s : Stream) (t : ICC.TagEntry) : Grammar ICC.Tag =
  do Daedalus._SetStreamAt (t.offset_to_data_element) s
     ($$ : ICC.Tag) <- Daedalus.Chunk ICC.Tag (t.size_of_data_element) (ICC.Tag (t.tag_signature))
     pure $$
 
ICC.Main : Grammar ICC.Main =
  do (s : Stream) <- CurrentStream
     (profileHeader : ICC.ProfileHeader) <- ICC.ProfileHeader
     (tags : [ICC.Tag]) <- do (_533 : [ICC.TagEntry]) <- ICC.TagTable
                              map ((entry : ICC.TagEntry) in _533)
                                (ICC.ParseTagIn s entry)
     pure {profileHeader = profileHeader,
           tags = tags}
 
ICC.ParseTag (t : ICC.TagEntry) : Grammar ICC.Tag =
  do Daedalus._Skip (t.offset_to_data_element)
     ($$ : ICC.Tag) <- Daedalus.Chunk ICC.Tag (t.size_of_data_element) (ICC.Tag (t.tag_signature))
     pure $$
 
ICC.XYNumber : Grammar ICC.XYNumber =
  do (x : uint 32) <- Daedalus.BE32
     (y : uint 32) <- Daedalus.BE32
     pure {x = x,
           y = y}
 
ICC.ASCII7 : Grammar [uint 7] =
  do ($$ : [uint 7]) <- Many[] do (_535 : uint 8) <- Match (1 .. 255)
                                  _535 AS uint 7
     Choose biased
       { @Many[ 1 .. ] @Match {'\NUL'}
       | Fail "Non 0 string terminator"
       }
     pure $$
 
ICC.Response16Number : Grammar ICC.Response16Number =
  do (device : uint 16) <- Daedalus.BE16
     ICC._Exactly (uint 16) 0 Daedalus.BE16
     (measurement : uint 32) <- Daedalus.BE32
     pure {device = device,
           measurement = measurement}
 
ICC.exp ?a0 ?a1 (Arith ?a0) (Integral ?a1) (Literal 1 ?a1) (Literal 0 ?a1) (Literal 1 ?a0) (b : ?a0) (e : ?a1) : ?a0 =
  for ((x : ?a0) = 1; (i : ?a1) in rangeUp 0 e 1)
    (x * b)
 
ICC.Lut8Type : Grammar ICC.Lut8Type =
  do ICC._StartTag "mft1"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {'\NUL'}
     (encoded_e_parameters : [sint 32]) <- Many[9] do (_536 : uint 32) <- Daedalus.BE32
                                                      pure (_536 as sint 32)
     (input_tables : Stream) <- Daedalus.Bytes (256 * i)
     (clut_values : Stream) <- Daedalus.Bytes ((ICC.exp (uint 64) (uint 64) g i) * o)
     (output_tables : Stream) <- Daedalus.Bytes (256 * o)
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           number_of_clut_grid_points = number_of_clut_grid_points,
           encoded_e_parameters = encoded_e_parameters,
           input_tables = input_tables,
           clut_values = clut_values,
           output_tables = output_tables}
 
ICC.Lut16Type : Grammar ICC.Lut16Type =
  do ICC._StartTag "mft2"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {'\NUL'}
     (encoded_e_parameters : [sint 32]) <- Many[9] do (_537 : uint 32) <- Daedalus.BE32
                                                      pure (_537 as sint 32)
     (number_of_input_table_entries : uint 32) <- Daedalus.BE32
     (n : uint 64) <- pure (number_of_input_table_entries as uint 64)
     (number_of_output_table_entries : uint 32) <- Daedalus.BE32
     (m : uint 64) <- pure (number_of_output_table_entries as uint 64)
     (input_tables : Stream) <- Daedalus.Bytes ((256 * n) * i)
     (clut_values : Stream) <- Daedalus.Bytes ((2 * (ICC.exp (uint 64) (uint 64) g i)) * o)
     (output_tables : Stream) <- Daedalus.Bytes ((2 * m) * o)
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           number_of_clut_grid_points = number_of_clut_grid_points,
           encoded_e_parameters = encoded_e_parameters,
           number_of_input_table_entries = number_of_input_table_entries,
           number_of_output_table_entries = number_of_output_table_entries,
           input_tables = input_tables,
           clut_values = clut_values,
           output_tables = output_tables}
 
ICC.LutBToAType : Grammar ICC.LutBToAType =
  do ICC._StartTag "mBA "
     (number_of_input_channels : uint 8) <- GetByte
     (number_of_output_channels : uint 8) <- GetByte
     @MatchBytes [0,
                  0]
     (offset_first_B_curve : uint 32) <- Daedalus.BE32
     (offset_to_matrix : uint 32) <- Daedalus.BE32
     (offset_to_first_M_curve : uint 32) <- Daedalus.BE32
     (offset_to_CLUT : uint 32) <- Daedalus.BE32
     (offset_to_first_A_curve : uint 32) <- Daedalus.BE32
     (data : Stream) <- CurrentStream
     pure {number_of_input_channels = number_of_input_channels,
           number_of_output_channels = number_of_output_channels,
           offset_first_B_curve = offset_first_B_curve,
           offset_to_matrix = offset_to_matrix,
           offset_to_first_M_curve = offset_to_first_M_curve,
           offset_to_CLUT = offset_to_CLUT,
           offset_to_first_A_curve = offset_to_first_A_curve,
           data = data}
 
ICC.Lut_8_16_AB_BA : Grammar ICC.Lut_8_16_AB_BA =
  Choose biased
    { {- lut8 -} do (_538 : ICC.Lut8Type) <- ICC.Lut8Type
                    pure {lut8: _538}
    | {- lut16 -} do (_539 : ICC.Lut16Type) <- ICC.Lut16Type
                     pure {lut16: _539}
    | {- lutAB -} do (_540 : ICC.LutAToBType) <- ICC.LutAToBType
                     pure {lutAB: _540}
    | {- lutBA -} do (_541 : ICC.LutBToAType) <- ICC.LutBToAType
                     pure {lutBA: _541}
    }
 
ICC.Lut_8_16_AB : Grammar ICC.Lut_8_16_AB =
  Choose biased
    { {- lut8 -} do (_542 : ICC.Lut8Type) <- ICC.Lut8Type
                    pure {lut8: _542}
    | {- lut16 -} do (_543 : ICC.Lut16Type) <- ICC.Lut16Type
                     pure {lut16: _543}
    | {- lutAB -} do (_544 : ICC.LutAToBType) <- ICC.LutAToBType
                     pure {lutAB: _544}
    }
 
ICC.Lut_8_16_BA : Grammar ICC.Lut_8_16_BA =
  Choose biased
    { {- lut8 -} do (_545 : ICC.Lut8Type) <- ICC.Lut8Type
                    pure {lut8: _545}
    | {- lut16 -} do (_546 : ICC.Lut16Type) <- ICC.Lut16Type
                     pure {lut16: _546}
    | {- lutBA -} do (_547 : ICC.LutBToAType) <- ICC.LutBToAType
                     pure {lutBA: _547}
    }
 
ICC.CurveType : Grammar [uint 16] =
  do ICC._StartTag "curv"
     (n : uint 64) <- do (_548 : uint 32) <- Daedalus.BE32
                         pure (_548 as uint 64)
     ($$ : [uint 16]) <- Many[n] Daedalus.BE16
     pure $$
 
ICC.ParametricCurveType : Grammar ICC.ParametricCurveType =
  do ICC._StartTag "para"
     (function : uint 16) <- Daedalus.BE16
     @MatchBytes [0,
                  0]
     (parameters : [uint 32]) <- Many[] Daedalus.BE32
     pure {function = function,
           parameters = parameters}
 
ICC.SomeCurve : Grammar ICC.SomeCurve =
  Choose biased
    { {- curve -} do (_550 : [uint 16]) <- ICC.CurveType
                     pure {curve: _550}
    | {- parametric_curve -} do (_551 : ICC.ParametricCurveType) <- ICC.ParametricCurveType
                                pure {parametric_curve: _551}
    }
 
ICC.StartTag (x : [uint 8]) : Grammar [uint 8] =
  do @MatchBytes x
     ($$ : [uint 8]) <- MatchBytes [0,
                                    0,
                                    0,
                                    0]
     pure $$
 
ICC.DateTimeType : Grammar ICC.DateTimeNumber =
  do ICC._StartTag "dtim"
     ($$ : ICC.DateTimeNumber) <- ICC.DateTimeNumber
     pure $$
 
ICC.TextType : Grammar [uint 7] =
  do ICC._StartTag "text"
     ($$ : [uint 7]) <- Daedalus.Only [uint 7] ICC.ASCII7
     pure $$
 
ICC.SignatureType : Grammar [uint 8] =
  do ICC._StartTag "sig "
     ($$ : [uint 8]) <- Many[4] GetByte
     pure $$
 
ICC.S15Fixed16ArrayType : Grammar [uint 32] =
  do ICC._StartTag "sf32"
     ($$ : [uint 32]) <- Many[] Daedalus.BE32
     pure $$
 
ICC.ChromaticityType : Grammar ICC.ChromaticityType =
  do ICC._StartTag "chrm"
     (number_of_device_channels : uint 64) <- do (_556 : uint 16) <- Daedalus.BE16
                                                 pure (_556 as uint 64)
     (phosphor_or_colorant : uint 16) <- Daedalus.BE16
     (cie_coords : [ICC.XYNumber]) <- Many[number_of_device_channels] ICC.XYNumber
     pure {phosphor_or_colorant = phosphor_or_colorant,
           cie_coords = cie_coords}
 
ICC.ColorantOrderType : Grammar [uint 8] =
  do ICC._StartTag "clro"
     Daedalus._BE32
     ($$ : [uint 8]) <- Many[] GetByte
     pure $$
 
ICC.Colorant : Grammar ICC.Colorant =
  do (name : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (pcs : [uint 16]) <- Many[3] Daedalus.BE16
     pure {name = name,
           pcs = pcs}
 
ICC.ColorantTableType : Grammar [ICC.Colorant] =
  do ICC._StartTag "clrt"
     (count_of_colorant : uint 64) <- do (_558 : uint 32) <- Daedalus.BE32
                                         pure (_558 as uint 64)
     ($$ : [ICC.Colorant]) <- Many[count_of_colorant] ICC.Colorant
     pure $$
 
ICC.ResponseCurve (n : uint 64) : Grammar ICC.ResponseCurve =
  do (measurement_unit : uint 32) <- Daedalus.BE32
     (counts : [uint 32]) <- Many[n] Daedalus.BE32
     (pcxyzs : [ICC.XYNumber]) <- Many[n] ICC.XYNumber
     (response_arrays : [[ICC.Response16Number]]) <- map ((qi : uint 32) in counts)
                                                       (Many[qi as uint 64] ICC.Response16Number)
     pure {measurement_unit = measurement_unit,
           pcxyzs = pcxyzs,
           response_arrays = response_arrays}
 
ICC.ResponseCurveSet16Type : Grammar [ICC.ResponseCurve] =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "rcs2"
     (number_of_channels : uint 64) <- do (_560 : uint 16) <- Daedalus.BE16
                                          pure (_560 as uint 64)
     (count : uint 64) <- do (_561 : uint 16) <- Daedalus.BE16
                             pure (_561 as uint 64)
     ($$ : [ICC.ResponseCurve]) <- Many[count] do (off : uint 64) <- do (_563 : uint 32) <- Daedalus.BE32
                                                                        pure (_563 as uint 64)
                                                  ($$ : ICC.ResponseCurve) <- Daedalus.LookAhead ICC.ResponseCurve do Daedalus._SetStreamAt off s
                                                                                                                      ($$ : ICC.ResponseCurve) <- ICC.ResponseCurve number_of_channels
                                                                                                                      pure $$
                                                  pure $$
     pure $$
 
ICC.MeasurementType : Grammar ICC.MeasurementType =
  do ICC._StartTag "meas"
     (standard_observer : uint 32) <- Daedalus.BE32
     (nCIEXYZ : ICC.XYZNumber) <- ICC.XYZNumber
     (geometry : uint 32) <- Daedalus.BE32
     (flare : uint 32) <- Daedalus.BE32
     (illuminant : uint 32) <- Daedalus.BE32
     pure {standard_observer = standard_observer,
           nCIEXYZ = nCIEXYZ,
           geometry = geometry,
           flare = flare,
           illuminant = illuminant}
 
ICC.ColorName (m : uint 64) : Grammar ICC.ColorName =
  do (name_root : [uint 7]) <- Daedalus.Chunk [uint 7] 32 ICC.ASCII7
     (pcs_coords : [uint 16]) <- Many[3] Daedalus.BE16
     (device_coords : [uint 16]) <- Many[m] Daedalus.BE16
     pure {name_root = name_root,
           pcs_coords = pcs_coords,
           device_coords = device_coords}
 
ICC.NamedColor2Type : Grammar ICC.NamedColor2Type =
  do ICC._StartTag "ncl2"
     (vendor_specific : uint 32) <- Daedalus.BE32
     (count : uint 64) <- do (_566 : uint 32) <- Daedalus.BE32
                             pure (_566 as uint 64)
     (number_of_coords : uint 64) <- do (_567 : uint 32) <- Daedalus.BE32
                                        pure (_567 as uint 64)
     (prefix : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (suffix : [uint 7]) <- Daedalus.Chunk [uint 7] 32 (Daedalus.Only [uint 7] ICC.ASCII7)
     (names : [ICC.ColorName]) <- Many[count] ICC.ColorName number_of_coords
     pure {vendor_specific = vendor_specific,
           prefix = prefix,
           suffix = suffix,
           names = names}
 
ICC.ViewConditionsType : Grammar ICC.ViewConditionsType =
  do ICC._StartTag "view"
     (illuminantXYZ : ICC.XYZNumber) <- ICC.XYZNumber
     (surroundXYZ : ICC.XYZNumber) <- ICC.XYZNumber
     (illuminant : uint 32) <- Daedalus.BE32
     pure {illuminantXYZ = illuminantXYZ,
           surroundXYZ = surroundXYZ,
           illuminant = illuminant}
 
ICC._Positioned ?a0 (s : Stream) (_P : Grammar {}) : Grammar {} =
  do (p : ICC.PositionNumber) <- ICC.PositionNumber
     Daedalus._LookAhead ?a0 do Daedalus._SetStreamAt (p.offset) s
                                Daedalus._Chunk ?a0 (p.size) _P
 
ICC._SingleSampledCurve : Grammar {} =
  do Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE16
     Daedalus._BE16
 
ICC._FunParams_g_a_b_c : Grammar {} =
  do Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
 
ICC._FunParams_g_a_b_c_d : Grammar {} =
  do Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
 
ICC._FunParams_a_b_c_d_e : Grammar {} =
  do Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
     Daedalus._BEFloat
 
ICC._FormualCurveSegment : Grammar {} =
  do (fun : uint 16) <- Daedalus.BE16
     do (_482 : bool) <- do (_481 : uint 16) <- Daedalus.BE16
                            pure (_481 == 0)
        Daedalus._Guard _482
     case fun is
       { 0 -> ICC._FunParams_g_a_b_c
       ; 1 -> ICC._FunParams_g_a_b_c_d
       ; 2 -> ICC._FunParams_a_b_c_d_e
       ; 3 -> ICC._FunParams_g_a_b_c
       }
 
ICC._CurveSegment : Grammar {} =
  do (tag : uint 32) <- Daedalus.BE32
     ICC._Exactly (uint 32) 0 Daedalus.BE32
     case tag is
       { 1885434470 -> ICC._FormualCurveSegment
       ; 1935764838 -> do (_491 : uint 64) <- do (_490 : uint 32) <- Daedalus.BE32
                                                 pure (_490 as uint 64)
                          @Many[_491] Daedalus._BEFloat
       }
 
ICC._SegmentedCurve : Grammar {} =
  do (n : uint 64) <- do (_493 : uint 16) <- Daedalus.BE16
                         pure (_493 as uint 64)
     Choose biased
       { Daedalus._Guard (1 <= n)
       | Fail "Need at least one curve segment"
       }
     ICC._Exactly (uint 16) 0 Daedalus.BE16
     (bnum : uint 64) <- pure (n - 1)
     @Many[bnum] Daedalus._BEFloat
     @Many[n] ICC._CurveSegment
 
ICC._Curve : Grammar {} =
  do (tag : uint 32) <- Daedalus.BE32
     ICC._Exactly (uint 32) 0 Daedalus.BE32
     case tag is
       { 1936615270 -> ICC._SingleSampledCurve
       ; 1668641382 -> ICC._SegmentedCurve
       ; _ -> pure {}
       }
 
ICC._Matrix (p : uint 64) (q : uint 64) : Grammar {} =
  do @Many[q] @Many[p] Daedalus._BEFloat
     @Many[q] Daedalus._BEFloat
 
ICC._MPElement : Grammar {} =
  do (s : Stream) <- CurrentStream
     (tag : uint 32) <- Daedalus.BE32
     @MatchBytes [0,
                  0,
                  0,
                  0]
     (inputs : uint 64) <- do (_497 : uint 16) <- Daedalus.BE16
                              pure (_497 as uint 64)
     (outputs : uint 64) <- do (_498 : uint 16) <- Daedalus.BE16
                               pure (_498 as uint 64)
     case tag is
       { 1667329123 -> do ICC.CalcElement s inputs outputs
                          pure {}
       ; 1668707188 -> @Many[inputs] ICC._Positioned ICC.Curve s ICC._Curve
       ; 1835103334 -> ICC._Matrix inputs outputs
       ; _ -> pure {}
       }
 
ICC._MultiProcessElementsType : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "mpet"
     Daedalus._BE16
     Daedalus._BE16
     (number_of_processing_elements : uint 32) <- Daedalus.BE32
     (n : uint 64) <- pure (number_of_processing_elements as uint 64)
     Choose biased
       { Daedalus._Guard (1 <= n)
       | Fail "Need at least one MPE"
       }
     @Many[n] ICC._Positioned ICC.MPElement s ICC._MPElement
 
ICC._LutAToBType : Grammar {} =
  do ICC._StartTag "mAB "
     @GetByte
     @GetByte
     @MatchBytes [0,
                  0]
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
 
ICC._LutAB_or_multi : Grammar {} =
  Choose biased
    { {- lutAB -} ICC._LutAToBType
    | {- mpe -} ICC._MultiProcessElementsType
    }
 
ICC._LutBA_or_multi : Grammar {} =
  Choose biased
    { {- lutBA -} ICC._LutAToBType
    | {- mpe -} ICC._MultiProcessElementsType
    }
 
ICC._UnicodeRecord (s : Stream) : Grammar {} =
  do @Many[2] @GetByte
     @Many[2] @GetByte
     (size : uint 64) <- do (_508 : uint 32) <- Daedalus.BE32
                            pure (_508 as uint 64)
     (offset : uint 64) <- do (_509 : uint 32) <- Daedalus.BE32
                              pure (_509 as uint 64)
     Daedalus._LookAhead [uint 8] do Daedalus._SetStreamAt offset s
                                     @Many[size] @GetByte
 
ICC._MultiLocalizedUnicodeType : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "mluc"
     (record_number : uint 32) <- Daedalus.BE32
     ICC._Exactly (uint 32) 12 Daedalus.BE32
     @Many[record_number as uint 64] ICC._UnicodeRecord s
 
ICC._SpectralViewingConditionsType : Grammar {} =
  do ICC._StartTag "svcn"
     Daedalus._BE32
 
ICC._XYZNumber : Grammar {} =
  do Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
 
ICC._XYZType : Grammar {} =
  do ICC._StartTag "XYZ "
     @Many[] ICC._XYZNumber
 
ICC._Tag (sig : uint 32) : Grammar {} =
  case sig is
    { 1684370275 -> ICC._MultiLocalizedUnicodeType
    ; 1093812784 -> ICC._LutAB_or_multi
    ; 1093812785 -> ICC._LutAB_or_multi
    ; 1093812786 -> ICC._LutAB_or_multi
    ; 1093812787 -> ICC._LutAB_or_multi
    ; 1093815600 -> ICC._MultiProcessElementsType
    ; 1110589744 -> ICC._LutBA_or_multi
    ; 1110589745 -> ICC._LutBA_or_multi
    ; 1110589746 -> ICC._LutBA_or_multi
    ; 1110589747 -> ICC._LutBA_or_multi
    ; 1110590512 -> ICC._MultiProcessElementsType
    ; 1110590513 -> ICC._MultiProcessElementsType
    ; 1110590514 -> ICC._MultiProcessElementsType
    ; 1110590515 -> ICC._MultiProcessElementsType
    ; 2004119668 -> ICC._XYZType
    ; 1668313716 -> ICC._MultiLocalizedUnicodeType
    ; 1664250736 -> ICC._MultiProcessElementsType
    ; 1932682096 -> ICC._MultiProcessElementsType
    ; 1937138542 -> ICC._SpectralViewingConditionsType
    ; _ -> pure {}
    }
 
ICC._ParseTag (t : ICC.TagEntry) : Grammar {} =
  do Daedalus._Skip (t.offset_to_data_element)
     Daedalus._Chunk ICC.Tag (t.size_of_data_element) (ICC._Tag (t.tag_signature))
 
ICC.TagStructType : Grammar ICC.TagStructType =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "tstr"
     (struct_type_id : [uint 8]) <- Many[4] GetByte
     (n : uint 64) <- do (_568 : uint 32) <- Daedalus.BE32
                         pure (_568 as uint 64)
     @Many[n] do (ent : ICC.TagEntry) <- ICC.TagEntry
                 Daedalus._LookAhead ICC.Tag do SetStream s
                                                ICC._ParseTag ent
     pure {struct_type_id = struct_type_id}
 
ICC.ChunkRelativeTo (s : Stream) (off : uint 64) (sz : uint 64) : Grammar Stream =
  do Daedalus._SetStreamAt off s
     ($$ : Stream) <- Daedalus.Bytes sz
     pure $$
 
ICC._VersionField : Grammar {} =
  do @GetByte
     @GetByte
     @MatchBytes [0,
                  0]
 
ICC._ProfileClass : Grammar {} =
  do (_373 : uint 32) <- Daedalus.BE32
     case _373 is
       { 1935896178 -> pure {}
       ; 1835955314 -> pure {}
       ; 1886549106 -> pure {}
       ; 1818848875 -> pure {}
       ; 1936744803 -> pure {}
       ; 1633842036 -> pure {}
       ; 1852662636 -> pure {}
       ; 1667591779 -> pure {}
       ; 1835623456 -> pure {}
       ; 1835822699 -> pure {}
       ; 1836476787 -> pure {}
       }
 
ICC._DataColorSpace : Grammar {} =
  do (tag : uint 32) <- Daedalus.BE32
     case tag is
       { 1482250784 -> pure {}
       ; 1281450528 -> pure {}
       ; 1282766368 -> pure {}
       ; 1499685490 -> pure {}
       ; 1501067552 -> pure {}
       ; 1280135968 -> pure {}
       ; 1380401696 -> pure {}
       ; 1196573017 -> pure {}
       ; 1213421088 -> pure {}
       ; 1212961568 -> pure {}
       ; 1129142603 -> pure {}
       ; 1129142560 -> pure {}
       ; 843271250 -> pure {}
       ; 860048466 -> pure {}
       ; 876825682 -> pure {}
       ; 893602898 -> pure {}
       ; 910380114 -> pure {}
       ; 927157330 -> pure {}
       ; 943934546 -> pure {}
       ; 960711762 -> pure {}
       ; 1094929490 -> pure {}
       ; 1111706706 -> pure {}
       ; 1128483922 -> pure {}
       ; 1145261138 -> pure {}
       ; 1162038354 -> pure {}
       ; 1178815570 -> pure {}
       ; 0 -> pure {}
       ; _ -> Daedalus._Guard ((tag >> 16) == 28261)
       }
 
ICC._PrimaryPlatform : Grammar {} =
  do (_376 : uint 32) <- Daedalus.BE32
     case _376 is
       { 1095782476 -> pure {}
       ; 1297303124 -> pure {}
       ; 1397180704 -> pure {}
       ; 1398099543 -> pure {}
       ; 0 -> pure {}
       }
 
ICC._RenderingIntent : Grammar {} =
  do (_377 : uint 32) <- Daedalus.BE32
     case _377 is
       { 0 -> pure {}
       ; 1 -> pure {}
       ; 2 -> pure {}
       ; 3 -> pure {}
       }
 
ICC._DateTimeNumber : Grammar {} =
  do Daedalus._BE16
     Daedalus._BE16
     Daedalus._BE16
     Daedalus._BE16
     Daedalus._BE16
     Daedalus._BE16
 
ICC._ProfileHeader : Grammar {} =
  do Daedalus._BE32
     @Many[4] @GetByte
     ICC._VersionField
     ICC._ProfileClass
     ICC._DataColorSpace
     ICC._DataColorSpace
     ICC._DateTimeNumber
     @MatchBytes "acsp"
     ICC._PrimaryPlatform
     Daedalus._BE32
     @Many[4] @GetByte
     @Many[4] @GetByte
     Daedalus._BE64
     ICC._RenderingIntent
     ICC._XYZNumber
     @Many[4] @GetByte
     @Many[16] @GetByte
     @Many[28] @GetByte
 
ICC._TagEntry : Grammar {} =
  do Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
 
ICC._TagTable : Grammar {} =
  do (_381 : uint 64) <- do (_380 : uint 32) <- Daedalus.BE32
                            pure (_380 as uint 64)
     @Many[_381] ICC._TagEntry
 
ICC._NoParams : Grammar {} =
  ICC._Exactly (uint 32) 0 Daedalus.BE32
 
ICC._OpParam : Grammar {} =
  do Daedalus._BE16
     ICC._Exactly (uint 16) 0 Daedalus.BE16
 
ICC._OpParams : Grammar {} =
  do Daedalus._BE16
     Daedalus._BE16
 
ICC._FunOp : Grammar {} =
  do (tag : uint 32) <- Daedalus.BE32
     case tag is
       { 1684108385 -> Daedalus._BEFloat
       ; 1768824864 -> ICC._OpParams
       ; 1869968416 -> ICC._OpParams
       ; 1952933236 -> ICC._OpParams
       ; 1953527156 -> ICC._OpParams
       ; 1953718646 -> ICC._OpParams
       ; 1701738016 -> Daedalus._BE32
       ; 1668641398 -> Daedalus._BE32
       ; 1836349472 -> Daedalus._BE32
       ; 1668052340 -> Daedalus._BE32
       ; 1667329123 -> Daedalus._BE32
       ; 1953066612 -> Daedalus._BE32
       ; 1701602669 -> Daedalus._BE32
       ; 1668247673 -> ICC._OpParams
       ; 1919906924 -> ICC._OpParams
       ; 1919906930 -> ICC._OpParams
       ; 1886352228 -> ICC._OpParams
       ; 1718380912 -> ICC._OpParams
       ; 1886351392 -> ICC._OpParams
       ; 1936682102 -> ICC._OpParams
       ; 1953653102 -> ICC._OpParams
       ; 1937075488 -> ICC._OpParam
       ; 1886547812 -> ICC._OpParam
       ; 1835626016 -> ICC._OpParam
       ; 1835104288 -> ICC._OpParam
       ; 1634624544 -> ICC._OpParam
       ; 1869750304 -> ICC._OpParam
       ; 1885937696 -> ICC._OpParam
       ; 726224454 -> ICC._OpParam
       ; 759778886 -> ICC._OpParam
       ; 1312902688 -> ICC._OpParam
       ; 1633969184 -> ICC._OpParam
       ; 1937072672 -> ICC._OpParam
       ; 1836411936 -> ICC._OpParam
       ; 1684633120 -> ICC._OpParam
       ; 1836016672 -> ICC._OpParam
       ; 1886353184 -> ICC._OpParam
       ; 1734438241 -> ICC._OpParam
       ; 1935762532 -> ICC._OpParam
       ; 1936946530 -> ICC._OpParam
       ; 1936553324 -> ICC._OpParam
       ; 1935960438 -> ICC._OpParam
       ; 1936793632 -> ICC._OpParam
       ; 1936814708 -> ICC._OpParam
       ; 1667375136 -> ICC._OpParam
       ; 1667396212 -> ICC._OpParam
       ; 1633841952 -> ICC._OpParam
       ; 1852139296 -> ICC._OpParam
       ; 1919905380 -> ICC._OpParam
       ; 1718382450 -> ICC._OpParam
       ; 1667590508 -> ICC._OpParam
       ; 1953656419 -> ICC._OpParam
       ; 1936287598 -> ICC._OpParam
       ; 1702391840 -> ICC._OpParam
       ; 1819240224 -> ICC._OpParam
       ; 1819156512 -> ICC._OpParam
       ; 1936289312 -> ICC._OpParam
       ; 1668248352 -> ICC._OpParam
       ; 1952542240 -> ICC._OpParam
       ; 1634953582 -> ICC._OpParam
       ; 1633906547 -> ICC._OpParam
       ; 1635017070 -> ICC._OpParam
       ; 1635020338 -> ICC._OpParam
       ; 1668575088 -> ICC._OpParam
       ; 1886678883 -> ICC._OpParam
       ; 1919841645 -> ICC._OpParam
       ; 1819549728 -> ICC._OpParam
       ; 1818566688 -> ICC._OpParam
       ; 1701912608 -> ICC._OpParam
       ; 1852137842 -> ICC._OpParam
       ; 1734680608 -> ICC._OpParam
       ; 1735663648 -> ICC._OpParam
       ; 1986881902 -> ICC._OpParam
       ; 1986879864 -> ICC._OpParam
       ; 1986096740 -> ICC._OpParam
       ; 1987015200 -> ICC._OpParam
       ; 1951162722 -> ICC._OpParam
       ; 1951947098 -> ICC._OpParam
       ; 1768300576 -> Daedalus._BE32
       ; 1701606245 -> Daedalus._BE32
       ; 1936026656 -> ICC._NoParams
       ; 1667330917 -> Daedalus._BE32
       ; 1684434036 -> Daedalus._BE32
       ; _ -> Daedalus._BE32
       }
 
ICC._CalcFun : Grammar {} =
  do ICC._StartTag "func"
     (_476 : uint 64) <- do (_475 : uint 32) <- Daedalus.BE32
                            pure (_475 as uint 64)
     @Many[_476] ICC._FunOp
 
ICC._PositionNumber : Grammar {} =
  do Daedalus._BE32
     Daedalus._BE32
 
ICC._CalcElement (s : Stream) : Grammar {} =
  do (subElNum : uint 64) <- do (_503 : uint 32) <- Daedalus.BE32
                                pure (_503 as uint 64)
     ICC._Positioned [ICC.FunOp] s ICC._CalcFun
     @Many[subElNum] ICC._Positioned ICC.MPElement s ICC._MPElement
 
ICC._ParseTagIn (s : Stream) (t : ICC.TagEntry) : Grammar {} =
  do Daedalus._SetStreamAt (t.offset_to_data_element) s
     Daedalus._Chunk ICC.Tag (t.size_of_data_element) (ICC._Tag (t.tag_signature))
 
ICC._Main : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._ProfileHeader
     (_533 : [ICC.TagEntry]) <- ICC.TagTable
     map ((entry : ICC.TagEntry) in _533)
       (ICC.ParseTagIn s entry)
     pure {}
 
ICC._XYNumber : Grammar {} =
  do Daedalus._BE32
     Daedalus._BE32
 
ICC._ASCII7 : Grammar {} =
  do @Many[] do (_535 : uint 8) <- Match (1 .. 255)
                @(_535 AS uint 7)
     Choose biased
       { @Many[ 1 .. ] @Match {'\NUL'}
       | Fail "Non 0 string terminator"
       }
 
ICC._Response16Number : Grammar {} =
  do Daedalus._BE16
     ICC._Exactly (uint 16) 0 Daedalus.BE16
     Daedalus._BE32
 
ICC._Lut8Type : Grammar {} =
  do ICC._StartTag "mft1"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {'\NUL'}
     @Many[9] Daedalus._BE32
     Daedalus._Bytes (256 * i)
     Daedalus._Bytes ((ICC.exp (uint 64) (uint 64) g i) * o)
     Daedalus._Bytes (256 * o)
 
ICC._Lut16Type : Grammar {} =
  do ICC._StartTag "mft2"
     (number_of_input_channels : uint 8) <- GetByte
     (i : uint 64) <- pure (number_of_input_channels as uint 64)
     (number_of_output_channels : uint 8) <- GetByte
     (o : uint 64) <- pure (number_of_output_channels as uint 64)
     (number_of_clut_grid_points : uint 8) <- GetByte
     (g : uint 64) <- pure (number_of_clut_grid_points as uint 64)
     @Match {'\NUL'}
     @Many[9] Daedalus._BE32
     (number_of_input_table_entries : uint 32) <- Daedalus.BE32
     (n : uint 64) <- pure (number_of_input_table_entries as uint 64)
     (number_of_output_table_entries : uint 32) <- Daedalus.BE32
     (m : uint 64) <- pure (number_of_output_table_entries as uint 64)
     Daedalus._Bytes ((256 * n) * i)
     Daedalus._Bytes ((2 * (ICC.exp (uint 64) (uint 64) g i)) * o)
     Daedalus._Bytes ((2 * m) * o)
 
ICC._LutBToAType : Grammar {} =
  do ICC._StartTag "mBA "
     @GetByte
     @GetByte
     @MatchBytes [0,
                  0]
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
 
ICC._Lut_8_16_AB_BA : Grammar {} =
  Choose biased
    { {- lut8 -} ICC._Lut8Type
    | {- lut16 -} ICC._Lut16Type
    | {- lutAB -} ICC._LutAToBType
    | {- lutBA -} ICC._LutBToAType
    }
 
ICC._Lut_8_16_AB : Grammar {} =
  Choose biased
    { {- lut8 -} ICC._Lut8Type
    | {- lut16 -} ICC._Lut16Type
    | {- lutAB -} ICC._LutAToBType
    }
 
ICC._Lut_8_16_BA : Grammar {} =
  Choose biased
    { {- lut8 -} ICC._Lut8Type
    | {- lut16 -} ICC._Lut16Type
    | {- lutBA -} ICC._LutBToAType
    }
 
ICC._CurveType : Grammar {} =
  do ICC._StartTag "curv"
     (n : uint 64) <- do (_548 : uint 32) <- Daedalus.BE32
                         pure (_548 as uint 64)
     @Many[n] Daedalus._BE16
 
ICC._ParametricCurveType : Grammar {} =
  do ICC._StartTag "para"
     Daedalus._BE16
     @MatchBytes [0,
                  0]
     @Many[] Daedalus._BE32
 
ICC._SomeCurve : Grammar {} =
  Choose biased
    { {- curve -} ICC._CurveType
    | {- parametric_curve -} ICC._ParametricCurveType
    }
 
ICC._DateTimeType : Grammar {} =
  do ICC._StartTag "dtim"
     ICC._DateTimeNumber
 
ICC._TextType : Grammar {} =
  do ICC._StartTag "text"
     Daedalus._Only [uint 7] ICC._ASCII7
 
ICC._SignatureType : Grammar {} =
  do ICC._StartTag "sig "
     @Many[4] @GetByte
 
ICC._S15Fixed16ArrayType : Grammar {} =
  do ICC._StartTag "sf32"
     @Many[] Daedalus._BE32
 
ICC._ChromaticityType : Grammar {} =
  do ICC._StartTag "chrm"
     (number_of_device_channels : uint 64) <- do (_556 : uint 16) <- Daedalus.BE16
                                                 pure (_556 as uint 64)
     Daedalus._BE16
     @Many[number_of_device_channels] ICC._XYNumber
 
ICC._ColorantOrderType : Grammar {} =
  do ICC._StartTag "clro"
     Daedalus._BE32
     @Many[] @GetByte
 
ICC._Colorant : Grammar {} =
  do Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     @Many[3] Daedalus._BE16
 
ICC._ColorantTableType : Grammar {} =
  do ICC._StartTag "clrt"
     (count_of_colorant : uint 64) <- do (_558 : uint 32) <- Daedalus.BE32
                                         pure (_558 as uint 64)
     @Many[count_of_colorant] ICC._Colorant
 
ICC._ResponseCurve (n : uint 64) : Grammar {} =
  do Daedalus._BE32
     (counts : [uint 32]) <- Many[n] Daedalus.BE32
     @Many[n] ICC._XYNumber
     map ((qi : uint 32) in counts)
       (Many[qi as uint 64] ICC.Response16Number)
     pure {}
 
ICC._ResponseCurveSet16Type : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "rcs2"
     (number_of_channels : uint 64) <- do (_560 : uint 16) <- Daedalus.BE16
                                          pure (_560 as uint 64)
     (count : uint 64) <- do (_561 : uint 16) <- Daedalus.BE16
                             pure (_561 as uint 64)
     @Many[count] do (off : uint 64) <- do (_563 : uint 32) <- Daedalus.BE32
                                           pure (_563 as uint 64)
                     Daedalus._LookAhead ICC.ResponseCurve do Daedalus._SetStreamAt off s
                                                              ICC._ResponseCurve number_of_channels
 
ICC._MeasurementType : Grammar {} =
  do ICC._StartTag "meas"
     Daedalus._BE32
     ICC._XYZNumber
     Daedalus._BE32
     Daedalus._BE32
     Daedalus._BE32
 
ICC._ColorName (m : uint 64) : Grammar {} =
  do Daedalus._Chunk [uint 7] 32 ICC._ASCII7
     @Many[3] Daedalus._BE16
     @Many[m] Daedalus._BE16
 
ICC._NamedColor2Type : Grammar {} =
  do ICC._StartTag "ncl2"
     Daedalus._BE32
     (count : uint 64) <- do (_566 : uint 32) <- Daedalus.BE32
                             pure (_566 as uint 64)
     (number_of_coords : uint 64) <- do (_567 : uint 32) <- Daedalus.BE32
                                        pure (_567 as uint 64)
     Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     Daedalus._Chunk [uint 7] 32 (Daedalus._Only [uint 7] ICC._ASCII7)
     @Many[count] ICC._ColorName number_of_coords
 
ICC._ViewConditionsType : Grammar {} =
  do ICC._StartTag "view"
     ICC._XYZNumber
     ICC._XYZNumber
     Daedalus._BE32
 
ICC._TagStructType : Grammar {} =
  do (s : Stream) <- CurrentStream
     ICC._StartTag "tstr"
     @Many[4] @GetByte
     (n : uint 64) <- do (_568 : uint 32) <- Daedalus.BE32
                         pure (_568 as uint 64)
     @Many[n] do (ent : ICC.TagEntry) <- ICC.TagEntry
                 Daedalus._LookAhead ICC.Tag do SetStream s
                                                ICC._ParseTag ent
 
ICC._ChunkRelativeTo (s : Stream) (off : uint 64) (sz : uint 64) : Grammar {} =
  do Daedalus._SetStreamAt off s
     Daedalus._Bytes sz
