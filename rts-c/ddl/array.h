#ifndef DDL_ARRAY
#define DDL_ARRAY

#include <memory>
#include <ddl/number.h>

namespace DDL {


// Just for debugging to ensure deletions happen
template <typename T>
struct MyDeleter {
  std::default_delete <T[]> d;
  void operator() (T *p) const {
    std::cout << "Deleteing" << std::endl;
    d(p);
  }
};

// Having the size in each node is a bit wasteful, but it is a bit easier
// to match the interface generated by the code generator this way.
template <typename T> struct ArrayCons;
template <typename T> class Array;
template <typename T> using ArrayBuilder = ArrayCons<T> const *;

template <typename T>
size_t arrayBuilderSize(ArrayBuilder<T> xs) { return xs? xs->size : 0; }


template <typename T>
struct ArrayCons
{
  const size_t          size;
  const T               head;
  const ArrayBuilder<T> tail;

  ArrayCons(T v, ArrayBuilder<T> xs)
    : size(1+arrayBuilderSize(xs)), head(v), tail(xs) {}
};



template <typename T>
void buildArray(ArrayBuilder<T> input, Array<T> &out);


template <typename T>
class Array {
  size_t             array_size;
  std::shared_ptr<T> data;
public:

  Array(size_t n, const char *bs) {
    allocate(n);
    DDL::UInt<8> *p = data.get();
      for (size_t i = 0; i < n; ++i) {
        p[i] = DDL::UInt<8>(bs[i]);
      }
  }

  T operator[](size_t i) { return data.get()[i]; }

  size_t size() { return array_size; }

  void allocate(size_t s) {
    array_size = s;
    data = std::shared_ptr<T>(new T[s],MyDeleter<T>());
                                        // std::default_delete<T[]>() );
  }

  template <typename S>
  friend void DDL::buildArray(ArrayBuilder<S> input, Array<S> &out);
};


template <typename T>
static inline
std::ostream& operator<<(std::ostream& os, DDL::Array<T> x) {
  bool first = true;
  os << "[";
  size_t n = x.size();
  for (size_t i = 0; i < n; ++i) {
    if (!first) os << ",";
    os << x[i];
    first = false;
  }
  os << "]";
  return os;
}




template <typename T>
static inline
void buildArray(ArrayBuilder<T> input, Array<T> &out) {
  out.allocate(arrayBuilderSize(input));

  T* output = out.data.get();
  while (input != NULL) {
    output[input->size - 1] = input->head;
    ArrayBuilder<T> next    = input->tail;
    delete input;
    input = next;
  }
}



template <typename T>
class ArrayIterator {
  Array<T> array;
  size_t   index;

public:
  ArrayIterator(Array<T> xs) : array(xs), index(0) {}
  ArrayIterator(Array<T> xs, size_t i) : array(xs), index(i) {}

  bool   done()        { return index >= array.size(); }

  // Assumes !done()
  size_t key()         { return index; }

  // Assumes !done()
  T      value()       { return array[index]; }

  // Assumes !done()
  ArrayIterator next() { return ArrayIterator(array,index+1); }

};


}
#endif
