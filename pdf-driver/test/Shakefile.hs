{-# LANGUAGE PartialTypeSignatures #-}

-- system:
import           Control.Monad
import           Data.Maybe
import           System.Exit

-- shake pkg:
import qualified Development.Shake as Shake
import           Development.Shake         hiding (Timeout)
import           Development.Shake.FilePath
import           Development.Shake.Util


timeoutInSecs:: Int
timeoutInSecs = 5 -- 5*60 -- 5 minutes FIXME

main :: IO ()
main = shakeArgs shakeOptions{shakeFiles="_build"} $ do
  
  want ["all.result-summary"]
  
  phony "clean" $
    do
    putInfo "Cleaning files"
    removeFilesAfter "." ["//*.stdout","//*.stderr","//*.meta"]
    removeFilesAfter "." ["//*.result-actual"
                         ,"all.result-summary"]
    -- FIXME: just delete directory _!
    
  ["//*.stdout","//*.stderr","//*.meta"]
     &%> \[outF,errF,metaF] ->
    do
    let src = outF -<.> ".pdf"
        timeInMs x = round(x * 1000)
    need [src]
    (Exit code, CmdTime t) <-
      command [ Shake.Timeout (fromIntegral timeoutInSecs)
              , WithStdout True
              , WithStderr True
              , EchoStderr True
              , FileStdout outF
              , FileStderr errF
              ]
              "pdf-hs-driver" [src]
    writeFile' metaF
       $ triviallyFormat
       $ show
       $ MetaData code (timeInMs t)

  "//*.result-actual" %> \outF ->
    do
    let metaF = outF -<.> ".meta"
    need [metaF]
    metaC <- readFile' metaF
    let metaD = read metaC :: MetaData
    
    let r = if runtime metaD >= timeoutInSecs*1000 then
              Timeout
            else if exitCode metaD == ExitSuccess then
              Good
            else
              Bad
    writeFile' outF (show r)
      
  "all.result-summary" %> \outF ->
    do
    -- source files:
    let varF = "variances.txt"
    need [varF]
    varianceFiles <- lines <$> readFile' varF
    exps <- getDirectoryFiles "." ["*.result-expctd"]
    need exps

    --  generated files (see FN1 below)
    acts <- liftIO $ getDirectoryFilesIO "." ["*.result-actual"]
    need acts
    
    rs <- forM acts
          $ \actF-> do
                    let inpF = actF -<.> ".pdf"
                        expF = actF -<.> ".result-expctd"
                        varC = inpF `elem` varianceFiles
                    eqv <- liftIO $ filesEqual expF actF
                    return $ case (eqv,varC) of
                      (False,False ) -> Just (inpF, NE_NoVariance)
                      (True ,True  ) -> Just (inpF, Eq_Variance)
                      _              -> Nothing
    let rs' = catMaybes rs
        report = unlines $
                   [ show(length rs) ++ " files"
                   , show(length rs') ++ " problem(s):"
                   , show rs' -- FIXME: improve
                   ]
    putInfo report
    writeFile' outF report

  -- FIXME: name things as an 'isvalid' (not 'result') projection
     -- and abstract over
  -- FIXME: allow for files w/o '.pdf'

  -- FN1:
  --   The getDirectoryFiles operation is tracked by the build system, so if the
  --   files in a directory change the rule will rebuild in the next run. You
  --   should only use getDirectoryFiles on source files, not files that are
  --   generated by the build system, otherwise the results will change while
  --   you are running the build and the build may be inconsistent.
    

filesEqual :: FilePath -> FilePath -> IO Bool
filesEqual fa fb =
  do
  ca <- readFile fa
  cb <- readFile fb
  return (ca == cb)
  
{-
ppProblem 
"Variance When Equal"
"Not Equal, no Variance"
-}

data ErrorType = Eq_Variance
               | NE_NoVariance
               deriving (Eq, Read, Show)

triviallyFormat []     = ""
triviallyFormat (c:cs) =
  if c `elem` "{,}" then
    "\n  " ++ [c] ++ triviallyFormat cs
  else
    c : triviallyFormat cs
 
data Result = Good | Bad | Timeout
              deriving (Eq, Read, Show)  

data MetaData = MetaData { exitCode :: ExitCode
                         , runtime  :: Int
                         }
                deriving (Eq,Show,Read)

{-
main = shakeArgs shakeOptions{shakeFiles="_build"} $ do
    want ["_build/run" <.> exe]

    "_build/run" <.> exe %> \out -> do
        cs <- getDirectoryFiles "" ["//*.c"]
        let os = ["_build" </> c -<.> "o" | c <- cs]
        need os
        cmd_ "gcc -o" [out] os

    "_build//*.o" %> \out -> do
        let c = dropDirectory1 $ out -<.> "c"
        let m = out -<.> "m"
        cmd_ "gcc -c" [c] "-o" [out] "-MMD -MF" [m]
        neededMakefileDependencies m
-}
