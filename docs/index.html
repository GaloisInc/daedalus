
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>DaeDaLus User Guide &#8212; Daedalus 0.1 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="#">Daedalus 0.1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="daedalus-user-guide">
<h1>DaeDaLus User Guide<a class="headerlink" href="#daedalus-user-guide" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<p>DaeDaLus is a domain specific language for specifying parsers.  It supports
data dependent parsing, which allows a parser’s behavior to be affected by
the semantic values parsed from other parts of the input.
This allows for a clear, yet precise, specification of many binary formats.</p>
<div class="section" id="using-the-daedalus-tool">
<h2>Using the <code class="docutils literal notranslate"><span class="pre">daedalus</span></code> Tool<a class="headerlink" href="#using-the-daedalus-tool" title="Permalink to this headline">¶</a></h2>
<div class="section" id="help">
<h3>Help<a class="headerlink" href="#help" title="Permalink to this headline">¶</a></h3>
<p>To see a list of options:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>daedalus --help
</pre></div>
</div>
</div>
<div class="section" id="check-a-specification">
<h3>Check a Specification<a class="headerlink" href="#check-a-specification" title="Permalink to this headline">¶</a></h3>
<p>To type-check a DaeDaLus specification and see the types of the declarations:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>daedalus --show-types MyParserSpec.ddl
</pre></div>
</div>
<p>The resulting types have the following form:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>ParserName:
  parameter: &lt;type A&gt;
  parameter: &lt;type B&gt;
  ...
  defines: &lt;type C&gt;
</pre></div>
</div>
<p>This resembles a C type declaration as follows:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">type</span> <span class="n">C</span><span class="o">&gt;</span> <span class="n">ParserName</span><span class="p">(</span><span class="o">&lt;</span><span class="n">type</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">type</span> <span class="n">B</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
<p>The types themselves may be simple types such as integers or arrays, but they
often have the form <code class="docutils literal notranslate"><span class="pre">parser</span> <span class="pre">of</span> <span class="pre">&lt;type</span> <span class="pre">A&gt;</span></code>. This indicates that the parameter or
result is a parser, that itself generates semantic values of type <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</div>
<div class="section" id="run-the-interpreter">
<h3>Run the Interpreter<a class="headerlink" href="#run-the-interpreter" title="Permalink to this headline">¶</a></h3>
<p>To run interpret a specification on a particular input:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>daedalus MyParserSpec.ddl --interp<span class="o">=</span>input.txt
</pre></div>
</div>
<p>If successful, the resulting semantic value will be shown on <code class="docutils literal notranslate"><span class="pre">stdout</span></code>.
You may also add the flag <code class="docutils literal notranslate"><span class="pre">--json</span></code> or <code class="docutils literal notranslate"><span class="pre">--html</span></code> to see the semantic value
in the corresponding formats.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Document the JSON schema</p>
</div>
</div>
<div class="section" id="compile-to-haskell">
<h3>Compile to Haskell<a class="headerlink" href="#compile-to-haskell" title="Permalink to this headline">¶</a></h3>
<p>To compile a DaeDaLus parser specification to Haskell:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>daedalus MyParserSpec.ddl --compile-hs
</pre></div>
</div>
<p>The result is a Haskell module which contains definitions for the
parsers and functions defined in the specification.   To use the generated
code you’d have to integrate it with a Haskell project and also use
the <code class="docutils literal notranslate"><span class="pre">rts-hs</span></code> package.</p>
</div>
<div class="section" id="compile-to-c">
<h3>Compile to C++<a class="headerlink" href="#compile-to-c" title="Permalink to this headline">¶</a></h3>
<p>To compile a DaeDaLus package specification C++ 17:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>daedalus MyParserSpec.ddl --compile-c++ --out-dir<span class="o">=</span>some_dir_name
</pre></div>
</div>
<p>This will generate a number of C++ files together with a <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> and
a sample driver program in directory <code class="docutils literal notranslate"><span class="pre">some_dir_name</span></code>.
The <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> shows how to build the parser and has an option to
generate Doxygen documentation.</p>
</div>
</div>
<div class="section" id="declarations">
<h2>Declarations<a class="headerlink" href="#declarations" title="Permalink to this headline">¶</a></h2>
<p>A DaeDaLus specification consists of a sequence of <em>declarations</em>.
Each declaration can specify either a <em>parser</em>, a <em>semantic value</em>, or
a <em>character class</em>.  Parsers may examine and consume input, and have
the ability to fail.  If successful, they produce a semantic value.
Character classes describe sets of bytes, which may be used to define
parsers, and will be discussed in more detail in section <a class="reference internal" href="#id1">Character Classes</a>.</p>
<p>The general form of a declarations is as follows:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def Name Parameters = Definition
</pre></div>
</div>
<p>The name of a declaration determines what sort of entity it defines:</p>
<blockquote>
<div><ul class="simple">
<li><strong>parsers</strong> always have names starting with an <strong>uppercase</strong> letter,</li>
<li><strong>semantic values</strong> have names starting with a <strong>lowercase</strong> letter,</li>
<li><strong>character classes</strong> have names starting with the symbol <code class="docutils literal notranslate"><span class="pre">$</span></code>.</li>
</ul>
</div></blockquote>
<p>Here are some sample declarations:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def P   = UInt8       -- a parser named `P`
def x   = true        -- a semantic value named `x`
def $d  = &#39;0&#39; .. &#39;9&#39;  -- a character class named `$d`
</pre></div>
</div>
<p>Single line comments are marked with <code class="docutils literal notranslate"><span class="pre">--</span></code>, while multi-line comment are
enclosed between <code class="docutils literal notranslate"><span class="pre">{-</span></code> and <code class="docutils literal notranslate"><span class="pre">-}</span></code>, and may be nested.</p>
<p>Declarations may be parameterized, and the parameters of a declaration follow
the same rules.  In a declaration with a parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>, the lower case
indicates that the parameter is a semantic value, while <code class="docutils literal notranslate"><span class="pre">P</span></code> (upper case)
would be a grammar parameter, and <code class="docutils literal notranslate"><span class="pre">$p</span></code> a character class parameter.</p>
<p>Consider, for example the following declaration:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def Example n P $q =
  if n &gt; 0
    then P
    else Match1 $q
</pre></div>
</div>
<p>This declares a parser called <code class="docutils literal notranslate"><span class="pre">Example</span></code> with 3 parameters, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">P</span></code> and
<code class="docutils literal notranslate"><span class="pre">$q</span></code>.   Note that the parameters are simply separated by space, and usually
there is no need to provide type annotations as DaeDaLus can infer the types
based on the naming rules and the uses in the definition.</p>
</div>
<div class="section" id="parsers">
<h2>Parsers<a class="headerlink" href="#parsers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="primitive-parsers">
<h3>Primitive Parsers<a class="headerlink" href="#primitive-parsers" title="Permalink to this headline">¶</a></h3>
<p><strong>Any Byte.</strong> The parser <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> extracts a single byte from the input.
It fails if there are no bytes left in the input.  If successful, it constructs
a value of type <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">8</span></code>.</p>
<p><strong>Specific Byte.</strong> The parser <code class="docutils literal notranslate"><span class="pre">Match1</span> <span class="pre">$set</span></code> matches a single byte that
belongs to the set of bytes (also referred to as <em>character class</em>)
described by <code class="docutils literal notranslate"><span class="pre">$set</span></code>.</p>
<p><strong>Specific Byte Sequence.</strong> The parser <code class="docutils literal notranslate"><span class="pre">Match</span> <span class="pre">bytes</span></code> matches the byte
sequence <code class="docutils literal notranslate"><span class="pre">bytes</span></code> in the current input. The resulting semantic value is an
array of bytes, <code class="docutils literal notranslate"><span class="pre">[uint</span> <span class="pre">8]</span></code>, corresponding to the matched bytes.
For example <code class="docutils literal notranslate"><span class="pre">Match</span> <span class="pre">&quot;keyword&quot;</span></code> will match <code class="docutils literal notranslate"><span class="pre">&quot;keyword&quot;</span></code>, while
<code class="docutils literal notranslate"><span class="pre">Match</span> <span class="pre">[0x00,0x01]</span></code> will match two bytes: 0 followed by 1.</p>
<p><strong>End of Input.</strong> The parser <code class="docutils literal notranslate"><span class="pre">END</span></code> succeeds only if there is no more input
to be parsed.  If successful, the result is the trivial semantic value <code class="docutils literal notranslate"><span class="pre">{}</span></code>.
Normally DaeDaLus parsers succeed as long as they match a <em>prefix</em> of the
entire input.  By sequencing (see <a class="reference internal" href="#sequencing-parsers">Sequencing Parsers</a>) a parser with
<code class="docutils literal notranslate"><span class="pre">END</span></code> we specify that the entire input must be matched.</p>
<p><strong>Pure Parsers.</strong> Any semantic value may be turned into a parser that does
not consume any input and always succeeds with the given result.  To do
so prefix the semantic value with the operator <code class="docutils literal notranslate"><span class="pre">^</span></code>.  Thus, <code class="docutils literal notranslate"><span class="pre">^</span> <span class="pre">'A'</span></code> is
a parser that always succeeds and produces byte <code class="docutils literal notranslate"><span class="pre">'A'</span></code> as a result.</p>
<p><strong>Explicit Failure</strong> The <code class="docutils literal notranslate"><span class="pre">Fail</span></code> construct will always fail.  This
parser is parameterized by an optional location, along with an error
message.</p>
<p><strong>Examples:</strong></p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>{- Declaration                      Matches       Result          -}
def GetByte     = UInt8             -- Any byte X X
def TheLetterA  = Match1 &#39;A&#39;        -- Byte 65    65
def TheNumber3  = Match1 (0 .. 5)   -- A byte between 0 to 5
def TheNumber16 = Match1 0x10       -- Byte 16    16
def Magic       = Match &quot;HELLO&quot;     -- &quot;HELLO&quot;    [72,69,76,76,79]
def AlwaysA     = ^ &#39;A&#39;             -- &quot;&quot;         65
def GiveUp      = Fail &quot;I give up&quot;  -- (none)    Failure with message &quot;I give up&quot;
</pre></div>
</div>
</div>
<div class="section" id="sequencing-parsers">
<h3>Sequencing Parsers<a class="headerlink" href="#sequencing-parsers" title="Permalink to this headline">¶</a></h3>
<div class="section" id="basic-sequencing">
<h4>Basic Sequencing<a class="headerlink" href="#basic-sequencing" title="Permalink to this headline">¶</a></h4>
<p>Multiple parsers may be executed one after the other,
by listing them either between <code class="docutils literal notranslate"><span class="pre">{</span></code> and <code class="docutils literal notranslate"><span class="pre">}</span></code> or between <code class="docutils literal notranslate"><span class="pre">[</span></code> and <code class="docutils literal notranslate"><span class="pre">]</span></code>,
and separating them with <code class="docutils literal notranslate"><span class="pre">;</span></code>.  Thus, <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">P;</span> <span class="pre">Q;</span> <span class="pre">R</span> <span class="pre">}</span></code> and <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">P;</span> <span class="pre">Q;</span> <span class="pre">R</span> <span class="pre">]</span></code> are
both composite parsers that will execute <code class="docutils literal notranslate"><span class="pre">P</span></code> , then <code class="docutils literal notranslate"><span class="pre">Q</span></code>, and finally <code class="docutils literal notranslate"><span class="pre">R</span></code>.
If any of the sequenced parsers fails, then the whole sequence fails.</p>
<p>Parsers sequenced with <code class="docutils literal notranslate"><span class="pre">[]</span></code> produce an array, with each element of the
array containing the result of the corresponding parser.
Since all elements in an array have the same type, all parsers sequenced
with <code class="docutils literal notranslate"><span class="pre">[]</span></code> should construct the same type of semantic value.</p>
<p>By default, parsers sequenced with <code class="docutils literal notranslate"><span class="pre">{}</span></code> return the result of the last
parser in the sequence.</p>
<p>Examples:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>{- Declaration                                      Matches        Result-}
def ABC1 = { Match1 &#39;A&#39;; Mathc1 &#39;B&#39;; Match1 &#39;C&#39; }   -- &quot;ABC&quot;       67
def ABC2 = [ Match1 &#39;A&#39;; Match1 &#39;B&#39;; Match1 &#39;C&#39; ]   -- &quot;ABC&quot;       [65,66,67]
def ABC3 = { Match &quot;Hello&quot;; Match &quot;ABC&quot; }           -- &quot;HelloABC&quot;  [65,66,67]
def ABC4 = { Match &quot;Hello&quot;; Match1 &#39;C&#39; }            -- &quot;HelloC&quot;    67
</pre></div>
</div>
<p>An alternative notation for <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">..</span> <span class="pre">}</span></code> parsers is to use the <code class="docutils literal notranslate"><span class="pre">block</span></code> keyword
and <em>layout</em>:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def UseBraces = { Match &quot;A&quot;; Match &quot;B&quot; }
def UseLayout =
  block
    Match &quot;A&quot;
    Match &quot;B&quot;
</pre></div>
</div>
<p>The parsers <code class="docutils literal notranslate"><span class="pre">UseBraces</span></code> and <code class="docutils literal notranslate"><span class="pre">UseLayout</span></code> are the same, just using a
different notation.  When using layout, the entries in the sequence must start
on the same column, and any text that is indented more than that column
belongs to the corresponding parser.  So, the following parser is also
equivalent to the previous two:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def AlsoTheSame =
  block
    Match
      &quot;A&quot;
    Match &quot;B&quot;
</pre></div>
</div>
</div>
<div class="section" id="explicit-result">
<h4>Explicit Result<a class="headerlink" href="#explicit-result" title="Permalink to this headline">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">block</span></code> or <code class="docutils literal notranslate"><span class="pre">{}</span></code>-sequenced group of parsers may
return the result from any member of the group instead of the last one.
To do so, assign the result of the parser to the special variable <code class="docutils literal notranslate"><span class="pre">$$</span></code>.
For example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def ReturnMiddle =
  block
    P
    $$ = Q
    R
</pre></div>
</div>
<p>In the example above, the semantic value produce by <code class="docutils literal notranslate"><span class="pre">ReturnMiddle</span></code> is that
produced by <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
</div>
<div class="section" id="local-variables">
<h4>Local Variables<a class="headerlink" href="#local-variables" title="Permalink to this headline">¶</a></h4>
<p>It is also possible to combine the results of some
of the <code class="docutils literal notranslate"><span class="pre">block/{}</span></code>-sequenced parsers by using <em>local variables</em> and the
pure parser.  Assignments prefixed by the keyword <code class="docutils literal notranslate"><span class="pre">let</span></code> introduce a local
variable, which is in scope in the following parsers.  Here is an example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def Add =
  block
    let x = UInt8
    Match1 &#39;+&#39;
    let y = UInt8
    ^ x + y
</pre></div>
</div>
<p>The parser <code class="docutils literal notranslate"><span class="pre">Add</span></code> is a sequence of 4 parsers.  The local variables <code class="docutils literal notranslate"><span class="pre">x</span></code>
and <code class="docutils literal notranslate"><span class="pre">y</span></code> store the results of the first and the third parser.  The result
of the sequence is the result of the last parser, which does not consume
any input, but only constructs a semantic value by adding <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>
together.</p>
</div>
<div class="section" id="structure-sequence">
<h4>Structure Sequence<a class="headerlink" href="#structure-sequence" title="Permalink to this headline">¶</a></h4>
<p>It is also possible to return results from more than
one of the parsers in a <code class="docutils literal notranslate"><span class="pre">block/{}</span></code>-sequenced group.  To do so give names
to the desired results (<em>without</em> <code class="docutils literal notranslate"><span class="pre">let</span></code>).  The semantic value of the
resulting parser is a structure with fields containing the value of
the correspondingly named parsers.  Consider, for example, the
following declaration:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def S =
  block
    x = UInt8
    y = Match &quot;HELLO&quot;
</pre></div>
</div>
<p>This declaration defines a parser named <code class="docutils literal notranslate"><span class="pre">S</span></code>, which will extract a
byte followed by the sequence <code class="docutils literal notranslate"><span class="pre">&quot;HELLO&quot;</span></code>. The result of this parser is
a <em>structure type</em>, also named <code class="docutils literal notranslate"><span class="pre">S</span></code>, which has two fields, <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>:
<code class="docutils literal notranslate"><span class="pre">x</span></code> is a byte, while <code class="docutils literal notranslate"><span class="pre">y</span></code> is an array of bytes.</p>
<p>Note that structure fields also introduce a local variable with the same name,
so later parsers in the sequence may depend on the semantic values in
earlier parsers in the sequence.  For example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def S1 =
  block
    x = UInt8
    y = block
          let z = UInt8
          ^ x + z
</pre></div>
</div>
<p>The parser <code class="docutils literal notranslate"><span class="pre">S1</span></code> is a sequence of two parsers, whose semantic value
is a structure with two fields, <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.  Both fields have type
<code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">8</span></code>.  The first parser just extracts a byte from input.  The second
parser is itself a sequence: first it extracts a byte from the input,
but its semantic value is the sum of the two extracted bytes.  As another
example, here is an equivalent way to define the same parser:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def S2 =
  block
    x = UInt8
    let z = UInt8
    y = ^ x + z
</pre></div>
</div>
</div>
<div class="section" id="syntactic-sugar">
<h4>Syntactic Sugar<a class="headerlink" href="#syntactic-sugar" title="Permalink to this headline">¶</a></h4>
<p>A number of the constructs described in this section are
may be thought of as simply syntactic sugar for using local variables.
Here are some examples:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Expression:</th>
<th class="head">Equivalent to:</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">$$</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">Q</span> <span class="pre">}</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">let</span> <span class="pre">x</span>&#160; <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">Q;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">^</span> <span class="pre">x</span> <span class="pre">}</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">P;</span> <span class="pre">Q</span> <span class="pre">]</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">let</span> <span class="pre">x0</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">let</span> <span class="pre">x1</span> <span class="pre">=</span> <span class="pre">Q;</span> <span class="pre">^</span> <span class="pre">[x0,x1]</span> <span class="pre">}</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">Q</span> <span class="pre">}</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">let</span> <span class="pre">x</span>&#160; <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">let</span> <span class="pre">y</span>&#160; <span class="pre">=</span> <span class="pre">Q;</span> <span class="pre">^</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x;</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">}</span> <span class="pre">}</span></code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="parsing-alternatives">
<h3>Parsing Alternatives<a class="headerlink" href="#parsing-alternatives" title="Permalink to this headline">¶</a></h3>
<div class="section" id="biased-choice">
<h4>Biased Choice<a class="headerlink" href="#biased-choice" title="Permalink to this headline">¶</a></h4>
<p>Given two parsers <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> we may construct the composite
parser <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&lt;|</span> <span class="pre">Q</span></code>.   This parser succeeds if <em>either</em> <code class="docutils literal notranslate"><span class="pre">P</span></code> <em>or</em> <code class="docutils literal notranslate"><span class="pre">Q</span></code>
succeeds. In the case that <em>both</em> succeed, the parser behaves like <code class="docutils literal notranslate"><span class="pre">P</span></code>.
Note that <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> have to construct semantic values of the same type.</p>
<p>More operationally, <code class="docutils literal notranslate"><span class="pre">P</span></code> would be used to parse the input first,
and only if it fails would we execute <code class="docutils literal notranslate"><span class="pre">Q</span></code> on the same input.  While this
may be a useful intuition about the behavior of this parser, the actual
parsing algorithm might implement this behavior in a different way.</p>
<p>Here are some examples:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>{- Declaration           Matches        Result   -}
def B1 = Match1 &#39;A&#39;   -- &quot;A&quot;            &#39;A&#39;, or
      &lt;| Match1 &#39;B&#39;   -- &quot;B&quot;            &#39;B&#39;

def B2 = Match1 &#39;A&#39;
      &lt;| ^ &#39;B&#39;        -- &quot;A&quot;            &#39;A&#39;, or
                      -- &quot;&quot;             &#39;B&#39;
</pre></div>
</div>
<dl class="docutils">
<dt>These two are quite different:</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal notranslate"><span class="pre">B1</span></code> matches a single byte, either <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> and returns the
matched byte as the result of the parser.</li>
<li><code class="docutils literal notranslate"><span class="pre">B2</span></code> matches either 1 byte, which must be <code class="docutils literal notranslate"><span class="pre">A</span></code> and will be returned
as the result of the parser, or 0 bytes, in which case it will return
byte <code class="docutils literal notranslate"><span class="pre">B</span></code>.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="unbiased-choice">
<h4>Unbiased Choice<a class="headerlink" href="#unbiased-choice" title="Permalink to this headline">¶</a></h4>
<p>Given two parsers <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> we may construct the composite
parser``P | Q``.  This parser succeeds if either <code class="docutils literal notranslate"><span class="pre">P</span></code> or <code class="docutils literal notranslate"><span class="pre">Q</span></code>
succeeds on the given input.   Unlike biased choice, if <em>both</em> succeed,
then the resulting parser is <em>ambiguous</em> for the given input, which means
that input may be parsed in more than one way.  It is possible, however, to
resolve ambiguities by composing (e.g., in sequence) with other parsers.</p>
<p>Here are some examples:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def U1 = Match1 &#39;A&#39; | ^ 0
def U2 = { U1; &#39;B&#39; }
</pre></div>
</div>
<p>Parser <code class="docutils literal notranslate"><span class="pre">U1</span></code> on its own is ambiguous on inputs starting with <code class="docutils literal notranslate"><span class="pre">&quot;A&quot;</span></code> because
it could produce either <code class="docutils literal notranslate"><span class="pre">'A</span></code> (by consuming it from the input),
or <code class="docutils literal notranslate"><span class="pre">0</span></code> (by consuming nothing).  This happens because parsers only need
to match a prefix of the input to succeed.</p>
<p>Parser <code class="docutils literal notranslate"><span class="pre">U2</span></code> accepts inputs starting with either <code class="docutils literal notranslate"><span class="pre">&quot;AB&quot;</span></code> (by using the
left alternative of <code class="docutils literal notranslate"><span class="pre">U1</span></code>) or starting with <code class="docutils literal notranslate"><span class="pre">&quot;B&quot;</span></code> (by using the right
alternative of <code class="docutils literal notranslate"><span class="pre">U1</span></code>).  No inputs are ambiguous in this case.</p>
</div>
<div class="section" id="alternative-syntax">
<h4>Alternative Syntax<a class="headerlink" href="#alternative-syntax" title="Permalink to this headline">¶</a></h4>
<p>Given multiple parsers <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, … we can use the <code class="docutils literal notranslate"><span class="pre">Choose</span></code> keyword
for unbiased choice and <code class="docutils literal notranslate"><span class="pre">Choose1</span></code> for biased choice.</p>
<table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Expression:</th>
<th class="head">Equivalent to:</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">Choose</span> <span class="pre">{</span> <span class="pre">A</span> <span class="pre">;</span> <span class="pre">B;</span> <span class="pre">...}</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">|</span> <span class="pre">B</span> <span class="pre">|</span> <span class="pre">...</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">Choose1</span> <span class="pre">{</span> <span class="pre">A</span> <span class="pre">;</span> <span class="pre">B;</span> <span class="pre">...</span> <span class="pre">}</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&lt;|</span> <span class="pre">B</span> <span class="pre">&lt;|</span> <span class="pre">...</span></code></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">Choose</span></code> and <code class="docutils literal notranslate"><span class="pre">Choose1</span></code> keywords also support <strong>layout</strong>, so instead
of using braces and semi-colons we can just line-up the alternatives like this:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def ChooseWithBraces =
  Choose1 {
    Match1 &#39;A&#39;;
    Match1 &#39;B&#39;;
  }

def ChooseWithLayout =
  Choose1
    Match &#39;A&#39;
    Match &#39;B&#39;
</pre></div>
</div>
</div>
<div class="section" id="tagged-unions">
<h4>Tagged Unions<a class="headerlink" href="#tagged-unions" title="Permalink to this headline">¶</a></h4>
<p>DaeDaLus supports a variation on <code class="docutils literal notranslate"><span class="pre">Choose</span></code> and <code class="docutils literal notranslate"><span class="pre">Choose1</span></code>
that can be used to construct tagged unions, which is useful if
you’d like the semantic value to reflect which of the parsers succeeded,
or if the branches need to return construct results of different types.</p>
<p>For example, the following parser constructs a union with possible tags
<code class="docutils literal notranslate"><span class="pre">good</span></code> and <code class="docutils literal notranslate"><span class="pre">bad</span></code>, depending on whether the input character is
<code class="docutils literal notranslate"><span class="pre">'G'</span></code> or <code class="docutils literal notranslate"><span class="pre">'B'</span></code>.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def BorG =
  Choose
    good = Match1 &#39;G&#39;
    bad  = Match1 &#39;B&#39;
</pre></div>
</div>
<p>This parser works in a similar way to ordinary <code class="docutils literal notranslate"><span class="pre">Choose</span></code> except that if
an alternative succeeds, the resulting semantic value is <em>tagged</em> with
the given tag (e.g., <code class="docutils literal notranslate"><span class="pre">good</span></code> or <code class="docutils literal notranslate"><span class="pre">bad</span></code> and the previous example).  The type
of the semantic value is of a new user-defined type, derived from the name
of the declaration—in the previous example, the result of the parser would
of a newly defined union type called <code class="docutils literal notranslate"><span class="pre">BorG</span></code>.</p>
<p>It is also possible to construct a value if a tagged-union type using
the notation <code class="docutils literal notranslate"><span class="pre">{|</span> <span class="pre">good</span> <span class="pre">=</span> <span class="pre">'G'</span> <span class="pre">|}</span></code>.  For example, an alternative way
to write the previous example is like this:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def AnotherBorG =
  Choose
    block
      let x = Match1 &#39;G&#39;
      ^ {| good = x |}
    block
      let x = Match1 &#39;B&#39;
      ^ {| bad = x |}
</pre></div>
</div>
<p>Note that when using the <code class="docutils literal notranslate"><span class="pre">{|</span> <span class="pre">tag</span> <span class="pre">=</span> <span class="pre">value</span> <span class="pre">|}</span></code> notation, DaeDaLus will try
to infer the type of the tagged union.  If it cannot infer it, it will generate
a new user defined type:  this is the case in the previous example, and so
parser <code class="docutils literal notranslate"><span class="pre">AnotherBorG</span></code> will return values of a newly generated type also
called <code class="docutils literal notranslate"><span class="pre">AnotherBorG</span></code>.</p>
<p>It is important to note that even though <code class="docutils literal notranslate"><span class="pre">BorG</span></code> and <code class="docutils literal notranslate"><span class="pre">AnotherBorG</span></code> have
essentially the same values, these values have distinct types and <strong>cannot</strong>
be freely interchanged.</p>
<p>If we want to make a tagged union value of an existing type, we’d have to
provide a <em>type annotation</em>, unless the type can already be inferred from
the context.   For example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def YetAnotherBorG =
  Choose
    block
      let x = Match1 &#39;G&#39;
      ^ {| good = x |} : BorG
    block
      let x = Match1 &#39;B&#39;
      ^ {| bad = x |}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">BorG</span></code> in the first alternative specifies that we are making a value
of type <code class="docutils literal notranslate"><span class="pre">BorG</span></code>.  Note that we do not need to provide the annotation on the
second alternative because all alternatives in (untagged) <code class="docutils literal notranslate"><span class="pre">Choose</span></code> have
the same type, so DaeDaLus can infer that we are also making a value of
type <code class="docutils literal notranslate"><span class="pre">BorG</span></code>.</p>
</div>
</div>
<div class="section" id="repetition">
<h3>Repetition<a class="headerlink" href="#repetition" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Many</span></code> construct allows the same parser to be run multiple times
in sequence on an incoming data stream, and it returns an array containing
the resulting semantic values.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>block
  $$ = Many (Match1 &#39;7&#39;)
  Match1 &#39;0&#39;
  END
</pre></div>
</div>
<p>This code will successfully parse any stream consisting of multiple <code class="docutils literal notranslate"><span class="pre">7</span></code>
characters, terminated by the <code class="docutils literal notranslate"><span class="pre">0</span></code> character at the end of the stream. For
example, the stream <code class="docutils literal notranslate"><span class="pre">&quot;7770&quot;</span></code> will return the array <code class="docutils literal notranslate"><span class="pre">['7',</span> <span class="pre">'7',</span> <span class="pre">'7']</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Many</span></code> construct optionally takes either a <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">64</span></code> value or an
interval bounded by two <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">64</span></code> values:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Many</span> <span class="pre">n</span> <span class="pre">P</span></code> succeeds if it executes parser <code class="docutils literal notranslate"><span class="pre">P</span></code> exactly <code class="docutils literal notranslate"><span class="pre">n</span></code> times.</li>
<li><code class="docutils literal notranslate"><span class="pre">Many</span> <span class="pre">(i..j)</span> <span class="pre">P</span></code> succeeds if it executes parser <code class="docutils literal notranslate"><span class="pre">P</span></code> at least <code class="docutils literal notranslate"><span class="pre">i</span></code> and
at most <code class="docutils literal notranslate"><span class="pre">j</span></code> times.</li>
<li><code class="docutils literal notranslate"><span class="pre">Many</span></code> also supports lower-bounded intervals <code class="docutils literal notranslate"><span class="pre">Many</span> <span class="pre">(i..)</span> <span class="pre">P</span></code>, and
likewise upper-bounded intervals <code class="docutils literal notranslate"><span class="pre">Many</span> <span class="pre">(..j)</span> <span class="pre">P</span></code>.</li>
</ul>
<p>To avoid spurious backtracking, <code class="docutils literal notranslate"><span class="pre">Many</span></code> will parse any input maximally.
This can have counter-intuitive consequences! For example, the following
code will never succeed:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>block
  Many (Match1 &#39;7&#39;)
  Match1 &#39;7&#39;
</pre></div>
</div>
<p>The call to <code class="docutils literal notranslate"><span class="pre">Many</span></code> will consume all the input characters matching <code class="docutils literal notranslate"><span class="pre">7</span></code>,
meaning that the following <code class="docutils literal notranslate"><span class="pre">Match1</span></code> will always fail. This may be difficult
to spot in situations where two more complex parsers are run in sequence,
the first of which contains an unbounded call to <code class="docutils literal notranslate"><span class="pre">Many</span></code>.</p>
</div>
</div>
<div class="section" id="control-structures">
<h2>Control Structures<a class="headerlink" href="#control-structures" title="Permalink to this headline">¶</a></h2>
<div class="section" id="if-then-else">
<h3>If-then-else<a class="headerlink" href="#if-then-else" title="Permalink to this headline">¶</a></h3>
<p>Booleans may be used to choose between one of two parsers:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>block
  let i = Match1 (&#39;0&#39;..&#39;9&#39;)
  if (i - &#39;0&#39;) &gt; 5
    then Match &#39;X&#39;
    else ^ 7
</pre></div>
</div>
<p>The parser above parses a decimal digit and if it is larger than 5
it will try to match <code class="docutils literal notranslate"><span class="pre">'X'</span></code> from the input, otherwise it will succeed
with semantic value 7.</p>
</div>
<div class="section" id="guards">
<h3>Guards<a class="headerlink" href="#guards" title="Permalink to this headline">¶</a></h3>
<p>Guards provide one way to examine a semantic value, and their general form is:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>expression is shape
</pre></div>
</div>
<p>A guard is a parser that will succeed if the expression has the required shape.</p>
<div class="section" id="boolean-guards">
<h4>Boolean Guards<a class="headerlink" href="#boolean-guards" title="Permalink to this headline">¶</a></h4>
<p>Perhaps the most common guard is on boolean semantic values,
which may be used to control whether parsing should continue. For example,
the following parser uses the guard <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">-</span> <span class="pre">'0')</span> <span class="pre">&gt;</span> <span class="pre">5</span> <span class="pre">is</span> <span class="pre">true</span></code> to continue
parsing (on the given alternative) only for digits larger than 5.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>block
  let i = Match1 (&#39;0&#39;..&#39;9&#39;)
  Choose1
    block
      (i - &#39;0&#39;) &gt; 5 is true
      ^ &quot;input gt 5&quot;
    ^ &quot;input leq 5&quot;
</pre></div>
</div>
<p>So, if <code class="docutils literal notranslate"><span class="pre">p</span></code> is a boolean value, then <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">is</span> <span class="pre">true</span></code> is a parser that
succeeds without consuming input if <code class="docutils literal notranslate"><span class="pre">p</span></code> holds, and fails otherwise.
Similarly, <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">is</span> <span class="pre">false</span></code> is a parser that would succeed only
if <code class="docutils literal notranslate"><span class="pre">p</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="guards-on-maybe">
<h4>Guards on <code class="docutils literal notranslate"><span class="pre">maybe</span></code><a class="headerlink" href="#guards-on-maybe" title="Permalink to this headline">¶</a></h4>
<p>The type <code class="docutils literal notranslate"><span class="pre">maybe</span></code> also supports guards, with two shapes:
<code class="docutils literal notranslate"><span class="pre">just</span></code> and <code class="docutils literal notranslate"><span class="pre">nothing</span></code>.  For example <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">is</span> <span class="pre">just</span></code> is a parser that will
succeed only if <code class="docutils literal notranslate"><span class="pre">e</span></code> is of the shape <code class="docutils literal notranslate"><span class="pre">just</span> <span class="pre">x</span></code> form some <code class="docutils literal notranslate"><span class="pre">x</span></code>.  In that
case the result of the parser would be the value <code class="docutils literal notranslate"><span class="pre">x</span></code>.  Guards that have
no interesting result (e.g., <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">is</span> <span class="pre">true</span></code>) simply return the trivial
value <code class="docutils literal notranslate"><span class="pre">{}</span></code>.</p>
</div>
<div class="section" id="guards-on-tagged-unions">
<h4>Guards on Tagged Unions<a class="headerlink" href="#guards-on-tagged-unions" title="Permalink to this headline">¶</a></h4>
<p>The same notation may be used to examine values of user-defined
union types (see <a class="reference internal" href="#tagged-unions">Tagged Unions</a>)</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>block
  let res = Choose
              good = Match1 &#39;G&#39;
              bad  = Match1 &#39;B&#39;

  Choose

    block
      res is good
      ^ &quot;Success!&quot;

    block
      res is bad
      ^ &quot;Failure!&quot;
</pre></div>
</div>
</div>
</div>
<div class="section" id="case">
<h3>Case<a class="headerlink" href="#case" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">case</span></code> construct provides an alternative method for examining semantic
values. The body of a case expression consists of a list of matches with the
syntax <code class="docutils literal notranslate"><span class="pre">pattern</span> <span class="pre">-&gt;</span> <span class="pre">result</span></code>. For example, the following expression has the same
functionality as the previous example, but avoids the need for backtracking.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>block
  let res = Choose
              good = Match1 &#39;G&#39;
              bad  = Match1 &#39;B&#39;
  case res of
    good -&gt; ^ &quot;Success!&quot;
    bad  -&gt; ^ &quot;Failure!&quot;
</pre></div>
</div>
<p>A case expression can extract the value from a tagged union. In this case, the
match should have the form <code class="docutils literal notranslate"><span class="pre">pattern</span> <span class="pre">var</span> <span class="pre">-&gt;</span> <span class="pre">result</span></code>.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>block
  let res = Choose
              number = Match1 (&#39;0&#39;..&#39;9&#39;)
              letter = Match1 (&#39;a&#39;..&#39;z&#39;)
              other = Match1 Uint8
  case res of
    number n -&gt; ^ (n - &#39;0&#39;)
    letter l -&gt; ^ (l - &#39;a&#39;)
    _        -&gt; Fail &quot;Something went wrong&quot;
</pre></div>
</div>
<p>Here the special pattern <code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">result</span></code> serves as a default, which matches
against any value. Similarly, a pattern of the form <code class="docutils literal notranslate"><span class="pre">pattern</span> <span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">result</span></code>
indicates that the value will not be used in the result.</p>
<p>In a parser expression, case need not be total (i.e. cover all possible
patterns) as any omitted matches will implicitly result in failure and
backtracking. In non-parser contexts, all case expressions are required to be
total.</p>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">It should be true that guards are just syntactic sugar for case</p>
</div>
</div>
<div class="section" id="for-loops">
<h3><code class="docutils literal notranslate"><span class="pre">for</span></code> loops<a class="headerlink" href="#for-loops" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">for</span></code> construct can be used to iterate over collections (arrays
and dictionaries).  A for-loop declares a local variable representing
the accumulated result of the computation, and a variable that is
bound to the elements of the collection.  The body may be a parser, or
a semantic value.  For example, the following expression sums the
values in an array of integers:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>for (val = 0 : int; v in [1,2,3])
  val + v
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">val</span></code> is initially bound to <code class="docutils literal notranslate"><span class="pre">0</span></code>. Each iteration of the loop binds
<code class="docutils literal notranslate"><span class="pre">v</span></code> to the current element of the sequence, then computes the value of the
body, <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">+</span> <span class="pre">v</span></code>. This returned value is the updated value of <code class="docutils literal notranslate"><span class="pre">val</span></code>.</p>
<p>Another way to understand how this works is to see the following expression,
which is the result of one step of evaluation:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>for (val = 1; v in [2, 3])
  val + v
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">for</span></code> supports an alternative form which binds both the index and
value of a collection. For example, the following loop multiplies
each element in the sequence by its index:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>for (val = 0; i,v in [1,2,3])
  val + (i * v)
</pre></div>
</div>
<p>This construct is also useful when iterating over the contents of
dictionaries, where the index is bound to the key.  The following
loop is a parser which fails when the value is less than the key:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>for (val = 0; k,v in d)
  k &lt;= v is true
</pre></div>
</div>
</div>
<div class="section" id="traversing-with-map">
<h3>Traversing with <code class="docutils literal notranslate"><span class="pre">map</span></code><a class="headerlink" href="#traversing-with-map" title="Permalink to this headline">¶</a></h3>
<p>DaeDaLus supports another iteration construct, <code class="docutils literal notranslate"><span class="pre">map</span></code>. This performs an operation on each
element of a sequence, resulting in a sequence of results. For example, the following code
doubles each element in an array:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>map (x in [1:int, 2, 3])
  2 * x
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">map</span></code> construct can be used to parse a sequence of blocks, based on a
sequence of values. For example the following code parses blocks of the form <code class="docutils literal notranslate"><span class="pre">0AAA...</span></code>,
with the number of <code class="docutils literal notranslate"><span class="pre">'A'</span></code> characters dictated by the input sequence.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>map (x in [1, 2, 3]) {
  Match1 &#39;0&#39;;
  Many x (Match1 &#39;A&#39;);
}
</pre></div>
</div>
<p>Just as with <code class="docutils literal notranslate"><span class="pre">for</span></code>, the map construct has an alternative form that includes both
sequence indexes and values:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>map (i,x in [5, 2, 1]) {
  Match1 &#39;0&#39;;
  len       = ^ { index = i, elem = x };
  something = Many x (Match1 &#39;A&#39;);
}
</pre></div>
</div>
</div>
<div class="section" id="commit">
<h3>Commit<a class="headerlink" href="#commit" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">commit</span></code> is an unstable experimental feature and its behavior may change
or it may be removed entirely.</p>
</div>
<p>Normally, at the point a parser fails, DaeDaLus will backtrack to a choice point
and try an alternative parser. The <code class="docutils literal notranslate"><span class="pre">commit</span></code> guard acts as a cut-point and prevents
backtracking. For example, the following code cannot parse the string <code class="docutils literal notranslate"><span class="pre">&quot;AC&quot;</span></code>
because parsing <code class="docutils literal notranslate"><span class="pre">'A'</span></code> and the subsequent <code class="docutils literal notranslate"><span class="pre">commit</span></code> will prevent backtracking
reaching the alternative branch.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>Choose1 {
  { Match1 &#39;A&#39;; commit; Match1 &#39;B&#39; };
  { Match1 &#39;A&#39;; Match1 &#39;C&#39; }  -- Can&#39;t happen
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">try</span></code> construct converts commit failure into parser failure.  A
commit failure will propagate until it hits an enclosing <code class="docutils literal notranslate"><span class="pre">try</span></code>
construct, or until it escapes the top-level definition.</p>
</div>
<div class="section" id="type-annotations">
<h3>Type Annotations<a class="headerlink" href="#type-annotations" title="Permalink to this headline">¶</a></h3>
<p>DaeDaLus declarations and expressions may be annotated with explicit types,
which is useful when type inference fails to infer the type of something,
or to improve the readability of the specification.</p>
<div class="section" id="annotating-an-expression">
<h4>Annotating an Expression<a class="headerlink" href="#annotating-an-expression" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">t</span></code> to specify that expression <code class="docutils literal notranslate"><span class="pre">e</span></code> should have type <code class="docutils literal notranslate"><span class="pre">t</span></code>.
For example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def i_am_a_byte = 1 : uint 8
</pre></div>
</div>
<p>Note that without the type annotation on the expression <code class="docutils literal notranslate"><span class="pre">1</span></code> the
resulting declaration would be polymorphic because literals are overloaded
and may be used at many different types.</p>
</div>
<div class="section" id="annotating-the-result-of-a-declaration">
<h4>Annotating the Result of a Declaration<a class="headerlink" href="#annotating-the-result-of-a-declaration" title="Permalink to this headline">¶</a></h4>
<p>To specify the result type of a declaration use <code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">t</span></code> after the name
(or the parameters, if any) of the declaration like this:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def also_byte : uint 8 = 1

def returns_byte x : uint 8 = x
</pre></div>
</div>
</div>
<div class="section" id="annotating-a-parameter">
<h4>Annotating a Parameter<a class="headerlink" href="#annotating-a-parameter" title="Permalink to this headline">¶</a></h4>
<p>Parameters of declarations may also be annotated with a type:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def Example (P : uint 8) = P
</pre></div>
</div>
<p>The previous example specifies that parameter <code class="docutils literal notranslate"><span class="pre">P</span></code> is a parser that
will construct a <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">8</span></code> semantic value.</p>
</div>
<div class="section" id="naming-unknown-types">
<h4>Naming Unknown Types<a class="headerlink" href="#naming-unknown-types" title="Permalink to this headline">¶</a></h4>
<p>Occasionally it is useful to name a type without specifying it explicitly.
For example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def f (x : maybe a) = 1 : a
</pre></div>
</div>
<p>In the previous example we assume that <code class="docutils literal notranslate"><span class="pre">a</span></code> is not the name of any type
that is in scope.  The type annotation <code class="docutils literal notranslate"><span class="pre">maybe</span> <span class="pre">a</span></code> specifies that the input
should be of type <code class="docutils literal notranslate"><span class="pre">maybe</span> <span class="pre">a</span></code> for <em>some</em> type <code class="docutils literal notranslate"><span class="pre">a</span></code> that we can refer to
using the name <code class="docutils literal notranslate"><span class="pre">a</span></code>, as we do in the body.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>This feature is a bit error prone and may change in the future.
Common problems are:</p>
<ol class="last arabic simple">
<li><dl class="first docutils">
<dt>Modifying the specification to define type <code class="docutils literal notranslate"><span class="pre">a</span></code> changes the</dt>
<dd>meaning of a seemingly unrelated declarations</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Mistyping the name of a type could make you think that you’ve</dt>
<dd>specified the type, but in fact you just named it.</dd>
</dl>
</li>
</ol>
</div>
</div>
</div>
<div class="section" id="coercions">
<h3>Coercions<a class="headerlink" href="#coercions" title="Permalink to this headline">¶</a></h3>
<p>Coercions provide a way to change a semantic value into the corresponding value
of a different type. The general form is <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">as</span> <span class="pre">T</span></code>, which converts the value of
expression <code class="docutils literal notranslate"><span class="pre">e</span></code> into type <code class="docutils literal notranslate"><span class="pre">T</span></code>. For example, the following code will parse
a byte and pad the resulting value out to a 32-bit unsigned integer.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>block
  let i = UInt8
  ^ i as uint 32
</pre></div>
</div>
<p>The base form <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">as</span> <span class="pre">T</span></code> statically checks that the resulting type has
enough bits to losslessly represent the original value. There are two other
forms, <code class="docutils literal notranslate"><span class="pre">as!</span></code> and <code class="docutils literal notranslate"><span class="pre">as?</span></code> that can be used when this does not hold true
statically:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">as!</span> <span class="pre">T</span></code> is guaranteed to succeed, but may lose information.
In the case that the original value fits into the target type, the behaviour
coincides with the lossless version of <code class="docutils literal notranslate"><span class="pre">as</span></code>. Otherwise, behaviour is
implementation dependent, but will attempt to do something reasonable.</li>
<li><code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">as?</span> <span class="pre">T</span></code> performs a run-time check that the coercion will not lose
information. If this holds, behaviour is identical to the lossless version of
<code class="docutils literal notranslate"><span class="pre">as</span></code>. Otherwise, the coercion fails and backtracks.</li>
</ul>
<p>Note that <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">as</span> <span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">as</span> <span class="pre">T</span></code> are values, and <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">as?</span> <span class="pre">T</span></code> is a parser.
This is because <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">as?</span> <span class="pre">T</span></code> can fail and backtrack, which is only meaningful
in parser expressions.</p>
</div>
</div>
<div class="section" id="semantic-values">
<h2>Semantic Values<a class="headerlink" href="#semantic-values" title="Permalink to this headline">¶</a></h2>
<p>If successful, a parser produces a semantic value, which describes the
input in some way useful to the application invoking the parser.
In addition, semantic values may be used to control how other parts of the
input are to be parsed.  DaeDaLus has a number of built-in semantic values
types, and allows for user-defined record and union types.</p>
<div class="section" id="booleans">
<h3>Booleans<a class="headerlink" href="#booleans" title="Permalink to this headline">¶</a></h3>
<p>The type <code class="docutils literal notranslate"><span class="pre">bool</span></code> classifies the usual boolean values <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>The operator <code class="docutils literal notranslate"><span class="pre">!</span></code> may be used to negate a boolean value.
The operators <code class="docutils literal notranslate"><span class="pre">||</span></code> and <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> are for (short-circuiting) “or” and “and”
respectively.</p>
<p>Boolean values may be compared for equality using <code class="docutils literal notranslate"><span class="pre">==</span></code> and are ordered
with <code class="docutils literal notranslate"><span class="pre">false</span> <span class="pre">&lt;</span> <span class="pre">true</span></code>.</p>
<p>Decisions on a boolean may be made either using <a class="reference internal" href="#if-then-else">If-then-else</a>, by
using <a class="reference internal" href="#guards">Guards</a>, or by using <a class="reference internal" href="#case">Case</a>.</p>
</div>
<div class="section" id="numeric-types">
<h3>Numeric Types<a class="headerlink" href="#numeric-types" title="Permalink to this headline">¶</a></h3>
<p>DaeDaLus supports a variety of numeric types: <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">N</span></code>, and
<code class="docutils literal notranslate"><span class="pre">sint</span> <span class="pre">N</span></code>, the latter two being families of types indexed by a number.
The type <code class="docutils literal notranslate"><span class="pre">int</span></code> classifies integers of arbitrary size.
The <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">N</span></code> classify unsigned numbers that can be represented using <code class="docutils literal notranslate"><span class="pre">N</span></code>
bits and <code class="docutils literal notranslate"><span class="pre">sint</span> <span class="pre">N</span></code> is for signed numbers that can be represented
in <code class="docutils literal notranslate"><span class="pre">N</span></code> bits.</p>
<div class="section" id="numeric-literals">
<h4>Numeric Literals<a class="headerlink" href="#numeric-literals" title="Permalink to this headline">¶</a></h4>
<p>Literals of the numeric types may written either using decimal or hexadecimal
notation (e.g., <code class="docutils literal notranslate"><span class="pre">10</span></code> or <code class="docutils literal notranslate"><span class="pre">0xA</span></code>).  The type of a literal can be inferred
from the context (e.g., <code class="docutils literal notranslate"><span class="pre">10</span></code> can be used as both <code class="docutils literal notranslate"><span class="pre">int</span></code> a <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">8</span></code>).</p>
</div>
<div class="section" id="comparisons">
<h4>Comparisons<a class="headerlink" href="#comparisons" title="Permalink to this headline">¶</a></h4>
<p>Numeric types can also be compared for equality, using <code class="docutils literal notranslate"><span class="pre">==</span></code> and ordering
using <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>.</p>
</div>
<div class="section" id="basic-arithmetic">
<h4>Basic Arithmetic<a class="headerlink" href="#basic-arithmetic" title="Permalink to this headline">¶</a></h4>
<p>Numeric types support basic arithmetic: addition, subtraction,
multiplication, division, and modulus using the usual operators
<code class="docutils literal notranslate"><span class="pre">+</span></code>,``-<code class="docutils literal notranslate"><span class="pre">,``*</span></code>,``/<code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">and</span> <span class="pre">``%</span></code>.</p>
</div>
<div class="section" id="bitwise-operations">
<h4>Bitwise Operations<a class="headerlink" href="#bitwise-operations" title="Permalink to this headline">¶</a></h4>
<p>DaeDaLus also supports shift operations <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>.
These operations are overloaded and can be used on all numeric types,
with the restriction that the inputs and the outputs must be of the
same type.  The shift amount is a value of type <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">64</span></code>.</p>
<p>Unsigned integers may also be treated as bit-vectors, and support various
bitwise operations:</p>
<ul class="simple">
<li>complement: <code class="docutils literal notranslate"><span class="pre">~</span></code></li>
<li>exclusive-or <code class="docutils literal notranslate"><span class="pre">.^.</span></code></li>
<li>and bitwise-and <code class="docutils literal notranslate"><span class="pre">.&amp;.</span></code>.</li>
</ul>
<p>Unsigned numbers can also be appended to other numbers via the
<code class="docutils literal notranslate"><span class="pre">#</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;#</span></code> operator.  To see the difference between the two,
consider two bitvectors <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">uint</span> <span class="pre">A)</span></code> and <code class="docutils literal notranslate"><span class="pre">(y</span> <span class="pre">:</span> <span class="pre">uint</span> <span class="pre">B)</span></code>.
The result of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">#</span> <span class="pre">y</span></code> is a bitvector of type <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span></code> with
<code class="docutils literal notranslate"><span class="pre">x</span></code> in the more significant bits, and <code class="docutils literal notranslate"><span class="pre">y</span></code> in the less significant bits.
The result of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;#</span> <span class="pre">y</span></code> is a bitvector of type <code class="docutils literal notranslate"><span class="pre">A</span></code> that contains
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">#</span> <span class="pre">y</span></code> but truncated to the <code class="docutils literal notranslate"><span class="pre">A</span></code> less significant bits.</p>
</div>
</div>
<div class="section" id="maybe-type">
<h3><code class="docutils literal notranslate"><span class="pre">maybe</span></code> type<a class="headerlink" href="#maybe-type" title="Permalink to this headline">¶</a></h3>
<p>DaeDaLus supports the special polymorphic type <code class="docutils literal notranslate"><span class="pre">maybe</span> <span class="pre">A</span></code>, which has possible
values <code class="docutils literal notranslate"><span class="pre">nothing</span></code> and <code class="docutils literal notranslate"><span class="pre">just</span> <span class="pre">x</span></code>, for some value, <code class="docutils literal notranslate"><span class="pre">x</span></code> of type <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>The parser <code class="docutils literal notranslate"><span class="pre">Optional</span> <span class="pre">P</span></code> will try to parse the input using and produce
a <code class="docutils literal notranslate"><span class="pre">maybe</span></code> value.  If <code class="docutils literal notranslate"><span class="pre">P</span></code> succeeds with result <code class="docutils literal notranslate"><span class="pre">x</span></code> then
<code class="docutils literal notranslate"><span class="pre">Optional</span> <span class="pre">P</span></code> will succeed with <code class="docutils literal notranslate"><span class="pre">just</span> <span class="pre">x</span></code>, and if <code class="docutils literal notranslate"><span class="pre">P</span></code> fails, then
<code class="docutils literal notranslate"><span class="pre">Optional</span> <span class="pre">P</span></code> will <em>succeed</em> with <code class="docutils literal notranslate"><span class="pre">nothing</span></code>.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def MaybeLetter = Optional (Match1 (&#39;A&#39;..&#39;Z&#39;))
</pre></div>
</div>
<p>To examine values of the <code class="docutils literal notranslate"><span class="pre">maybe</span></code> type you may use <a class="reference internal" href="#guards">Guards</a> or <a class="reference internal" href="#case">Case</a>.</p>
</div>
<div class="section" id="arrays">
<h3>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h3>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">Describe the interface to <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">el_type</span> <span class="pre">]</span></code></p>
</div>
</div>
<div class="section" id="association-maps">
<h3>Association Maps<a class="headerlink" href="#association-maps" title="Permalink to this headline">¶</a></h3>
<div class="admonition-todo admonition" id="index-3">
<p class="first admonition-title">Todo</p>
<p class="last">Describe the interface to <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">key</span> <span class="pre">-&gt;</span> <span class="pre">value</span> <span class="pre">]</span></code></p>
</div>
</div>
</div>
<div class="section" id="stream-manipulation">
<h2>Stream manipulation<a class="headerlink" href="#stream-manipulation" title="Permalink to this headline">¶</a></h2>
<p>DaeDaLus parsers operate on an <em>input stream</em>, which by default is the input
data to the parser. However, the input stream can be manipulated directly. For example,
we can write a parser function which runs two different parsers on the same stream.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def ParseTwice P1 P2 =
  block
    let cur = GetStream
    p1result = P1
    SetStream cur
    p2result = P2
</pre></div>
</div>
<p>By manipulating the stream, we can also run a parser on a fixed-size sub-stream.
The following parser parses a size-n chunk which begins with a sequence of
letters, and then is filled with spaces:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def LetterFill n =
  block
    let cur  = GetStream
    let this = Take n cur
    let next = Drop n cur
    SetStream this
    $$ = block
           $$ = Many (Match1 (&#39;A&#39;..&#39;Z&#39;))
           Many (Match1 &#39; &#39;)
           END
    SetStream next
</pre></div>
</div>
<p>It is also possible to directly access the current position in the stream using
<code class="docutils literal notranslate"><span class="pre">Offset</span></code>. This can be used to calculate how many characters were read by a
particular parser:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def OffsetTest = {
    a = Offset;
    Match &quot;AA&quot;;
    b = Offset;
    Match &quot;AAA&quot;;
    c = Offset;
}
-- Result: { a:0, b:2, c:5 }
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">arrayStream</span></code> operator converts an array into a stream:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def CatStream a b = {
    SetStream (arrayStream (concat [a, b]));
    Match &quot;AA&quot;;
    Match &quot;BBB&quot;;
    ^ {}
}
</pre></div>
</div>
<p>This example will succeed if the concatenation of the arrays <code class="docutils literal notranslate"><span class="pre">a</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span></code> starts with the string <code class="docutils literal notranslate"><span class="pre">&quot;AABBB&quot;</span></code>.</p>
</div>
<div class="section" id="character-classes">
<span id="id1"></span><h2>Character Classes<a class="headerlink" href="#character-classes" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="external-declarations">
<h2>External Declarations<a class="headerlink" href="#external-declarations" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="bitdata">
<h2>Bitdata<a class="headerlink" href="#bitdata" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">bitdata</span></code> construct provides a convenient way to break bytes into
groups of bits, which are then combined into a tagged union.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>bitdata ChooseOption where
  opt1 = 0x0 : uint 4
  opt2 = 0x1

bitdata OptionData where
  OptionData = { opt : ChooseOption, val : uint 4 }
</pre></div>
</div>
<p>Bitdata definitions are not parsers, but rather are used by applying coercions to
already parsed bytes. The following code parses a byte, and then checks that the
first four bits select the correct option.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>block
  let odat = UInt8 as? OptionData
  case odat of
    OptionData x -&gt;
      case x.opt of
        opt1 -&gt; ^ x.val
        _    -&gt; Fail &quot;Wrong option&quot;
</pre></div>
</div>
<p>Note that the coercion may fail if the parsed byte does not contain either
<code class="docutils literal notranslate"><span class="pre">0x0</span></code> or <code class="docutils literal notranslate"><span class="pre">0x1</span></code> in its first four bits. In this case, the parser will
backtrack.</p>
</div>
<div class="section" id="implicit-lifting">
<h2>Implicit Lifting<a class="headerlink" href="#implicit-lifting" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="implicit-parameters">
<h2>Implicit Parameters<a class="headerlink" href="#implicit-parameters" title="Permalink to this headline">¶</a></h2>
<p>An <em>implicit parameter</em> is a parameter that is automatically
passed along by the system, which helps avoid clutter in specifications.
In DaeDaLus, implicit parameters have names staring with <code class="docutils literal notranslate"><span class="pre">?</span></code>, for example
<code class="docutils literal notranslate"><span class="pre">?bigendian</span></code>.</p>
<p>Implicit parameters are useful in situations where the value of a parameter
is set once for a given scope, and then the same parameter is just passed
along with no changes to the “leaves” of the specification.   This is quite
common in situations where some configuration options are read once, and then
are just passed along for the rest of a parser.</p>
<p>Here is an example of a function that uses an implicit parameter to concatenate
two bit vectors one way or another:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def joinWords a b =
  if ?bigendian     -- ?bigendian is an implicit parameter
    then a # b
    else b # a
</pre></div>
</div>
<p>Parsers automatically inherit the implicit parameters needed by functions
or parsers they use.  For example, here are two parsers that can be used
to parse either big-endian or little-endian words, depending on the value
of the implicit parameter <code class="docutils literal notranslate"><span class="pre">?bigendian</span></code>:</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">These parsers use <a class="reference internal" href="#implicit-lifting">Implicit Lifting</a> to make them more readable</p>
</div>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def Word16 = joinWords UInt8 UInt8
def Word32 = joinWords Word16 Word16
</pre></div>
</div>
<p>If a <code class="docutils literal notranslate"><span class="pre">block</span></code> provides a value for an implicit parameter, then all calls
for the rest of the block will use that value for the parameter.  For example,
<code class="docutils literal notranslate"><span class="pre">BEWord16</span></code> <em>does not</em> have an implicit parameter:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def BEWord16 =
  block
    let ?bigendian = true
    Word16    -- `?bigendian` has the value `true`
</pre></div>
</div>
<p>It is possible to use different values for the same implicit parameter,
as illustrated by the following example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span>def Example =
  block
    -- Just for testing, we set the input stream to a known value
    SetStream (arrayStream (concat [ [0,1,0,0,0,1]
                                   , [1,0,1,0,0,0] ]))

    big =
      -- Here we define the value of an implicit parameter
      -- in all uses for the rest of the block
      block
        let ?bigendian = true
        x = Word16
        y = Word32
    little =
      -- This block uses a different value for the implicit parameter
      block
        let ?bigendian = false
        x = Word16
        y = Word32
</pre></div>
</div>
<p>Executing <code class="docutils literal notranslate"><span class="pre">Example</span></code> results in the following output:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">{</span> big: <span class="o">{</span> x: <span class="m">1</span><span class="o">[</span><span class="m">16</span><span class="o">]</span>
       , y: <span class="m">1</span><span class="o">[</span><span class="m">32</span><span class="o">]</span>
       <span class="o">}</span>
, little: <span class="o">{</span> x: <span class="m">1</span><span class="o">[</span><span class="m">16</span><span class="o">]</span>
          , y: <span class="m">1</span><span class="o">[</span><span class="m">32</span><span class="o">]</span>
          <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">DaeDaLus User Guide</a><ul>
<li><a class="reference internal" href="#using-the-daedalus-tool">Using the <code class="docutils literal notranslate"><span class="pre">daedalus</span></code> Tool</a><ul>
<li><a class="reference internal" href="#help">Help</a></li>
<li><a class="reference internal" href="#check-a-specification">Check a Specification</a></li>
<li><a class="reference internal" href="#run-the-interpreter">Run the Interpreter</a></li>
<li><a class="reference internal" href="#compile-to-haskell">Compile to Haskell</a></li>
<li><a class="reference internal" href="#compile-to-c">Compile to C++</a></li>
</ul>
</li>
<li><a class="reference internal" href="#declarations">Declarations</a></li>
<li><a class="reference internal" href="#parsers">Parsers</a><ul>
<li><a class="reference internal" href="#primitive-parsers">Primitive Parsers</a></li>
<li><a class="reference internal" href="#sequencing-parsers">Sequencing Parsers</a><ul>
<li><a class="reference internal" href="#basic-sequencing">Basic Sequencing</a></li>
<li><a class="reference internal" href="#explicit-result">Explicit Result</a></li>
<li><a class="reference internal" href="#local-variables">Local Variables</a></li>
<li><a class="reference internal" href="#structure-sequence">Structure Sequence</a></li>
<li><a class="reference internal" href="#syntactic-sugar">Syntactic Sugar</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parsing-alternatives">Parsing Alternatives</a><ul>
<li><a class="reference internal" href="#biased-choice">Biased Choice</a></li>
<li><a class="reference internal" href="#unbiased-choice">Unbiased Choice</a></li>
<li><a class="reference internal" href="#alternative-syntax">Alternative Syntax</a></li>
<li><a class="reference internal" href="#tagged-unions">Tagged Unions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#repetition">Repetition</a></li>
</ul>
</li>
<li><a class="reference internal" href="#control-structures">Control Structures</a><ul>
<li><a class="reference internal" href="#if-then-else">If-then-else</a></li>
<li><a class="reference internal" href="#guards">Guards</a><ul>
<li><a class="reference internal" href="#boolean-guards">Boolean Guards</a></li>
<li><a class="reference internal" href="#guards-on-maybe">Guards on <code class="docutils literal notranslate"><span class="pre">maybe</span></code></a></li>
<li><a class="reference internal" href="#guards-on-tagged-unions">Guards on Tagged Unions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#case">Case</a></li>
<li><a class="reference internal" href="#for-loops"><code class="docutils literal notranslate"><span class="pre">for</span></code> loops</a></li>
<li><a class="reference internal" href="#traversing-with-map">Traversing with <code class="docutils literal notranslate"><span class="pre">map</span></code></a></li>
<li><a class="reference internal" href="#commit">Commit</a></li>
<li><a class="reference internal" href="#type-annotations">Type Annotations</a><ul>
<li><a class="reference internal" href="#annotating-an-expression">Annotating an Expression</a></li>
<li><a class="reference internal" href="#annotating-the-result-of-a-declaration">Annotating the Result of a Declaration</a></li>
<li><a class="reference internal" href="#annotating-a-parameter">Annotating a Parameter</a></li>
<li><a class="reference internal" href="#naming-unknown-types">Naming Unknown Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coercions">Coercions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#semantic-values">Semantic Values</a><ul>
<li><a class="reference internal" href="#booleans">Booleans</a></li>
<li><a class="reference internal" href="#numeric-types">Numeric Types</a><ul>
<li><a class="reference internal" href="#numeric-literals">Numeric Literals</a></li>
<li><a class="reference internal" href="#comparisons">Comparisons</a></li>
<li><a class="reference internal" href="#basic-arithmetic">Basic Arithmetic</a></li>
<li><a class="reference internal" href="#bitwise-operations">Bitwise Operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#maybe-type"><code class="docutils literal notranslate"><span class="pre">maybe</span></code> type</a></li>
<li><a class="reference internal" href="#arrays">Arrays</a></li>
<li><a class="reference internal" href="#association-maps">Association Maps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stream-manipulation">Stream manipulation</a></li>
<li><a class="reference internal" href="#character-classes">Character Classes</a></li>
<li><a class="reference internal" href="#external-declarations">External Declarations</a></li>
<li><a class="reference internal" href="#bitdata">Bitdata</a></li>
<li><a class="reference internal" href="#implicit-lifting">Implicit Lifting</a></li>
<li><a class="reference internal" href="#implicit-parameters">Implicit Parameters</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="#">Daedalus 0.1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, The Daedalus Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>