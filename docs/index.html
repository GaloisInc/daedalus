
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>DaeDaLus User Guide &#8212; Daedalus 0.1 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="#">Daedalus 0.1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="daedalus-user-guide">
<h1>DaeDaLus User Guide<a class="headerlink" href="#daedalus-user-guide" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<p>DaeDaLus is a language for specifying parsers with data dependencies,
which allows a parser’s behavior to be affected by the semantic values
parsed from other parts of the inputs.  This allows a clear, yet precise,
specification of many binary formats.</p>
<div class="section" id="declarations">
<h2>Declarations<a class="headerlink" href="#declarations" title="Permalink to this headline">¶</a></h2>
<p>A Daedalus specification consists of a sequence of <em>declarations</em>.
Each declaration can specify either a <em>parser</em>, a <em>semantic value</em>, or
a <em>character class</em>.  Parsers may examine and consume input, and have
the ability to fail.  If successful, they produce a semantic value.
Character classes describe sets of bytes, which may be used to define
parsers, and will be discussed in more detail <a class="reference internal" href="#character-classes">later</a>.</p>
<p>The general form of a declarations is as follows:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def Name Parameters = Definition
</pre></div>
</div>
<p>The name of a declaration determines what sort of entity it defines:</p>
<blockquote>
<div><ul class="simple">
<li><strong>parsers</strong> always have names starting with an <strong>uppercase</strong> letter,</li>
<li><strong>semantic values</strong> have names starting with a <strong>lowercase</strong> letter,</li>
<li><strong>character classes</strong> have names starting with the symbol <code class="docutils literal notranslate"><span class="pre">$</span></code>.</li>
</ul>
</div></blockquote>
<p>Here are some sample declarations:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def P   = UInt8       -- a parser named `P`
def x   = true        -- a semantic value named `x`
def $d  = &#39;0&#39; .. &#39;9&#39;  -- a character class named `$d`
</pre></div>
</div>
<p>Single line comments are marked with <code class="docutils literal notranslate"><span class="pre">--</span></code>, while multi-line comment are
enclosed between <code class="docutils literal notranslate"><span class="pre">{-</span></code> and <code class="docutils literal notranslate"><span class="pre">-}</span></code>, and may be nested.</p>
</div>
<div class="section" id="parsers">
<h2>Parsers<a class="headerlink" href="#parsers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="primitive-parsers">
<h3>Primitive Parsers<a class="headerlink" href="#primitive-parsers" title="Permalink to this headline">¶</a></h3>
<p><strong>Any Byte.</strong> The parser <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> extracts a single byte from the input.
It fails if there are no bytes left in the input.  If successful, it constructs
a value of type <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">8</span></code>.</p>
<p><strong>Specific Byte.</strong> The parser <code class="docutils literal notranslate"><span class="pre">Match1</span> <span class="pre">$set</span></code> matches a single byte that
belongs to the set of bytes described by <code class="docutils literal notranslate"><span class="pre">$set</span></code>.</p>
<p><strong>Specific Byte Sequence.</strong> The parser <code class="docutils literal notranslate"><span class="pre">Match</span> <span class="pre">bytes</span></code> matches the byte
sequence <code class="docutils literal notranslate"><span class="pre">bytes</span></code> in the current input. The resulting semantic value is an
array of bytes, <code class="docutils literal notranslate"><span class="pre">[uint</span> <span class="pre">8]</span></code>, correspnding to the matched bytes.
For example <code class="docutils literal notranslate"><span class="pre">Match</span> <span class="pre">&quot;keyword&quot;</span></code> will match <code class="docutils literal notranslate"><span class="pre">&quot;keyword&quot;</span></code>, while
<code class="docutils literal notranslate"><span class="pre">Match</span> <span class="pre">[0x00,0x01]</span></code> will match two bytes, 0 followed by 1.</p>
<p><strong>End of Input.</strong> The parser <code class="docutils literal notranslate"><span class="pre">END</span></code> succeeds only if there is no more input
to be parsed.  If successful, the result is the trivial semantic value <code class="docutils literal notranslate"><span class="pre">{}</span></code>.
Normally Daedalus parsers succeed as long as they match a <em>prefix</em> of the
entire input.  By sequencing (section <a class="reference internal" href="#sequencing-parsers">Sequencing Parsers</a>) a parser with
<code class="docutils literal notranslate"><span class="pre">END</span></code> we specify that the entire input must be matched.</p>
<p><strong>Pure Parsers.</strong> Any semantic value may be turned into a parser that does
not consume any input and always succeeds with the given result.  To do
so prefix the semantic value with the operator <code class="docutils literal notranslate"><span class="pre">^</span></code>.  Thus, <code class="docutils literal notranslate"><span class="pre">^</span> <span class="pre">'A'</span></code> is
a parser that always succeeds and produces byte <code class="docutils literal notranslate"><span class="pre">'A'</span></code> as a result.</p>
<p><strong>Explicit Failure</strong> The <code class="docutils literal notranslate"><span class="pre">Fail</span></code> construct will always fail.  This
parser is parameterized by an optional location, along with an error
message.</p>
<p><strong>Examples:</strong></p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>{- Declaration                      Matches       Result          -}
def GetByte     = UInt8             -- Any byte X X
def TheLetterA  = Match1 &#39;A&#39;        -- Byte 65    65
def TheNumber3  = Match1 (0 .. 5)   -- A byte between 0 to 5
def TheNumber16 = Match1 0x10       -- Byte 16    16
def Magic       = Match &quot;HELLO&quot;     -- &quot;HELLO&quot;    [72,69,76,76,79]
def AlwaysA     = ^ &#39;A&#39;             -- &quot;&quot;         65
def GiveUp      = Fail &quot;I give up&quot;  -- (none)    Failure with message &quot;I give up&quot;
</pre></div>
</div>
</div>
<div class="section" id="sequencing-parsers">
<h3>Sequencing Parsers<a class="headerlink" href="#sequencing-parsers" title="Permalink to this headline">¶</a></h3>
<p><strong>Basic Sequencing.</strong> Multiple parsers may be executed one after the other,
by listing them either between <code class="docutils literal notranslate"><span class="pre">{</span></code> and <code class="docutils literal notranslate"><span class="pre">}</span></code> or between <code class="docutils literal notranslate"><span class="pre">[</span></code> and <code class="docutils literal notranslate"><span class="pre">]</span></code>,
and separating them with <code class="docutils literal notranslate"><span class="pre">;</span></code>.  Thus, <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">P;</span> <span class="pre">Q;</span> <span class="pre">R</span> <span class="pre">}</span></code> and <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">P;</span> <span class="pre">Q;</span> <span class="pre">R</span> <span class="pre">]</span></code> are
both composite parsers that will execute <code class="docutils literal notranslate"><span class="pre">P</span></code> , then <code class="docutils literal notranslate"><span class="pre">Q</span></code>, and finally <code class="docutils literal notranslate"><span class="pre">R</span></code>.
If any of the sequenced parsers fails, then the whole sequence fails.</p>
<p>Parsers sequenced with <code class="docutils literal notranslate"><span class="pre">[]</span></code> produce an array, with each element of the
array containing the result of the corresponding parser.
Since all elements in an array have the same type, all parsers sequenced
with <code class="docutils literal notranslate"><span class="pre">[]</span></code> should construct the same type of semantic value.</p>
<p>By default, parsers sequenced with <code class="docutils literal notranslate"><span class="pre">{}</span></code> return the result of the last
parser in the sequence.</p>
<p>Examples:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>{- Declaration                                      Matches        Result-}
def ABC1 = { Match1 &#39;A&#39;; Mathc1 &#39;B&#39;; Match1 &#39;C&#39; }   -- &quot;ABC&quot;       67
def ABC2 = [ Match1 &#39;A&#39;; Match1 &#39;B&#39;; Match1 &#39;C&#39; ]   -- &quot;ABC&quot;       [65,66,67]
def ABC3 = { Match &quot;Hello&quot;; Match &quot;ABC&quot; }           -- &quot;HelloABC&quot;  [65,66,67]
def ABC4 = { Match &quot;Hello&quot;; Match1 &#39;C&#39; }            -- &quot;HelloC&quot;    67
</pre></div>
</div>
<p>An alternative notation for <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">..</span> <span class="pre">}</span></code> parsers is to use the <code class="docutils literal notranslate"><span class="pre">block</span></code> keywrd
and <em>layout</em>:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def UseBraces = { Match &quot;A&quot;; Match &quot;B&quot; }
def UseLayout =
  block
    Match &quot;A&quot;
    Match &quot;B&quot;
</pre></div>
</div>
<p>The parsers <code class="docutils literal notranslate"><span class="pre">UseBraces</span></code> and <code class="docutils literal notranslate"><span class="pre">UseLayout</span></code> are the same, just using a
different notation.  When using layout, the entries in the sequence must start
on the same column, and any text that is indented more than that column
belongs to the corresponding parser.  So, the following parser is also
equivalent to the previous two:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def AlsoTheSame =
  block
    Match
      &quot;A&quot;
    Match &quot;B&quot;
</pre></div>
</div>
<p><strong>Explicit Result.</strong> A <code class="docutils literal notranslate"><span class="pre">block/{}</span></code>-sequenced group of parsers may return
the result from any member of the group instead of the last one.  To do so,
assign the result of the parser to the special variable <code class="docutils literal notranslate"><span class="pre">$$</span></code>.  For example,
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">P;</span> <span class="pre">$$</span> <span class="pre">=</span> <span class="pre">Q;</span> <span class="pre">R</span> <span class="pre">}</span></code> specifies that the group’s result should come from
<code class="docutils literal notranslate"><span class="pre">Q</span></code> instead of <code class="docutils literal notranslate"><span class="pre">R</span></code>.   It is an error to assign <code class="docutils literal notranslate"><span class="pre">$$</span></code> more than once.</p>
<p><strong>Local Variables.</strong> It is also possible to combine the results of some
of the <code class="docutils literal notranslate"><span class="pre">block/{}</span></code>-sequenced parsers by using <em>local variables</em> and the
pure parser.  Assignments prefixed by the keyword <code class="docutils literal notranslate"><span class="pre">let</span></code> introduce a local
variable, which is in scope in the following parsers.  Here is an example:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def Add =
  block
    let x = UInt8
    Match1 &#39;+&#39;
    let y = UInt8
    ^ x + y
</pre></div>
</div>
<p>The parser <code class="docutils literal notranslate"><span class="pre">Add</span></code> is a sequence of 4 parsers.  The local variables <code class="docutils literal notranslate"><span class="pre">x</span></code>
and <code class="docutils literal notranslate"><span class="pre">y</span></code> store the results of the first and the third parser.  The result
of the sequence is the result of the last parser, which does not consume
any input, but only constructs a semantic value by adding <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>
together.</p>
<p><strong>Structure Sequence.</strong> It is also possible to return results from more than
one of the parsers in a <code class="docutils literal notranslate"><span class="pre">block/{}</span></code>-sequenced group.  To do so give names
to the desired results (<em>without</em> <code class="docutils literal notranslate"><span class="pre">let</span></code>).  The semantic value of the
resulting parser is a structure with fields containing the value of
the correspondingly named parsers.  Consider, for example, the
following declaration:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def S =
  block
    x = UInt8
    y = Match &quot;HELLO&quot;
</pre></div>
</div>
<p>This declaration defines a parser named <code class="docutils literal notranslate"><span class="pre">S</span></code>, which will extract a
byte followed by the sequence <code class="docutils literal notranslate"><span class="pre">&quot;HELLO&quot;</span></code>. The result of this parser is
a <em>structure type</em>, also named <code class="docutils literal notranslate"><span class="pre">S</span></code>, which has two fields, <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>:
<code class="docutils literal notranslate"><span class="pre">x</span></code> is a byte, while <code class="docutils literal notranslate"><span class="pre">y</span></code> is an array of bytes.</p>
<p>Note that structure fields also introduce a local variable with the same name,
so later parsers in the sequence may depend on the semantic values in
earlier parsers in the sequence.  For example:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def S1 =
  block
    x = UInt8
    y = block
          let z = UInt8
          ^ x + z
</pre></div>
</div>
<p>The parser <code class="docutils literal notranslate"><span class="pre">S1</span></code> is a sequence of two parsers, whose semantic value
is a structure with two fields, <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.  Both fields have type
<code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">8</span></code>.  The first parser just extracts a byte from input.  The second
parser is itself a sequence: first it extracts a byte from the input,
but its semantic value is the sum of the two extracted bytes.  As another
example, here is an equivalent way to define the same parser:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def S2 =
  block
    x = UInt8
    let z = UInt8
    y = ^ x + z
</pre></div>
</div>
<p><strong>Syntactc Sugar.</strong> A number of the constructs described in this section are
simply syntactic sugar for using local variables.  Here are some examples:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Expression:</th>
<th class="head">Equivalent to:</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">$$</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">Q</span> <span class="pre">}</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">P;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">Q;</span> <span class="pre">^</span> <span class="pre">x</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">}</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">P;</span> <span class="pre">Q</span> <span class="pre">]</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">let</span> <span class="pre">x0</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">let</span> <span class="pre">x1</span> <span class="pre">=</span> <span class="pre">Q;</span> <span class="pre">^</span> <span class="pre">[x0,x1]</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">}</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">Q</span> <span class="pre">}</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">P;</span>&#160; <span class="pre">let</span> <span class="pre">y</span>&#160; <span class="pre">=</span> <span class="pre">Q;</span> <span class="pre">^</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x;</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">}</span> <span class="pre">}</span></code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="parsing-alternatives">
<h3>Parsing Alternatives<a class="headerlink" href="#parsing-alternatives" title="Permalink to this headline">¶</a></h3>
<p><strong>Biased Choice.</strong> Given two parsers <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> we may construct
the composite parser <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&lt;|</span> <span class="pre">Q</span></code>.   This parser succeeds if <em>either</em>
<code class="docutils literal notranslate"><span class="pre">P</span></code> <em>or</em> <code class="docutils literal notranslate"><span class="pre">Q</span></code> succeeds. In the case that <em>both</em> succeed, the parser behaves
like <code class="docutils literal notranslate"><span class="pre">P</span></code>.  Note that <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> have to construct semantic values of
the same type.</p>
<p>More operationally, <code class="docutils literal notranslate"><span class="pre">P</span></code> would be used to parse the input first,
and only if it fails would we execute <code class="docutils literal notranslate"><span class="pre">Q</span></code> on the same input.  While this
may be a useful intuition about the behavior of this parser, the actual
parsing algorithm might implement this behavior in a different way.</p>
<p>Here are some examples:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>{- Declaration            Matches        Result   -}
def B1 = Match1 &#39;A&#39;   -- &quot;A&quot;            &#39;A&#39;, or
      &lt;| Match1 &#39;B&#39;   -- &quot;B&quot;            &#39;B&#39;

def B2 = Match1 &#39;A&#39;
      &lt;| ^ &#39;B&#39;        -- &quot;A&quot;            &#39;A&#39;, or
                      -- &quot;&quot;             &#39;B&#39;
</pre></div>
</div>
<p>These two are quite different:  <code class="docutils literal notranslate"><span class="pre">B1</span></code> will fail unless the
next byte in the input is <code class="docutils literal notranslate"><span class="pre">'A'</span></code> or <code class="docutils literal notranslate"><span class="pre">'B'</span></code>, while <code class="docutils literal notranslate"><span class="pre">B2</span></code> never fails.</p>
<p><strong>Unbiased Choice.</strong> Given two parsers <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> we may construct
the composite parser <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">|</span> <span class="pre">Q</span></code>.  This parser succeeds if either <code class="docutils literal notranslate"><span class="pre">P</span></code> or <code class="docutils literal notranslate"><span class="pre">Q</span></code>
succeeds on the given input.   Unlike biased choice, if <em>both</em> succeed,
then the resulting parser is <em>ambigous</em> for the given input, which means
that input may be parsed in more than one way.  It is possible, however, to
resolve ambiguities by composing (e.g., in sequence) with other parsers.</p>
<p>Here are some examples:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def U1 = Match1 &#39;A&#39; | ^ 0
def U2 = { U1; &#39;B&#39; }
</pre></div>
</div>
<p>Parser <code class="docutils literal notranslate"><span class="pre">U1</span></code> on its own is ambiguous on inputs starting with <code class="docutils literal notranslate"><span class="pre">&quot;A&quot;</span></code> because
it could produce either <code class="docutils literal notranslate"><span class="pre">'A</span></code> (by consuming it from the input),
or <code class="docutils literal notranslate"><span class="pre">0</span></code> (by consuming nothing).  This happens because parsers only need
to match a prefix of the input to succeed.</p>
<p>Parser <code class="docutils literal notranslate"><span class="pre">U2</span></code> accepts inputs starting with either <code class="docutils literal notranslate"><span class="pre">&quot;AB&quot;</span></code> (by using the
left alternative of <code class="docutils literal notranslate"><span class="pre">U1</span></code>) or starting with <code class="docutils literal notranslate"><span class="pre">&quot;B&quot;</span></code> (by using the right
alternative of <code class="docutils literal notranslate"><span class="pre">U1</span></code>).  No inputs are ambiguous in this case.</p>
<p><strong>Alternative Syntax.</strong> Given multiple parsers <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, … we can use
the <code class="docutils literal notranslate"><span class="pre">Choose</span></code> keyword for unbiased choice and <code class="docutils literal notranslate"><span class="pre">Choose1</span></code> for biased choice.</p>
<table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Expression:</th>
<th class="head">Equivalent to:</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">Choose</span> <span class="pre">{</span> <span class="pre">A</span> <span class="pre">;</span> <span class="pre">B;</span> <span class="pre">...}</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">|</span> <span class="pre">B</span> <span class="pre">|</span> <span class="pre">...</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">Choose1</span> <span class="pre">{</span> <span class="pre">A</span> <span class="pre">;</span> <span class="pre">B;</span> <span class="pre">...</span> <span class="pre">}</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&lt;|</span> <span class="pre">B</span> <span class="pre">&lt;|</span> <span class="pre">...</span></code></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">Choose</span></code> and <code class="docutils literal notranslate"><span class="pre">Choose1</span></code> keywords also support <strong>layout</strong>, so instead
of using braces and semi-colons we can just line-up the alternaitves like this:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def ChooseWithBraces =
  Choose1 {
    Match1 &#39;A&#39;;
    Match1 &#39;B&#39;;
  }

def ChooseWithLayout =
  Choose1
    Match &#39;A&#39;
    Match &#39;B&#39;
</pre></div>
</div>
<p>Choose can also be used to construct tagged unions: see below.</p>
</div>
</div>
<div class="section" id="control-structures">
<h2>Control Structures<a class="headerlink" href="#control-structures" title="Permalink to this headline">¶</a></h2>
<div class="section" id="guards">
<h3>Guards<a class="headerlink" href="#guards" title="Permalink to this headline">¶</a></h3>
<p>Boolean semantic values may be used as a guard to control whether parsing
continues. For example, the following parser uses the guard
<code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">-</span> <span class="pre">'0')</span> <span class="pre">&gt;</span> <span class="pre">5</span> <span class="pre">is</span> <span class="pre">true</span></code> to distinguish whether an parsed digit is
greater than 5.</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>block
  let i = Match1 (&#39;0&#39;..&#39;9&#39;)
  Choose1
    block
      (i - &#39;0&#39;) &gt; 5 is true
      ^ &quot;input gt 5&quot;
    ^ &quot;input leq 5&quot;
</pre></div>
</div>
<p>So, if <code class="docutils literal notranslate"><span class="pre">p</span></code> is a boolean value, then <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">is</span> <span class="pre">true</span></code> is a parser that
succeeds without consuming input if <code class="docutils literal notranslate"><span class="pre">p</span></code> holds, and fails otherwise.
Similarly, <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">is</span> <span class="pre">false</span></code> is a parser that would succeed only
if <code class="docutils literal notranslate"><span class="pre">p</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="if-then-else">
<h3>If-then-else<a class="headerlink" href="#if-then-else" title="Permalink to this headline">¶</a></h3>
<p>Booleans may also be used to choose between one of two parsers:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>block
  let i = Match1 (&#39;0&#39;..&#39;9&#39;)
  if (i - &#39;0&#39;) &gt; 5
    then Match &#39;X&#39;
    else ^ 7
</pre></div>
</div>
<p>The parser above parses a decimal digit and if it is larger than 5
it will try to match <code class="docutils literal notranslate"><span class="pre">'X'</span></code> from the input, otherwise it will succeed
with sematic value 7.</p>
</div>
<div class="section" id="for-loops">
<h3><code class="docutils literal notranslate"><span class="pre">for</span></code> loops<a class="headerlink" href="#for-loops" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">for</span></code> construct can be used to iterate over collections (arrays
and dictionaries).  A for-loop declares a local variable representing
the accumulated result of the computation, and a variable that is
bound to the elements of the collection.  The body may be a parser, or
a semantic value.  For example, the following expression sums the
values in an array of integers:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>for (val = 0 : int; v in [1,2,3])
  val + v
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">val</span></code> is initially bound to <code class="docutils literal notranslate"><span class="pre">0</span></code>. Each iteration of the loop binds
<code class="docutils literal notranslate"><span class="pre">v</span></code> to the current element of the sequence, then computes the value of the
body, <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">+</span> <span class="pre">v</span></code>. This returned value is the updated value of <code class="docutils literal notranslate"><span class="pre">val</span></code>.</p>
<p>Another way to understand how this works is to see the following expression,
which is the result of one step of evaluation:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>for (val = 1; v in [2, 3])
  val + v
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">for</span></code> supports an alternative form which binds both the index and
value of a collection. For example, the following loop multiplies
each element in the sequence by its index:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>for (val = 0; i,v in [1,2,3])
  val + (i * v)
</pre></div>
</div>
<p>This construct is also useful when iterating over the contents of
dictionaries, where the index is bound to the key.  The following
loop is a parser which fails when the value is less than the key:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>for (val = 0; k,v in d)
  k &lt;= v is true
</pre></div>
</div>
</div>
<div class="section" id="map">
<h3>Map<a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h3>
<p>Daedalus supports another iteration construct, <code class="docutils literal notranslate"><span class="pre">map</span></code>. This performs an operation on each
element of a sequence, resulting in a sequence of results. For example, the following code
doubles each element in an array:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>map (x in [1:int, 2, 3])
  2 * x
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">map</span></code> construct can be used to parse a sequence of blocks, based on a
sequence of values. For example the following code parses blocks of the form <code class="docutils literal notranslate"><span class="pre">0AAA...</span></code>,
with the number of <code class="docutils literal notranslate"><span class="pre">'A'</span></code> characters dicated by the input sequence.</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>map (x in [1, 2, 3]) {
  Match1 &#39;0&#39;;
  Many x (Match1 &#39;A&#39;);
}
</pre></div>
</div>
<p>Just as with <code class="docutils literal notranslate"><span class="pre">for</span></code>, the map construct has an alternative form that includes both
sequence indexes and values:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>map (i,x in [5, 2, 1]) {
  Match1 &#39;0&#39;;
  len       = ^ { index = i, elem = x };
  something = Many x (Match1 &#39;A&#39;);
}
</pre></div>
</div>
</div>
<div class="section" id="unions-and-case-distinction">
<h3>Unions and Case Distinction<a class="headerlink" href="#unions-and-case-distinction" title="Permalink to this headline">¶</a></h3>
<p>Daedalus supports tagged unions and case distinction on unions. The way to
construct a union is to use <code class="docutils literal notranslate"><span class="pre">Choose</span></code>. For example, the following parser
constructs a union with possible tags <code class="docutils literal notranslate"><span class="pre">good</span></code> and <code class="docutils literal notranslate"><span class="pre">bad</span></code>,
depending on whether the input character is <code class="docutils literal notranslate"><span class="pre">'G'</span></code> or <code class="docutils literal notranslate"><span class="pre">'B'</span></code>.</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>-- (using layout)
Choose
  good = &#39;G&#39;
  bad = &#39;B&#39;
</pre></div>
</div>
<p>It is also possible to construct a union literal using <code class="docutils literal notranslate"><span class="pre">{|</span> <span class="pre">good</span> <span class="pre">=</span> <span class="pre">'G'</span> <span class="pre">|}</span></code>.
Note however that the compiler will reject programs where it cannot infer
the resulting type of the union.  In such cases, you’d need to provide
an explicit type signature.</p>
<p>Given a union <code class="docutils literal notranslate"><span class="pre">u</span></code> and tag name <code class="docutils literal notranslate"><span class="pre">t</span></code>, the guard <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">is</span> <span class="pre">t</span></code> succeeds
if the union has the correct tag. This can be used to control parser
control flow, as in the following example:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>block
  let res = Choose
              good = Match1 &#39;G&#39;
              bad  = Match1 &#39;B&#39;

  Choose

    block
      res is good
      ^ &quot;Success!&quot;

    block
      res is bad
      ^ &quot;Failure!&quot;
</pre></div>
</div>
<p>The result of a succesful <code class="docutils literal notranslate"><span class="pre">is</span></code> guard is the value of the union
element.  For example</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>block
  let res = Choose
              good =
                block
                  Match1 &#39;G&#39;
                  Many (Match1 (&#39;a&#39; .. &#39;z&#39;))

              bad = Match1 &#39;B&#39;

  Choose

    block
      let msg = res is good
      ^ concat [ &quot;Success!&quot;, msg]

    block
      res is bad
      ^ &quot;Failure!&quot;
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Document <code class="docutils literal notranslate"><span class="pre">case</span></code></p>
</div>
</div>
<div class="section" id="commit">
<h3>Commit<a class="headerlink" href="#commit" title="Permalink to this headline">¶</a></h3>
<p>Normally, at the point a parser fails, Daedalus will backtrack to a choice point
and try an alternative parser. The <code class="docutils literal notranslate"><span class="pre">commit</span></code> guard acts as a cut-point and prevents
backtracking. For example, the following code cannot parse the string <code class="docutils literal notranslate"><span class="pre">&quot;AC&quot;</span></code>
because parsing <code class="docutils literal notranslate"><span class="pre">'A'</span></code> and the subsequent <code class="docutils literal notranslate"><span class="pre">commit</span></code> will prevent backtracking
reaching the alternative branch.</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>Choose1 {
  { Match1 &#39;A&#39;; commit; Match1 &#39;B&#39; };
  { Match1 &#39;A&#39;; Match1 &#39;C&#39; }  -- Can&#39;t happen
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">try</span></code> construct converts commit failure into parser failure.  A
commit failure will propagate until it hits an enclosing <code class="docutils literal notranslate"><span class="pre">try</span></code>
construct, or until it escapes the top-level definition.</p>
</div>
<div class="section" id="option-type">
<h3>Option type<a class="headerlink" href="#option-type" title="Permalink to this headline">¶</a></h3>
<p>Daedalus supports the special polymorphic type <code class="docutils literal notranslate"><span class="pre">maybe</span> <span class="pre">A</span></code>, which has possible
values <code class="docutils literal notranslate"><span class="pre">nothing</span></code> and <code class="docutils literal notranslate"><span class="pre">just</span> <span class="pre">i</span></code>, for some value of type <code class="docutils literal notranslate"><span class="pre">A</span></code>.
The <code class="docutils literal notranslate"><span class="pre">is</span></code> guard can be used to identify which case holds.</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>{
  @res =
    {@l = Match1 (&#39;A&#39;..&#39;Z&#39;); ^ just l}
      &lt;|
    {^ nothing};
  r = res is just
}
</pre></div>
</div>
<p>The above example could also be written using the builtin <code class="docutils literal notranslate"><span class="pre">Optional</span></code> parser.</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>{
  @res = Optional (Match1 &#39;A&#39;..&#39;Z&#39;);
  r = res is just
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="semantic-values">
<h2>Semantic Values<a class="headerlink" href="#semantic-values" title="Permalink to this headline">¶</a></h2>
<p>If successful, a parser produces a semantic value, which describes the
input in some way useful to the application invoking the parser.
In addition, semantic values may be used to control how other parts of the
input are to be parsed.  Daedalus has a number of built-in semantic values
types, and allows for user-defined record and union types.</p>
<div class="section" id="booleans">
<h3>Booleans<a class="headerlink" href="#booleans" title="Permalink to this headline">¶</a></h3>
<p>The type <code class="docutils literal notranslate"><span class="pre">bool</span></code> classifies the usual boolean values <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>The operator <code class="docutils literal notranslate"><span class="pre">!</span></code> may be used to negate a boolean value.</p>
<p>Boolean values may be compared for equality using <code class="docutils literal notranslate"><span class="pre">==</span></code>.</p>
</div>
<div class="section" id="numeric-types">
<h3>Numeric Types<a class="headerlink" href="#numeric-types" title="Permalink to this headline">¶</a></h3>
<p>Daedalus supports a variety of numeric types: <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">N</span></code>, and
<code class="docutils literal notranslate"><span class="pre">sint</span> <span class="pre">N</span></code>, the latter two being families of types indexed by a number.
The type <code class="docutils literal notranslate"><span class="pre">int</span></code> classifies integers of arbitrary size.
The <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">N</span></code> classify unsigned numbers that can be represented using <code class="docutils literal notranslate"><span class="pre">N</span></code>
bits and <code class="docutils literal notranslate"><span class="pre">sint</span> <span class="pre">N</span></code> is for signed numbers that can be represented
in <code class="docutils literal notranslate"><span class="pre">N</span></code> bits.</p>
<p>Literals of the numeric types may written either using decimal or hexadecimal
notation (e.g., <code class="docutils literal notranslate"><span class="pre">10</span></code> or <code class="docutils literal notranslate"><span class="pre">0xA</span></code>).  The type of a literal can be inferred
from the context (e.g., <code class="docutils literal notranslate"><span class="pre">10</span></code> can be used as both <code class="docutils literal notranslate"><span class="pre">int</span></code> a <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">8</span></code>).</p>
<p>Numeric types support basic arithmetic: addition, subtraction,
multiplication, division, and modulus using the usual operators
<code class="docutils literal notranslate"><span class="pre">+</span></code>,``-<code class="docutils literal notranslate"><span class="pre">,``*</span></code>,``/<code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">and</span> <span class="pre">``%</span></code>.  DaeDaLus also supports shift
operations <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>.
These operations are overloaded and can be used on all numeric types,
with the restriction that the inputs and the outputs must be of the
same type.</p>
<p>Numeric types can also be compared for equality, using <code class="docutils literal notranslate"><span class="pre">==</span></code> and ordering
using <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>.</p>
<p>Unsigned integers may also be treated as bit-vectors, and support various
bitwise operations: complement: <code class="docutils literal notranslate"><span class="pre">~</span></code>; exclusive-or <code class="docutils literal notranslate"><span class="pre">^</span></code>; and bitwise-and <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>.</p>
<p>Unsigned numbers can also be appended to other numbers via the
<code class="docutils literal notranslate"><span class="pre">#</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;#</span></code> operator.  To see the difference between the two,
consider two bitvectors <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">uint</span> <span class="pre">A)</span></code> and <code class="docutils literal notranslate"><span class="pre">(y</span> <span class="pre">:</span> <span class="pre">uint</span> <span class="pre">B)</span></code>.
The result of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">#</span> <span class="pre">y</span></code> is a bitvector of type <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span></code> with
<code class="docutils literal notranslate"><span class="pre">x</span></code> in the more significatn bits, and <code class="docutils literal notranslate"><span class="pre">y</span></code> in the less significant bits.
The result of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;#</span> <span class="pre">y</span></code> is a bitvector of type <code class="docutils literal notranslate"><span class="pre">A</span></code> that contains
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">#</span> <span class="pre">y</span></code> but truncated to the <code class="docutils literal notranslate"><span class="pre">A</span></code> less significatn bits.</p>
</div>
</div>
<div class="section" id="stream-manipulation">
<h2>Stream manipulation<a class="headerlink" href="#stream-manipulation" title="Permalink to this headline">¶</a></h2>
<p>Daedalus parsers operate on an <em>input stream</em>, which by default is the input
data to the parser. However, the input stream can be manipulated directly. For example,
we can write a parser function which runs two different parsers on the same stream.</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def ParseTwice P1 P2 = {
  @cur = GetStream;
  p1result = P1;
  SetStream cur;
  p2result = P2;
}
</pre></div>
</div>
<p>By manipulating the stream, we can also run a parser on a fixed-size sub-stream.
The following parser parses a size-n chunk which begins with a sequence of
letters, and then is filled with spaces:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def LetterFill n = {
  @cur = GetStream;
  @this = Take n cur;
  @next = Drop n cur;
  SetStream this;
  $$ = { $$ = Many (Match1 (&#39;A&#39;..&#39;Z&#39;))
          Many (Match1 &#39; &#39;);
          END; };
  SetStream next;
}
</pre></div>
</div>
<p>It is also possible to directly access the current position in the stream using
<code class="docutils literal notranslate"><span class="pre">Offset</span></code>. This can be used to calculate how many characters were read by a
particular parser:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def OffsetTest = {
    a = Offset;
    Match &quot;AA&quot;;
    b = Offset;
    Match &quot;AAA&quot;;
    c = Offset;
}
-- Result: { a:0, b:2, c:5 }
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">arrayStream</span></code> operator converts an array into a stream:</p>
<div class="highlight-Daedalus notranslate"><div class="highlight"><pre><span></span>def CatStream a b = {
    SetStream (arrayStream (concat [a, b]));
    Match &quot;AA&quot;;
    Match &quot;BBB&quot;;
    ^ {}
}
</pre></div>
</div>
<p>This example will succeed if the concatenation of the arrays <code class="docutils literal notranslate"><span class="pre">a</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span></code> starts with the string <code class="docutils literal notranslate"><span class="pre">&quot;AABBB&quot;</span></code>.</p>
</div>
<div class="section" id="types">
<h2>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="character-classes">
<span id="id1"></span><h2>Character Classes<a class="headerlink" href="#character-classes" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="external-declarations">
<h2>External Declarations<a class="headerlink" href="#external-declarations" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">DaeDaLus User Guide</a><ul>
<li><a class="reference internal" href="#declarations">Declarations</a></li>
<li><a class="reference internal" href="#parsers">Parsers</a><ul>
<li><a class="reference internal" href="#primitive-parsers">Primitive Parsers</a></li>
<li><a class="reference internal" href="#sequencing-parsers">Sequencing Parsers</a></li>
<li><a class="reference internal" href="#parsing-alternatives">Parsing Alternatives</a></li>
</ul>
</li>
<li><a class="reference internal" href="#control-structures">Control Structures</a><ul>
<li><a class="reference internal" href="#guards">Guards</a></li>
<li><a class="reference internal" href="#if-then-else">If-then-else</a></li>
<li><a class="reference internal" href="#for-loops"><code class="docutils literal notranslate"><span class="pre">for</span></code> loops</a></li>
<li><a class="reference internal" href="#map">Map</a></li>
<li><a class="reference internal" href="#unions-and-case-distinction">Unions and Case Distinction</a></li>
<li><a class="reference internal" href="#commit">Commit</a></li>
<li><a class="reference internal" href="#option-type">Option type</a></li>
</ul>
</li>
<li><a class="reference internal" href="#semantic-values">Semantic Values</a><ul>
<li><a class="reference internal" href="#booleans">Booleans</a></li>
<li><a class="reference internal" href="#numeric-types">Numeric Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stream-manipulation">Stream manipulation</a></li>
<li><a class="reference internal" href="#types">Types</a></li>
<li><a class="reference internal" href="#character-classes">Character Classes</a></li>
<li><a class="reference internal" href="#external-declarations">External Declarations</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="#">Daedalus 0.1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, The Daedalus Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>