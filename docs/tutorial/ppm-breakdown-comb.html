<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Breaking down PPM: Parser Combinators &mdash; Daedalus 0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Breaking down PPM: Primitive Parsing" href="ppm-breakdown-parse.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Daedalus
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Using the Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../using-daedalus.html">Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../using-daedalus.html#check-a-specification">Check a Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../using-daedalus.html#run-the-interpreter">Run the Interpreter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../using-daedalus.html#compile-to-haskell">Compile to Haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../using-daedalus.html#compile-to-c">Compile to C++</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Daedalus Language</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../declarations.html">Declarations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parsers.html">Parsers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../parsers.html#primitive-parsers">Primitive Parsers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parsers.html#sequencing-parsers">Sequencing Parsers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../parsers.html#basic-sequencing">Basic Sequencing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parsers.html#explicit-result">Explicit Result</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parsers.html#local-variables">Local Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parsers.html#structure-sequence">Structure Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parsers.html#syntactic-sugar">Syntactic Sugar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../parsers.html#parsing-alternatives">Parsing Alternatives</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../parsers.html#biased-choice">Biased Choice</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parsers.html#unbiased-choice">Unbiased Choice</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parsers.html#alternative-syntax">Alternative Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parsers.html#tagged-unions">Tagged Unions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../parsers.html#repetition">Repetition</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../control-structures.html">Control Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../control-structures.html#if-then-else">If-then-else</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-structures.html#guards">Guards</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../control-structures.html#boolean-guards">Boolean Guards</a></li>
<li class="toctree-l3"><a class="reference internal" href="../control-structures.html#guards-on-maybe">Guards on <code class="docutils literal notranslate"><span class="pre">maybe</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../control-structures.html#guards-on-tagged-unions">Guards on Tagged Unions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../control-structures.html#case">Case</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-structures.html#for-loops"><code class="docutils literal notranslate"><span class="pre">for</span></code> loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-structures.html#traversing-with-map">Traversing with <code class="docutils literal notranslate"><span class="pre">map</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-structures.html#many-loops"><code class="docutils literal notranslate"><span class="pre">many</span></code> loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-structures.html#commit">Commit</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../types.html">Type Annotations and Coercions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../types.html#annotating-an-expression">Annotating an Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types.html#annotating-the-result-of-a-declaration">Annotating the Result of a Declaration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types.html#annotating-a-parameter">Annotating a Parameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types.html#naming-unknown-types">Naming Unknown Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types.html#coercions">Coercions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../semantic-values.html">Semantic Values</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../semantic-values.html#booleans">Booleans</a></li>
<li class="toctree-l2"><a class="reference internal" href="../semantic-values.html#numeric-types">Numeric Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../semantic-values.html#numeric-literals">Numeric Literals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../semantic-values.html#comparisons">Comparisons</a></li>
<li class="toctree-l3"><a class="reference internal" href="../semantic-values.html#basic-arithmetic">Basic Arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../semantic-values.html#bitwise-operations">Bitwise Operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../semantic-values.html#maybe-type"><code class="docutils literal notranslate"><span class="pre">maybe</span></code> type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../semantic-values.html#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../semantic-values.html#association-maps">Association Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../semantic-values.html#builders">Builders</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../streams.html">Stream Manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../character-classes.html">Character Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../external.html">External Declarations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bitdata.html">Bitdata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lifting.html">Implicit Lifting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../implicit-parameters.html">Implicit Parameters</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Daedalus Tutorial</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting-started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="getting-started.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting-started.html#daedalus-syntax-highlighting-editing-modes">DaeDaLus Syntax Highlighting / Editing Modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting-started.html#your-first-daedalus-specification">Your First DaeDaLus Specification</a><ul>
<li class="toctree-l3"><a class="reference internal" href="getting-started.html#the-portable-pixmap-format">The Portable PixMap Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="getting-started.html#an-example-ppm-image">An Example PPM Image</a></li>
<li class="toctree-l3"><a class="reference internal" href="getting-started.html#a-daedalus-ppm-specification">A DaeDaLus PPM Specification</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ppm-breakdown.html">Breaking Down the PPM Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="ppm-breakdown-decl.html">Breaking down PPM: Declarations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ppm-breakdown-decl.html#deducing-types-from-names">Deducing Types From Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="ppm-breakdown-decl.html#parameterized-declarations">Parameterized Declarations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ppm-breakdown-parse.html">Breaking down PPM: Primitive Parsing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ppm-breakdown-parse.html#uint8"><code class="docutils literal notranslate"><span class="pre">UInt8</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="ppm-breakdown-parse.html#match1"><code class="docutils literal notranslate"><span class="pre">Match1</span> <span class="pre">...</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="ppm-breakdown-parse.html#match"><code class="docutils literal notranslate"><span class="pre">Match</span> <span class="pre">...</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="ppm-breakdown-parse.html#end"><code class="docutils literal notranslate"><span class="pre">END</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="ppm-breakdown-parse.html#id1"><code class="docutils literal notranslate"><span class="pre">^</span> <span class="pre">...</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="ppm-breakdown-parse.html#fail"><code class="docutils literal notranslate"><span class="pre">Fail</span> <span class="pre">...</span></code></a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Breaking down PPM: Parser Combinators</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#standard-sequencing">Standard Sequencing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#array-sequencing">Array Sequencing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#structure-sequencing">Structure Sequencing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#de-sugaring-nonstandard-structure-sequences">De-Sugaring Nonstandard Structure Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parsing-alternates">Parsing Alternates</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#biased-choice-parsing">Biased Choice Parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unbiased-choice-parsing">Unbiased Choice Parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tagged-sum-types">Tagged Sum Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#repeating-parsers">Repeating Parsers</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Daedalus</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Breaking down PPM: Parser Combinators</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/tutorial/ppm-breakdown-comb.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="breaking-down-ppm-parser-combinators">
<h1>Breaking down PPM: Parser Combinators<a class="headerlink" href="#breaking-down-ppm-parser-combinators" title="Permalink to this headline"></a></h1>
<p>The primitives are critical to defining parsers, but aren’t very interesting
on their own - we need ways to sequence them, represent notions of choice,
and deal with repetition. First, we look at the various ways to sequence a
collection of parsers.</p>
<section id="standard-sequencing">
<h2>Standard Sequencing<a class="headerlink" href="#standard-sequencing" title="Permalink to this headline"></a></h2>
<p>First and foremost, we need a way to run one parser after another. In DaeDaLus,
we write sequenced parsers by surrounding them with curly braces (<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>)
and separating the parsers with semicolons. We’ve already seen this in the
<code class="docutils literal notranslate"><span class="pre">Token</span></code> parser:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">Token</span> <span class="n">P</span> <span class="k">=</span> <span class="p">{</span>
  <span class="k">$$</span> <span class="k">=</span> <span class="n">P</span><span class="p">;</span>
  <span class="k">Many</span> <span class="p">(</span><span class="m">1</span><span class="p">..)</span> <span class="n">WS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This says “run the parser <code class="docutils literal notranslate"><span class="pre">P</span></code>, then run the parser <code class="docutils literal notranslate"><span class="pre">Many</span> <span class="pre">(1..)</span> <span class="pre">WS</span></code>.” If
either of these were to fail, the entire sequence would fail.</p>
<p>By default, when we use <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> for parser sequencing, the result of the
last parser in the sequence is what will be returned. We can subvert this
default, as in the <code class="docutils literal notranslate"><span class="pre">Token</span></code> example, using the special variable <code class="docutils literal notranslate"><span class="pre">$$</span></code>:
Assigning to this variable in a sequence means “return this as the result
of the whole sequence” - as we’ll see later, this is simply <em>syntactic sugar</em>
for a more verbose construction with exactly the same behavior.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There is another way of writing sequenced parsers in DaeDaLus that you may
see sometimes that relies on whitespace-sensitivity / code layout, in much
the same way as the Python programming language.</p>
<p>Consider the two following declarations:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">UseBraces</span> <span class="k">=</span> <span class="p">{</span> <span class="k">Match</span> <span class="s">&quot;A&quot;</span><span class="p">;</span> <span class="k">Match</span> <span class="s">&quot;B&quot;</span> <span class="p">}</span>
<span class="k">def</span> <span class="n">UseLayout</span> <span class="k">=</span>
  <span class="k">block</span>
    <span class="k">Match</span> <span class="s">&quot;A&quot;</span>
    <span class="k">Match</span> <span class="s">&quot;B&quot;</span>
</pre></div>
</div>
<p>We can use layout instead of braces/semicolons using the <code class="docutils literal notranslate"><span class="pre">block</span></code> keyword.
All of the parsers we are sequencing must be aligned on the same column,
and any text that is indented beyond this column belongs to the
corresponding (preceding) parser. To demonstrate:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">UseLayout2</span> <span class="k">=</span>
  <span class="k">block</span>
    <span class="k">Match</span>
      <span class="s">&quot;A&quot;</span>
    <span class="k">Match</span> <span class="s">&quot;B&quot;</span>
</pre></div>
</div>
<p>Which behaves the same as both of the previous parsers. Neither style is
preferred by the language; use what’s comfortable for you!</p>
</div>
</section>
<section id="array-sequencing">
<h2>Array Sequencing<a class="headerlink" href="#array-sequencing" title="Permalink to this headline"></a></h2>
<p>We may also use square braces (<code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">..</span> <span class="pre">]</span></code>) for sequencing parsers. When we use
this notation, rather than returning a single result from one of the sequenced
parsers, we return an array containing <em>all</em> of the results. Crucially, in this
case, all of the parsers being sequenced must return the same type of semantic
value, since array elements must all have the same type.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Remember: Arrays in DaeDaLus must contain only elements of the same type!
If you need to package up data of varying types, keep reading on about
structure sequencing.</p>
</div>
</section>
<section id="structure-sequencing">
<h2>Structure Sequencing<a class="headerlink" href="#structure-sequencing" title="Permalink to this headline"></a></h2>
<p>What if we need to keep the results of multiple parsers, but they return
different types of semantic values? Neither standard nor array sequencing are
sufficient, so we need something a bit fancier.</p>
<p>In many programming languages, we can define <em>record types</em> that store a
collection of named fields, each of which has its own type. For example,
a <code class="docutils literal notranslate"><span class="pre">Person</span></code> record might contain a field <code class="docutils literal notranslate"><span class="pre">name</span></code> of type <code class="docutils literal notranslate"><span class="pre">string</span></code>, and an
<code class="docutils literal notranslate"><span class="pre">age</span></code> field of type <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">8</span></code>. We build a new <code class="docutils literal notranslate"><span class="pre">Person</span></code> by providing values
for each field, and from a <code class="docutils literal notranslate"><span class="pre">Person</span></code> we may extract the values of each field,
typically using some kind of “field access” notation.</p>
<p>DaeDaLus also supports record types, though in a non-traditional way: A record
is defined by a corresponding parser. This idea is best shown by example.</p>
<p>In the PPM specification, we have the following declaration for a parser
(pop quiz: how do we know it’s a parser?) called <code class="docutils literal notranslate"><span class="pre">RGB</span></code>:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">RGB</span> <span class="k">=</span> <span class="p">{</span>
  <span class="n">red</span>   <span class="k">=</span> <span class="n">Token</span> <span class="n">Natural</span><span class="p">;</span>
  <span class="n">green</span> <span class="k">=</span> <span class="n">Token</span> <span class="n">Natural</span><span class="p">;</span>
  <span class="n">blue</span>  <span class="k">=</span> <span class="n">Token</span> <span class="n">Natural</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note here that, rather than simply sequencing three parsers, we are storing the
result of each in a variable. Doing so in this way means that the semantic
value produced by the <code class="docutils literal notranslate"><span class="pre">RGB</span></code> parser will be a record (hereafter referred to as
a <em>structure</em>) with three fields, <code class="docutils literal notranslate"><span class="pre">red</span></code>, <code class="docutils literal notranslate"><span class="pre">green</span></code>, and <code class="docutils literal notranslate"><span class="pre">blue</span></code>, and with a
type named after the parser itself, i.e. <code class="docutils literal notranslate"><span class="pre">RGB</span></code>. As you might hope, the names
we introduce are available to be referred to later in the sequence of parsers,
so if we needed to, we could use the value stored in <code class="docutils literal notranslate"><span class="pre">red</span></code> while parsing
<code class="docutils literal notranslate"><span class="pre">green</span></code> or <code class="docutils literal notranslate"><span class="pre">blue</span></code>.</p>
<p>To better demonstrate this last point, consider this more contrived example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">S</span> <span class="k">=</span>
  <span class="k">block</span>
    <span class="n">x</span> <span class="k">=</span> <span class="k">UInt8</span>
    <span class="n">y</span> <span class="k">=</span> <span class="k">^</span> <span class="n">x</span> <span class="o">+</span> <span class="m">17</span>
</pre></div>
</div>
<p>This defines a parser named <code class="docutils literal notranslate"><span class="pre">S</span></code> which will return a semantic value that is a
structure (whose type is also named <code class="docutils literal notranslate"><span class="pre">S</span></code>) with two fields, <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>,
where <code class="docutils literal notranslate"><span class="pre">x</span></code> is a byte we parse and <code class="docutils literal notranslate"><span class="pre">y</span></code> is that byte plus 17.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is also possible to define <em>local variables</em> within a declaration
without causing a structure to be created - this can be useful when we want
to save parsing results for later, or have some complex semantic value that
we don’t want to write down more than once.</p>
<p>To introduce a local variable that won’t be turned into a structure field,
prefix the assignment with the keyword <code class="docutils literal notranslate"><span class="pre">let</span></code> (or the symbol <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>). We’ve
already seen an example of this in the <code class="docutils literal notranslate"><span class="pre">Digit</span></code> parser:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Digit</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nd">@d</span> <span class="o">=</span> <span class="n">Match1</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span> <span class="o">..</span> <span class="s1">&#39;9&#39;</span><span class="p">);</span>
  <span class="o">^</span> <span class="n">d</span> <span class="o">-</span> <span class="s1">&#39;0&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, the result of the parser <code class="docutils literal notranslate"><span class="pre">Match1</span> <span class="pre">('0'</span> <span class="pre">..</span> <span class="pre">'9')</span></code> is stored in a local
variable <code class="docutils literal notranslate"><span class="pre">d</span></code>, which we later use in a lifted semantic value to return the
value of the digit itself.</p>
<p>Remember: If we prefix the assignment with <code class="docutils literal notranslate"><span class="pre">let</span></code> or <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, we’re <em>just</em>
creating a local variable, <em>not</em> the field of a structure!</p>
</div>
</section>
<section id="de-sugaring-nonstandard-structure-sequences">
<h2>De-Sugaring Nonstandard Structure Sequences<a class="headerlink" href="#de-sugaring-nonstandard-structure-sequences" title="Permalink to this headline"></a></h2>
<p>Let’s pull back the curtain a bit: As it turns out, most of the constructs
for sequencing we’ve looked at so far can be expressed using only local
variables and standard sequencing!</p>
<p>First, recall that the special variable <code class="docutils literal notranslate"><span class="pre">$$</span></code> allows us to control which
parser’s result is returned in a standard sequence - if we have
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">$$</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">Q</span> <span class="pre">}</span></code>, that means “run parser <code class="docutils literal notranslate"><span class="pre">P</span></code>”, then run parser <code class="docutils literal notranslate"><span class="pre">Q</span></code>,
and return the result of parser <code class="docutils literal notranslate"><span class="pre">P</span></code>.” Can we write this without using the
special variable?</p>
<p>Yes! All we need to do is store the result of <code class="docutils literal notranslate"><span class="pre">P</span></code> to refer to later, like
so: <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">&#64;x</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">Q;</span> <span class="pre">^</span> <span class="pre">x</span> <span class="pre">}</span></code>. Here, we store the result of <code class="docutils literal notranslate"><span class="pre">P</span></code> in the local
variable <code class="docutils literal notranslate"><span class="pre">x</span></code>, which we later lift using the primitive pure parser <code class="docutils literal notranslate"><span class="pre">^</span></code>.</p>
<p>Similarly, array sequencing of parsers, such as <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">P;</span> <span class="pre">Q</span> <span class="pre">]</span></code>, can be
written: <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">&#64;x0</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">&#64;x1</span> <span class="pre">=</span> <span class="pre">Q;</span> <span class="pre">^</span> <span class="pre">[x0,</span> <span class="pre">x1]</span> <span class="pre">}</span></code>. Note that, in both this and
the previous case, the expanded forms require us to come up with more names
for things. Arguably, naming is one of the hardest problems we face in
computer science, so it’s nice to be able to avoid coming up with new names
using the shorthand originally presented.</p>
<p>Finally, even structure sequencing can be written this way, since we can
construct structure semantic values using the primitive pure parser. If
we have <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">Q</span> <span class="pre">}</span></code>, this can also be written
<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">&#64;x</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">&#64;y</span> <span class="pre">=</span> <span class="pre">Q;</span> <span class="pre">^</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">}</span> <span class="pre">}</span></code>.</p>
<p>While we recommend using the shorthand, developing an understanding of what
it actually means can make it more obvious when each construct is
appropriate for your use-cases.</p>
</section>
<section id="parsing-alternates">
<h2>Parsing Alternates<a class="headerlink" href="#parsing-alternates" title="Permalink to this headline"></a></h2>
<p>While it is great to be able to parse many things in sequence, most interesting
formats require that we be able to parse one of a set of <em>alternatives</em> - as an
example, in a programming language, there are typically many different forms of
expression, and anywhere an expression is allowed, we must be able to
successfully parse any of those different forms.</p>
<p>DaeDaLus is unique in that it provides two ways of handling alternatives:
<em>biased choice</em> and <em>unbiased choice</em> - many parsing libraries do not provide
this flexibility. We’ll now look at these alternatives (no pun intended), and
some examples that demonstrate their differing behaviors.</p>
<p>Note that our working PPM example does not use any alternative parsing - the
extended exercise following this section, to implement the PNG image format,
will show off these features more concretely.</p>
<section id="biased-choice-parsing">
<h3>Biased Choice Parsing<a class="headerlink" href="#biased-choice-parsing" title="Permalink to this headline"></a></h3>
<p>If we have two parsers, <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code>, we can construct the parser
<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&lt;|</span> <span class="pre">Q</span></code>. This new parser succeeds if either <code class="docutils literal notranslate"><span class="pre">P</span></code> or <code class="docutils literal notranslate"><span class="pre">Q</span></code> succeeds, and
crucially, when <em>both</em> succeed, it behaves like <code class="docutils literal notranslate"><span class="pre">P</span></code> (the symbol should
you of this.) Thought about another way: <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&lt;|</span> <span class="pre">Q</span></code> tries to parse using
<code class="docutils literal notranslate"><span class="pre">P</span></code>, and if this fails, it backtracks and tries parsing with <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<p>Consider this contrived example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">P</span> <span class="k">=</span> <span class="p">(</span><span class="n">Match1</span> <span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="k">&lt;|</span> <span class="p">(</span><span class="k">^</span> <span class="s">&#39;B&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">P</span></code> consumes a single byte, <code class="docutils literal notranslate"><span class="pre">'A'</span></code>, and returns it, or it consumes nothing
and returns the byte <code class="docutils literal notranslate"><span class="pre">'B'</span></code> (in the case that parsing a single <code class="docutils literal notranslate"><span class="pre">'A'</span></code> fails.)
Important to note is that, on inputs starting with <code class="docutils literal notranslate"><span class="pre">'A'</span></code>, <code class="docutils literal notranslate"><span class="pre">P</span></code>’s behavior is
unambiguous - it will always consume the <code class="docutils literal notranslate"><span class="pre">'A'</span></code>, rather than consuming
nothing.</p>
</section>
<section id="unbiased-choice-parsing">
<h3>Unbiased Choice Parsing<a class="headerlink" href="#unbiased-choice-parsing" title="Permalink to this headline"></a></h3>
<p>We can also construct the parser <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">|</span> <span class="pre">Q</span></code> from two parsers <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code>.
Like biased choice, this parser succeeds if either <code class="docutils literal notranslate"><span class="pre">P</span></code> or <code class="docutils literal notranslate"><span class="pre">Q</span></code> succeed -
However, when <em>both</em> succeed, it is <em>ambiguous</em>, and can parse inputs in more
than one way. Typically, these ambiguities are handled by sequencing with other
parsers.</p>
<p>If we take our biased choice example and replace <code class="docutils literal notranslate"><span class="pre">&lt;|</span></code> with <code class="docutils literal notranslate"><span class="pre">|</span></code>:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">P</span> <span class="k">=</span> <span class="p">(</span><span class="n">Match1</span> <span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="k">|</span> <span class="p">(</span><span class="k">^</span> <span class="s">&#39;B&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">P</span></code> is now ambiguous on inputs that start with <code class="docutils literal notranslate"><span class="pre">'A'</span></code>, since it can consume
either one or zero bytes - remember, DaeDaLus parsers in general only need to
match a prefix of the input to succeed.</p>
<p>There are many grammars that have intentional ambiguities, and this unbiased
choice facility in DaeDaLus allows us to express those formats with ease.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Much like with parser sequencing, we can use a layout-based syntax to write
down alternatives parsers. We use the keyword <code class="docutils literal notranslate"><span class="pre">First</span></code> for biased choice,
and <code class="docutils literal notranslate"><span class="pre">Choose</span></code> for unbiased choice, like so:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">BP</span> <span class="k">=</span>
  <span class="k">First</span>
    <span class="k">block</span>
      <span class="k">Match</span> <span class="s">&quot;This is&quot;</span>
      <span class="k">Match</span> <span class="s">&quot;the first alternative&quot;</span>
    <span class="k">Match</span>
      <span class="s">&quot;The second one is here&quot;</span>

<span class="k">def</span> <span class="n">UP</span> <span class="k">=</span>
  <span class="k">Choose</span>
    <span class="k">block</span>
      <span class="k">Match</span> <span class="s">&quot;This is&quot;</span>
      <span class="k">Match</span> <span class="s">&quot;the first alternative&quot;</span>
    <span class="k">Match</span>
      <span class="s">&quot;The second one is here&quot;</span>
</pre></div>
</div>
<p>Again, the language does not prefer this style over the use of <code class="docutils literal notranslate"><span class="pre">&lt;|</span></code> and
<code class="docutils literal notranslate"><span class="pre">|</span></code> - use whatever syntax is more comfortable for you. There is one major
exception to this, which we’ll address in the next section.</p>
</div>
</section>
<section id="tagged-sum-types">
<h3>Tagged Sum Types<a class="headerlink" href="#tagged-sum-types" title="Permalink to this headline"></a></h3>
<p>Something not mentioned above is that, like array-sequenced parsers,
alternative parsers must parse to the same type of semantic value on all
branches - but this is limiting! What if, for example, we’re parsing a format
that allows strings or numbers to appear in the same place? As described so
far, we can’t handle this using biased or unbiased choice.</p>
<p>Enter <em>sum types</em>.</p>
<p>In many programming languages, sum types are how we can describe a set of
alternatives. They are a ‘dual’ to record types, which are also known as
<em>product</em> types. Typically, the <em>variants</em> of a sum type are labeled with a
<em>tag</em>, which may or may not carry some additional data of some other type.</p>
<p>As a simple example, we can think of the type <code class="docutils literal notranslate"><span class="pre">bool</span></code> as a sum type with
two variants, both of which are simply tags: <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>DaeDaLus allows us to return a tagged sum type using variations of the
layout-based syntax described in the note above, similar to how we can
build structures using parser sequencing. Note that we can’t use the infix
operators <code class="docutils literal notranslate"><span class="pre">&lt;|</span></code> or <code class="docutils literal notranslate"><span class="pre">|</span></code> to accomplish this same goal - we <em>must</em> use
<code class="docutils literal notranslate"><span class="pre">First</span></code> and <code class="docutils literal notranslate"><span class="pre">Choose</span></code>.</p>
<p>As usual, this concept is best demonstrated by an example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">GoodOrBad</span> <span class="k">=</span>
  <span class="k">First</span>
    <span class="n">good</span> <span class="k">=</span> <span class="n">Match1</span> `<span class="n">G</span>`
    <span class="n">bad</span>  <span class="k">=</span> <span class="n">Match1</span> <span class="s">&#39;B&#39;</span>
</pre></div>
</div>
<p>This parser returns a semantic value of a new tagged sum type named
<code class="docutils literal notranslate"><span class="pre">GoodOrBad</span></code>, which has two variants whose tags are <code class="docutils literal notranslate"><span class="pre">good</span></code> and <code class="docutils literal notranslate"><span class="pre">bad</span></code>; this
is like parser sequencing that produces structures, except rather than each
variable corresponding to a field, each corresponds to one of the variants of
the sum type.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You might wonder if, like sequencing earlier, there is some syntactic sugar
at play. Indeed, we can construct semantic values of tagged-sum types
explicitly, using a special “barbed wire” bracket:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">GoodOrBad2</span> <span class="k">=</span>
  <span class="k">First</span>
    <span class="k">block</span>
      <span class="k">@</span><span class="n">x</span> <span class="k">=</span> <span class="n">Match1</span> <span class="s">&#39;G&#39;</span>
      <span class="k">^</span> <span class="p">{|</span> <span class="n">good</span> <span class="k">=</span> <span class="n">x</span> <span class="k">|</span><span class="p">}</span>
    <span class="k">block</span>
      <span class="k">@</span><span class="n">x</span> <span class="k">=</span> <span class="n">Match1</span> <span class="s">&#39;B&#39;</span>
      <span class="k">^</span> <span class="p">{|</span> <span class="n">bad</span> <span class="k">=</span> <span class="n">x</span> <span class="k">|</span><span class="p">}</span>
</pre></div>
</div>
<p>Note that, because of the way DaeDaLus attempts to infer the types of these
sum-typed values, this declaration will in fact create a <em>new</em> sum type
named <code class="docutils literal notranslate"><span class="pre">GoodOrBad2</span></code> - it is <em>not</em> interchangeable with the previous
definition of <code class="docutils literal notranslate"><span class="pre">GoodOrBad</span></code>, even though both types have essentially the
same values.</p>
<p>If we wanted this new parser to return the same type of semantic value as
the original <code class="docutils literal notranslate"><span class="pre">GoodOrBad</span></code>, we would need to provide <em>type annotations</em> to
guide the type inferencer:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">GoodOrBad3</span> <span class="k">=</span>
  <span class="k">First</span>
    <span class="k">block</span>
      <span class="k">@</span><span class="n">x</span> <span class="k">=</span> <span class="n">Match1</span> <span class="s">&#39;G&#39;</span>
      <span class="k">^</span> <span class="p">{|</span> <span class="n">good</span> <span class="k">=</span> <span class="n">x</span> <span class="k">|</span><span class="p">}</span> <span class="p">:</span> <span class="n">GoodOrBad</span>
    <span class="k">block</span>
      <span class="k">@</span><span class="n">x</span> <span class="k">=</span> <span class="n">Match1</span> <span class="s">&#39;B&#39;</span>
      <span class="k">^</span> <span class="p">{|</span> <span class="n">bad</span> <span class="k">=</span> <span class="n">x</span> <span class="k">|</span><span class="p">}</span>
</pre></div>
</div>
<p>Note that, since all branches of <code class="docutils literal notranslate"><span class="pre">First</span></code> and <code class="docutils literal notranslate"><span class="pre">Choose</span></code> parsers must have
the same type, we need only annotate the first branch’s result - the type
inferencer will take care of the rest.</p>
</div>
<p>With this set of rich type-constructing mechanisms, you can go forth and create
many interesting format specifications with DaeDaLus - but, what happens when
you need to parse many copies of the same thing in sequence, perhaps an unknown
number of times?</p>
</section>
</section>
<section id="repeating-parsers">
<h2>Repeating Parsers<a class="headerlink" href="#repeating-parsers" title="Permalink to this headline"></a></h2>
<p>If we need to parse the same thing multiple times, we can use the <code class="docutils literal notranslate"><span class="pre">Many</span></code>
parser combinator. In its most basic form, it can parse an arbitrarily long
sequence, stopping only when the given parser first fails. As a simple example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">$$</span> <span class="k">=</span> <span class="k">Many</span> <span class="p">(</span><span class="n">Match1</span> <span class="s">&#39;7&#39;</span><span class="p">);</span> <span class="n">Match1</span> <span class="s">&#39;0&#39;</span> <span class="p">}</span>
</pre></div>
</div>
<p>This parser will match any number of <code class="docutils literal notranslate"><span class="pre">7</span></code> followed by a <code class="docutils literal notranslate"><span class="pre">'0'</span></code> e.g.
<code class="docutils literal notranslate"><span class="pre">&quot;0&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;70&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;770&quot;</span></code>, etc. The semantic value returned by the above
parser is an array of all the <a href="#id1"><span class="problematic" id="id2">``</span></a>’7’<a href="#id3"><span class="problematic" id="id4">``</span></a>s that were parsed.</p>
<p>Be cautious when using this unbounded form of <code class="docutils literal notranslate"><span class="pre">Many</span></code>! It parses inputs
maximally, so it’s possible to accidentally create a parser that never
succeeds, e.g.:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">Many</span> <span class="p">(</span><span class="n">Match1</span> <span class="s">&#39;7&#39;</span><span class="p">);</span> <span class="n">Match1</span> <span class="s">&#39;7&#39;</span> <span class="p">}</span>
</pre></div>
</div>
<p>When we know that we are only parsing a particular number of things (or even
that there is a lower or upper bound on the number of things), we can provide
an optional additional argument to <code class="docutils literal notranslate"><span class="pre">Many</span></code>:</p>
<ul class="simple">
<li><p>The parser <code class="docutils literal notranslate"><span class="pre">Many</span> <span class="pre">n</span> <span class="pre">P</span></code> succeeds if <code class="docutils literal notranslate"><span class="pre">P</span></code> succeeds exactly <code class="docutils literal notranslate"><span class="pre">n</span></code> times</p></li>
<li><p>The parser <code class="docutils literal notranslate"><span class="pre">Many</span> <span class="pre">(i</span> <span class="pre">..</span> <span class="pre">j)</span> <span class="pre">P</span></code> succeeds if <code class="docutils literal notranslate"><span class="pre">P</span></code> succeeds at least <code class="docutils literal notranslate"><span class="pre">i</span></code> and
at most <code class="docutils literal notranslate"><span class="pre">j</span></code> times</p></li>
</ul>
<p>This latter form can be modified to leave off either the lower or upper bound,
e.g. <code class="docutils literal notranslate"><span class="pre">Many</span> <span class="pre">(i</span> <span class="pre">..)</span> <span class="pre">P</span></code>, which will succeed if <code class="docutils literal notranslate"><span class="pre">P</span></code> succeeds at least <code class="docutils literal notranslate"><span class="pre">i</span></code>
times.</p>
<p>All we’re missing now for a complete understanding of the PPM example is some
control-flow mechanisms and expressions involving semantic values - if you’re
already familiar with other programming languages, you can probably figure out
what’s going on with the <code class="docutils literal notranslate"><span class="pre">for</span></code>-loops and integer expressions, but the
following section will explain these features in more detail.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ppm-breakdown-parse.html" class="btn btn-neutral float-left" title="Breaking down PPM: Primitive Parsing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, The Daedalus Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>