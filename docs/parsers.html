<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Parsers &mdash; Daedalus 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/design-tabs.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Control Structures" href="control-structures.html" />
    <link rel="prev" title="Declarations" href="declarations.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Daedalus
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Using the Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="using-daedalus.html">Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-daedalus.html#check-a-specification">Check a Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-daedalus.html#run-the-interpreter">Run the Interpreter</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-daedalus.html#compile-to-haskell">Compile to Haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-daedalus.html#compile-to-c">Compile to C++</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Daedalus Language</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="declarations.html">Declarations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Parsers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#primitive-parsers">Primitive Parsers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sequencing-parsers">Sequencing Parsers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basic-sequencing">Basic Sequencing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-result">Explicit Result</a></li>
<li class="toctree-l3"><a class="reference internal" href="#local-variables">Local Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#structure-sequence">Structure Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="#syntactic-sugar">Syntactic Sugar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#parsing-alternatives">Parsing Alternatives</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#biased-choice">Biased Choice</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unbiased-choice">Unbiased Choice</a></li>
<li class="toctree-l3"><a class="reference internal" href="#alternative-syntax">Alternative Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tagged-unions">Tagged Unions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#repetition">Repetition</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="control-structures.html">Control Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="control-structures.html#if-then-else">If-then-else</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-structures.html#guards">Guards</a><ul>
<li class="toctree-l3"><a class="reference internal" href="control-structures.html#boolean-guards">Boolean Guards</a></li>
<li class="toctree-l3"><a class="reference internal" href="control-structures.html#guards-on-maybe">Guards on <code class="docutils literal notranslate"><span class="pre">maybe</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="control-structures.html#guards-on-tagged-unions">Guards on Tagged Unions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="control-structures.html#case">Case</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-structures.html#for-loops"><code class="docutils literal notranslate"><span class="pre">for</span></code> loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-structures.html#traversing-with-map">Traversing with <code class="docutils literal notranslate"><span class="pre">map</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="control-structures.html#many-loops"><code class="docutils literal notranslate"><span class="pre">many</span></code> loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-structures.html#commit">Commit</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Type Annotations and Coercions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="types.html#annotating-an-expression">Annotating an Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#annotating-the-result-of-a-declaration">Annotating the Result of a Declaration</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#annotating-a-parameter">Annotating a Parameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#naming-unknown-types">Naming Unknown Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#coercions">Coercions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="semantic-values.html">Semantic Values</a><ul>
<li class="toctree-l2"><a class="reference internal" href="semantic-values.html#booleans">Booleans</a></li>
<li class="toctree-l2"><a class="reference internal" href="semantic-values.html#numeric-types">Numeric Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="semantic-values.html#numeric-literals">Numeric Literals</a></li>
<li class="toctree-l3"><a class="reference internal" href="semantic-values.html#comparisons">Comparisons</a></li>
<li class="toctree-l3"><a class="reference internal" href="semantic-values.html#basic-arithmetic">Basic Arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="semantic-values.html#bitwise-operations">Bitwise Operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="semantic-values.html#maybe-type"><code class="docutils literal notranslate"><span class="pre">maybe</span></code> type</a></li>
<li class="toctree-l2"><a class="reference internal" href="semantic-values.html#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="semantic-values.html#array-builders">Array Builders</a></li>
<li class="toctree-l2"><a class="reference internal" href="semantic-values.html#association-maps">Association Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="semantic-values.html#streams">Streams</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="streams.html">Stream Manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="character-classes.html">Character Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="external.html">External Declarations</a></li>
<li class="toctree-l1"><a class="reference internal" href="bitdata.html">Bitdata</a></li>
<li class="toctree-l1"><a class="reference internal" href="lifting.html">Implicit Lifting</a></li>
<li class="toctree-l1"><a class="reference internal" href="implicit-parameters.html">Implicit Parameters</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Daedalus Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial/getting-started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial/getting-started.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/getting-started.html#daedalus-syntax-highlighting-editing-modes">DaeDaLus Syntax Highlighting / Editing Modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/getting-started.html#downloading-the-sample-specifications">Downloading The Sample Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/getting-started.html#your-first-daedalus-specification">Your First DaeDaLus Specification</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tutorial/getting-started.html#the-portable-pixmap-format">The Portable PixMap Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/getting-started.html#an-example-ppm-image">An Example PPM Image</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/getting-started.html#a-daedalus-ppm-specification">A DaeDaLus PPM Specification</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/ppm-breakdown-decl.html">Breaking down PPM: Declarations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-decl.html#deducing-types-from-names">Deducing Types From Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-decl.html#parameterized-declarations">Parameterized Declarations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/ppm-breakdown-parse.html">Breaking down PPM: Primitive Parsing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-parse.html#uint8"><code class="docutils literal notranslate"><span class="pre">UInt8</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-parse.html#match1"><code class="docutils literal notranslate"><span class="pre">Match1</span> <span class="pre">...</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-parse.html#match"><code class="docutils literal notranslate"><span class="pre">Match</span> <span class="pre">...</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-parse.html#end"><code class="docutils literal notranslate"><span class="pre">END</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-parse.html#id1"><code class="docutils literal notranslate"><span class="pre">^</span> <span class="pre">...</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-parse.html#fail"><code class="docutils literal notranslate"><span class="pre">Fail</span> <span class="pre">...</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/ppm-breakdown-comb.html">Breaking down PPM: Parser Combinators</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-comb.html#standard-sequencing">Standard Sequencing</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-comb.html#array-sequencing">Array Sequencing</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-comb.html#structure-sequencing">Structure Sequencing</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-comb.html#de-sugaring-nonstandard-structure-sequences">De-Sugaring Nonstandard Structure Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-comb.html#parsing-alternates">Parsing Alternates</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-comb.html#biased-choice-parsing">Biased Choice Parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-comb.html#unbiased-choice-parsing">Unbiased Choice Parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-comb.html#tagged-sum-types">Tagged Sum Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-comb.html#repeating-parsers">Repeating Parsers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html">Breaking down PPM: Expressions and Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#built-in-semantic-values">Built-In Semantic Values</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#bool"><code class="docutils literal notranslate"><span class="pre">bool</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#numerics">Numerics</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#maybe"><code class="docutils literal notranslate"><span class="pre">maybe</span> <span class="pre">...</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#t"><code class="docutils literal notranslate"><span class="pre">[T]</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#builders-for-arrays">Builders for Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#k-t"><code class="docutils literal notranslate"><span class="pre">[K</span> <span class="pre">-&gt;</span> <span class="pre">T]</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#control-strucutres">Control Strucutres</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#if-then-else"><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">...</span> <span class="pre">then</span> <span class="pre">...</span> <span class="pre">else</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#guarding">Guarding</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#case-of"><code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">...</span> <span class="pre">of</span> <span class="pre">...</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#loops">Loops</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#for"><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">...</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#map"><code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">...</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#more-on-types">More on Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#annotating-types">Annotating Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#unknown-types">Unknown Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/ppm-breakdown-expr.html#type-coercion">Type Coercion</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/extended-ex-intro.html">Extended Exercise: The PNG Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/extended-ex-parsers.html">Aside: What To (Not) Do While Parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/extended-ex-stdlib.html">Aside: The DaeDaLus Standard Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-stdlib.html#endianness">Endianness</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-stdlib.html#floating-point-numbers">Floating-Point Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-stdlib.html#guarding-and-consuming-everything">Guarding and Consuming Everything</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-stdlib.html#manipulating-input-streams">Manipulating Input Streams</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/extended-ex-utils.html">Extended Exercise: Defining Helpful Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-utils.html#domain-specific-parser-names">Domain-Specific Parser Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-utils.html#null-terminated-strings">Null-terminated Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-utils.html#common-structures">Common Structures</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/extended-ex-chunks.html">Extended Exercise: PNG Chunks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-chunks.html#introducing-bitdata">Introducing <code class="docutils literal notranslate"><span class="pre">bitdata</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-chunks.html#png-chunk-types">PNG Chunk Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-chunks.html#png-chunk-data">PNG Chunk Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#plte">PLTE</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#idat">IDAT</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#trns">tRNS</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#chrm">cHRM</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#gama">gAMA</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#iccp">iCCP</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#sbit">sBIT</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#srgb">sRGB</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#text">tEXt</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#ztxt">zTXt</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#itxt">iTXt</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#bkgd">bKGD</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#hist">hIST</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#phys">pHYs</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#splt">sPLT</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#time">tIME</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial/extended-ex-chunks.html#generic-chunk-data-parsing">Generic Chunk Data Parsing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-chunks.html#png-chunks">PNG Chunks</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-chunks.html#header-trailer">Header / Trailer</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-chunks.html#full-png">Full PNG</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/extended-ex-chunks.html#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/extended-ex-solution.html">Extended Exercise: Full Solution</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Daedalus</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Parsers</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/parsers.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="parsers">
<h1>Parsers<a class="headerlink" href="#parsers" title="Permalink to this headline"></a></h1>
<section id="primitive-parsers">
<h2>Primitive Parsers<a class="headerlink" href="#primitive-parsers" title="Permalink to this headline"></a></h2>
<p><strong>Specific Byte.</strong> The parser <code class="docutils literal notranslate"><span class="pre">$[</span> <span class="pre">set</span> <span class="pre">]</span></code> matches a single byte that
belongs to the set of bytes described by <em>set</em>.
For example, <code class="docutils literal notranslate"><span class="pre">$[</span> <span class="pre">'0'</span> <span class="pre">..</span> <span class="pre">'9'</span> <span class="pre">]</span></code> matches any bytes in the range 48 (<code class="docutils literal notranslate"><span class="pre">'0'</span></code>)
through 57 (<code class="docutils literal notranslate"><span class="pre">'9'</span></code>) inclusive.  See <a class="reference internal" href="character-classes.html#character-classes"><span class="std std-ref">Character Classes</span></a> for deatails
on how to write sets of bytes.</p>
<p><strong>Any Byte.</strong> The parser <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> extracts a single byte from the input.
It fails if there are no bytes left in the input.  If successful, it constructs
a value of type <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">8</span></code>.  This is equivalent to writing <code class="docutils literal notranslate"><span class="pre">$[</span> <span class="pre">$any</span> <span class="pre">]</span></code>.</p>
<p><strong>Specific Byte Sequence.</strong> The parser <code class="docutils literal notranslate"><span class="pre">Match</span> <span class="pre">bytes</span></code> matches the byte
sequence <em>bytes</em> in the current input. The resulting semantic value is an
array of bytes, <code class="docutils literal notranslate"><span class="pre">[uint</span> <span class="pre">8]</span></code>, corresponding to the matched bytes.
For example <code class="docutils literal notranslate"><span class="pre">Match</span> <span class="pre">&quot;keyword&quot;</span></code> will match <code class="docutils literal notranslate"><span class="pre">&quot;keyword&quot;</span></code>, while
<code class="docutils literal notranslate"><span class="pre">Match</span> <span class="pre">[0x00,0x01]</span></code> will match two bytes: 0 followed by 1.</p>
<p><strong>End of Input.</strong> The parser <code class="docutils literal notranslate"><span class="pre">END</span></code> succeeds only if there is no more input
to be parsed.  If successful, the result is the trivial semantic value <code class="docutils literal notranslate"><span class="pre">{}</span></code>.
Normally DaeDaLus parsers succeed as long as they match a <em>prefix</em> of the
entire input.  By sequencing (see <a class="reference internal" href="#sequencing-parsers">Sequencing Parsers</a>) a parser with
<code class="docutils literal notranslate"><span class="pre">END</span></code> we specify that the entire input must be matched.</p>
<p><strong>Pure Parsers.</strong> Any semantic value may be turned into a parser that does
not consume any input and always succeeds with the given result.  To do
so prefix the semantic value with the operator <code class="docutils literal notranslate"><span class="pre">^</span></code>.  Thus, <code class="docutils literal notranslate"><span class="pre">^</span> <span class="pre">'A'</span></code> is
a parser that always succeeds and produces byte <code class="docutils literal notranslate"><span class="pre">'A'</span></code> as a result.
The parser <code class="docutils literal notranslate"><span class="pre">Accept</span></code> may be used to match the empty string without
constructing an interesting semantic value.  It is equivalent to <code class="docutils literal notranslate"><span class="pre">^</span> <span class="pre">{}</span></code>.
In many cases, one may omit the <code class="docutils literal notranslate"><span class="pre">^</span></code> operator because of <a class="reference internal" href="lifting.html#implicit-lifting"><span class="std std-ref">Implicit Lifting</span></a>.</p>
<p><strong>Explicit Failure</strong> The <code class="docutils literal notranslate"><span class="pre">Fail</span></code> construct will always fail.  This
parser is parameterized by an optional location, along with an error
message.</p>
<p><strong>Examples:</strong></p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="c">{- Declaration                      Matches       Result          -}</span>
<span class="k">def</span> <span class="n">GetByte</span>     <span class="k">=</span> <span class="k">UInt8</span>             <span class="c">-- Any byte X X</span>
<span class="k">def</span> <span class="n">TheLetterA</span>  <span class="k">=</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;A&#39;</span> <span class="p">]</span>          <span class="c">-- Byte 65    65</span>
<span class="k">def</span> <span class="n">TheNumber3</span>  <span class="k">=</span> <span class="n">$</span><span class="p">[</span><span class="m">0</span> <span class="p">..</span> <span class="m">5</span><span class="p">]</span>         <span class="c">-- A byte between 0 to 5</span>
<span class="k">def</span> <span class="n">TheNumber16</span> <span class="k">=</span> <span class="n">$</span><span class="p">[</span> <span class="m">0x10</span> <span class="p">]</span>         <span class="c">-- Byte 16    16</span>
<span class="k">def</span> <span class="n">Magic</span>       <span class="k">=</span> <span class="k">Match</span> <span class="s">&quot;HELLO&quot;</span>     <span class="c">-- &quot;HELLO&quot;    [72,69,76,76,79]</span>
<span class="k">def</span> <span class="n">AlwaysA</span>     <span class="k">=</span> <span class="k">^</span> <span class="s">&#39;A&#39;</span>             <span class="c">-- &quot;&quot;         65</span>
<span class="k">def</span> <span class="n">GiveUp</span>      <span class="k">=</span> <span class="n">Fail</span> <span class="s">&quot;I give up&quot;</span>  <span class="c">-- (none)    Failure with message &quot;I give up&quot;</span>
</pre></div>
</div>
</section>
<section id="sequencing-parsers">
<h2>Sequencing Parsers<a class="headerlink" href="#sequencing-parsers" title="Permalink to this headline"></a></h2>
<section id="basic-sequencing">
<h3>Basic Sequencing<a class="headerlink" href="#basic-sequencing" title="Permalink to this headline"></a></h3>
<p>Multiple parsers may be executed one after the other,
by listing them either between <code class="docutils literal notranslate"><span class="pre">{</span></code> and <code class="docutils literal notranslate"><span class="pre">}</span></code> or between <code class="docutils literal notranslate"><span class="pre">[</span></code> and <code class="docutils literal notranslate"><span class="pre">]</span></code>,
and separating them with <code class="docutils literal notranslate"><span class="pre">;</span></code>.  Thus, <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">P;</span> <span class="pre">Q;</span> <span class="pre">R</span> <span class="pre">}</span></code> and <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">P;</span> <span class="pre">Q;</span> <span class="pre">R</span> <span class="pre">]</span></code> are
both composite parsers that will execute <code class="docutils literal notranslate"><span class="pre">P</span></code> , then <code class="docutils literal notranslate"><span class="pre">Q</span></code>, and finally <code class="docutils literal notranslate"><span class="pre">R</span></code>.
If any of the sequenced parsers fails, then the whole sequence fails.</p>
<p>Parsers sequenced with <code class="docutils literal notranslate"><span class="pre">[]</span></code> produce an array, with each element of the
array containing the result of the corresponding parser.
Since all elements in an array have the same type, all parsers sequenced
with <code class="docutils literal notranslate"><span class="pre">[]</span></code> should construct the same type of semantic value.</p>
<p>By default, parsers sequenced with <code class="docutils literal notranslate"><span class="pre">{}</span></code> return the result of the last
parser in the sequence.</p>
<p>Examples:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="c">{- Declaration                                  Matches       Result -}</span>
<span class="k">def</span> <span class="n">ABC1</span> <span class="k">=</span> <span class="p">{</span> <span class="n">$</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">];</span> <span class="n">$</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">];</span> <span class="n">$</span><span class="p">[</span><span class="s">&#39;C&#39;</span><span class="p">]</span> <span class="p">}</span>        <span class="c">-- &quot;ABC&quot;         67</span>
<span class="k">def</span> <span class="n">ABC2</span> <span class="k">=</span> <span class="p">[</span> <span class="n">$</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">];</span> <span class="n">$</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">];</span> <span class="n">$</span><span class="p">[</span><span class="s">&#39;C&#39;</span><span class="p">]</span> <span class="p">]</span>        <span class="c">-- &quot;ABC&quot;         [65,66,67]</span>
<span class="k">def</span> <span class="n">ABC3</span> <span class="k">=</span> <span class="p">{</span> <span class="k">Match</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span> <span class="k">Match</span> <span class="s">&quot;ABC&quot;</span> <span class="p">}</span>    <span class="c">-- &quot;HelloABC&quot;    [65,66,67]</span>
<span class="k">def</span> <span class="n">ABC4</span> <span class="k">=</span> <span class="p">{</span> <span class="k">Match</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span> <span class="n">$</span><span class="p">[</span><span class="s">&#39;C&#39;</span><span class="p">]</span> <span class="p">}</span>         <span class="c">-- &quot;HelloC&quot;      67</span>
</pre></div>
</div>
<p>An alternative notation for <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">..</span> <span class="pre">}</span></code> parsers is to use the <code class="docutils literal notranslate"><span class="pre">block</span></code> keyword
and <em>layout</em>:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">UseBraces</span> <span class="k">=</span> <span class="p">{</span> <span class="k">Match</span> <span class="s">&quot;A&quot;</span><span class="p">;</span> <span class="k">Match</span> <span class="s">&quot;B&quot;</span> <span class="p">}</span>
<span class="k">def</span> <span class="n">UseLayout</span> <span class="k">=</span>
  <span class="k">block</span>
    <span class="k">Match</span> <span class="s">&quot;A&quot;</span>
    <span class="k">Match</span> <span class="s">&quot;B&quot;</span>
</pre></div>
</div>
<p>The parsers <code class="docutils literal notranslate"><span class="pre">UseBraces</span></code> and <code class="docutils literal notranslate"><span class="pre">UseLayout</span></code> are the same, just using a
different notation.  When using layout, the entries in the sequence must start
on the same column, and any text that is indented more than that column
belongs to the corresponding parser.  So, the following parser is also
equivalent to the previous two:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">AlsoTheSame</span> <span class="k">=</span>
  <span class="k">block</span>
    <span class="k">Match</span>
      <span class="s">&quot;A&quot;</span>
    <span class="k">Match</span> <span class="s">&quot;B&quot;</span>
</pre></div>
</div>
</section>
<section id="explicit-result">
<h3>Explicit Result<a class="headerlink" href="#explicit-result" title="Permalink to this headline"></a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">block</span></code> or <code class="docutils literal notranslate"><span class="pre">{}</span></code>-sequenced group of parsers may
return the result from any member of the group instead of the last one.
To do so, assign the result of the parser to the special variable <code class="docutils literal notranslate"><span class="pre">$$</span></code>.
For example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">ReturnMiddle</span> <span class="k">=</span>
  <span class="k">block</span>
    <span class="n">P</span>
    <span class="k">$$</span> <span class="k">=</span> <span class="n">Q</span>
    <span class="n">R</span>
</pre></div>
</div>
<p>In the example above, the semantic value produce by <code class="docutils literal notranslate"><span class="pre">ReturnMiddle</span></code> is that
produced by <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
</section>
<section id="local-variables">
<h3>Local Variables<a class="headerlink" href="#local-variables" title="Permalink to this headline"></a></h3>
<p>It is also possible to combine the results of some
of the <code class="docutils literal notranslate"><span class="pre">block/{}</span></code>-sequenced parsers by using <em>local variables</em> and the
pure parser.  Assignments prefixed by the keyword <code class="docutils literal notranslate"><span class="pre">let</span></code> introduce a local
variable, which is in scope in the following parsers.  Here is an example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">Add</span> <span class="k">=</span>
  <span class="k">block</span>
    <span class="k">let</span> <span class="n">x</span> <span class="k">=</span> <span class="k">UInt8</span>
    <span class="n">$</span><span class="p">[</span> <span class="s">&#39;+&#39;</span> <span class="p">]</span>
    <span class="k">let</span> <span class="n">y</span> <span class="k">=</span> <span class="k">UInt8</span>
    <span class="k">^</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>The parser <code class="docutils literal notranslate"><span class="pre">Add</span></code> is a sequence of 4 parsers.  The local variables <code class="docutils literal notranslate"><span class="pre">x</span></code>
and <code class="docutils literal notranslate"><span class="pre">y</span></code> store the results of the first and the third parser.  The result
of the sequence is the result of the last parser, which does not consume
any input, but only constructs a semantic value by adding <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>
together.</p>
</section>
<section id="structure-sequence">
<h3>Structure Sequence<a class="headerlink" href="#structure-sequence" title="Permalink to this headline"></a></h3>
<p>It is also possible to return results from more than
one of the parsers in a <code class="docutils literal notranslate"><span class="pre">block/{}</span></code>-sequenced group.  To do so give names
to the desired results (<em>without</em> <code class="docutils literal notranslate"><span class="pre">let</span></code>).  The semantic value of the
resulting parser is a structure with fields containing the value of
the correspondingly named parsers.  Consider, for example, the
following declaration:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">S</span> <span class="k">=</span>
  <span class="k">block</span>
    <span class="n">x</span> <span class="k">=</span> <span class="k">UInt8</span>
    <span class="n">y</span> <span class="k">=</span> <span class="k">Match</span> <span class="s">&quot;HELLO&quot;</span>
</pre></div>
</div>
<p>This declaration defines a parser named <code class="docutils literal notranslate"><span class="pre">S</span></code>, which will extract a
byte followed by the sequence <code class="docutils literal notranslate"><span class="pre">&quot;HELLO&quot;</span></code>. The result of this parser is
a <em>structure type</em>, also named <code class="docutils literal notranslate"><span class="pre">S</span></code>, which has two fields, <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>:
<code class="docutils literal notranslate"><span class="pre">x</span></code> is a byte, while <code class="docutils literal notranslate"><span class="pre">y</span></code> is an array of bytes.</p>
<p>Note that structure fields also introduce a local variable with the same name,
so later parsers in the sequence may depend on the semantic values in
earlier parsers in the sequence.  For example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">S1</span> <span class="k">=</span>
  <span class="k">block</span>
    <span class="n">x</span> <span class="k">=</span> <span class="k">UInt8</span>
    <span class="n">y</span> <span class="k">=</span> <span class="k">block</span>
          <span class="k">let</span> <span class="n">z</span> <span class="k">=</span> <span class="k">UInt8</span>
          <span class="k">^</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span>
</pre></div>
</div>
<p>The parser <code class="docutils literal notranslate"><span class="pre">S1</span></code> is a sequence of two parsers, whose semantic value
is a structure with two fields, <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.  Both fields have type
<code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">8</span></code>.  The first parser just extracts a byte from input.  The second
parser is itself a sequence: first it extracts a byte from the input,
but its semantic value is the sum of the two extracted bytes.  As another
example, here is an equivalent way to define the same parser:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">S2</span> <span class="k">=</span>
  <span class="k">block</span>
    <span class="n">x</span> <span class="k">=</span> <span class="k">UInt8</span>
    <span class="k">let</span> <span class="n">z</span> <span class="k">=</span> <span class="k">UInt8</span>
    <span class="n">y</span> <span class="k">=</span> <span class="k">^</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span>
</pre></div>
</div>
</section>
<section id="syntactic-sugar">
<h3>Syntactic Sugar<a class="headerlink" href="#syntactic-sugar" title="Permalink to this headline"></a></h3>
<p>A number of the constructs described in this section are
may be thought of as simply syntactic sugar for using local variables.
Here are some examples:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Expression:</p></th>
<th class="head"><p>Equivalent to:</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">$$</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">Q</span> <span class="pre">}</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">let</span> <span class="pre">x</span>&#160; <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">Q;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">^</span> <span class="pre">x</span> <span class="pre">}</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">P;</span> <span class="pre">Q</span> <span class="pre">]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">let</span> <span class="pre">x0</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">let</span> <span class="pre">x1</span> <span class="pre">=</span> <span class="pre">Q;</span> <span class="pre">^</span> <span class="pre">[x0,x1]</span> <span class="pre">}</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">Q</span> <span class="pre">}</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">let</span> <span class="pre">x</span>&#160; <span class="pre">=</span> <span class="pre">P;</span> <span class="pre">let</span> <span class="pre">y</span>&#160; <span class="pre">=</span> <span class="pre">Q;</span> <span class="pre">^</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x;</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">}</span> <span class="pre">}</span></code></p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="parsing-alternatives">
<h2>Parsing Alternatives<a class="headerlink" href="#parsing-alternatives" title="Permalink to this headline"></a></h2>
<section id="biased-choice">
<h3>Biased Choice<a class="headerlink" href="#biased-choice" title="Permalink to this headline"></a></h3>
<p>Given two parsers <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> we may construct the composite
parser <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&lt;|</span> <span class="pre">Q</span></code>.   This parser succeeds if <em>either</em> <code class="docutils literal notranslate"><span class="pre">P</span></code> <em>or</em> <code class="docutils literal notranslate"><span class="pre">Q</span></code>
succeeds. In the case that <em>both</em> succeed, the parser behaves like <code class="docutils literal notranslate"><span class="pre">P</span></code>.
Note that <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> have to construct semantic values of the same type.</p>
<p>More operationally, <code class="docutils literal notranslate"><span class="pre">P</span></code> would be used to parse the input first,
and only if it fails would we execute <code class="docutils literal notranslate"><span class="pre">Q</span></code> on the same input.  While this
may be a useful intuition about the behavior of this parser, the actual
parsing algorithm might implement this behavior in a different way.</p>
<p>Here are some examples:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="c">{- Declaration           Matches        Result   -}</span>
<span class="k">def</span> <span class="n">B1</span> <span class="k">=</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;A&#39;</span> <span class="p">]</span>     <span class="c">-- &quot;A&quot;            &#39;A&#39;, or</span>
      <span class="k">&lt;|</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;B&#39;</span> <span class="p">]</span>     <span class="c">-- &quot;B&quot;            &#39;B&#39;</span>

<span class="k">def</span> <span class="n">B2</span> <span class="k">=</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;A&#39;</span> <span class="p">]</span>
      <span class="k">&lt;|</span> <span class="k">^</span> <span class="s">&#39;B&#39;</span>        <span class="c">-- &quot;A&quot;            &#39;A&#39;, or</span>
                      <span class="c">-- &quot;&quot;             &#39;B&#39;</span>
</pre></div>
</div>
<dl class="simple">
<dt>These two are quite different:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">B1</span></code> matches a single byte, either <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> and returns the
matched byte as the result of the parser.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">B2</span></code> matches either 1 byte, which must be <code class="docutils literal notranslate"><span class="pre">A</span></code> and will be returned
as the result of the parser, or 0 bytes, in which case it will return
byte <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p></li>
</ul>
</dd>
</dl>
</section>
<section id="unbiased-choice">
<h3>Unbiased Choice<a class="headerlink" href="#unbiased-choice" title="Permalink to this headline"></a></h3>
<p>Given two parsers <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> we may construct the composite
parser``P | Q``.  This parser succeeds if either <code class="docutils literal notranslate"><span class="pre">P</span></code> or <code class="docutils literal notranslate"><span class="pre">Q</span></code>
succeeds on the given input.   Unlike biased choice, if <em>both</em> succeed,
then the resulting parser is <em>ambiguous</em> for the given input, which means
that input may be parsed in more than one way.  It is possible, however, to
resolve ambiguities by composing (e.g., in sequence) with other parsers.</p>
<p>Here are some examples:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">U1</span> <span class="k">=</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;A&#39;</span> <span class="p">]</span> <span class="k">|</span> <span class="k">^</span> <span class="m">0</span>
<span class="k">def</span> <span class="n">U2</span> <span class="k">=</span> <span class="p">{</span> <span class="n">U1</span><span class="p">;</span> <span class="s">&#39;B&#39;</span> <span class="p">}</span>
</pre></div>
</div>
<p>Parser <code class="docutils literal notranslate"><span class="pre">U1</span></code> on its own is ambiguous on inputs starting with <code class="docutils literal notranslate"><span class="pre">&quot;A&quot;</span></code> because
it could produce either <code class="docutils literal notranslate"><span class="pre">'A</span></code> (by consuming it from the input),
or <code class="docutils literal notranslate"><span class="pre">0</span></code> (by consuming nothing).  This happens because parsers only need
to match a prefix of the input to succeed.</p>
<p>Parser <code class="docutils literal notranslate"><span class="pre">U2</span></code> accepts inputs starting with either <code class="docutils literal notranslate"><span class="pre">&quot;AB&quot;</span></code> (by using the
left alternative of <code class="docutils literal notranslate"><span class="pre">U1</span></code>) or starting with <code class="docutils literal notranslate"><span class="pre">&quot;B&quot;</span></code> (by using the right
alternative of <code class="docutils literal notranslate"><span class="pre">U1</span></code>).  No inputs are ambiguous in this case.</p>
</section>
<section id="alternative-syntax">
<h3>Alternative Syntax<a class="headerlink" href="#alternative-syntax" title="Permalink to this headline"></a></h3>
<p>Given multiple parsers <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, … we can use the <code class="docutils literal notranslate"><span class="pre">Choose</span></code> keyword
for unbiased choice and <code class="docutils literal notranslate"><span class="pre">First</span></code> for biased choice.  These constructs
use layout, in a similar style to <code class="docutils literal notranslate"><span class="pre">block</span></code>:  when using this notation
eahc alternative must start at the same indention in the file, and the
entire definition of an alternative must be indented furter.  Here are
some examples:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">BiasedExample</span> <span class="k">=</span>
  <span class="k">First</span>
    <span class="k">block</span>
      <span class="k">Match</span> <span class="s">&quot;This is&quot;</span>
      <span class="k">Match</span> <span class="s">&quot;the firts alternaitve&quot;</span>
    <span class="k">Match</span>
      <span class="s">&quot;The second one is here&quot;</span>

<span class="k">def</span> <span class="n">BiasedExample</span> <span class="k">=</span>
  <span class="k">Choose</span>
    <span class="k">block</span>
      <span class="k">Match</span> <span class="s">&quot;This is&quot;</span>
      <span class="k">Match</span> <span class="s">&quot;the firts alternaitve&quot;</span>
    <span class="k">Match</span>
      <span class="s">&quot;The second one is here&quot;</span>
</pre></div>
</div>
</section>
<section id="tagged-unions">
<h3>Tagged Unions<a class="headerlink" href="#tagged-unions" title="Permalink to this headline"></a></h3>
<p>DaeDaLus supports a variation on <code class="docutils literal notranslate"><span class="pre">Choose</span></code> and <code class="docutils literal notranslate"><span class="pre">First</span></code>
that can be used to construct tagged unions, which is useful if
you’d like the semantic value to reflect which of the parsers succeeded,
or if the branches need to return construct results of different types.</p>
<p>For example, the following parser constructs a union with possible tags
<code class="docutils literal notranslate"><span class="pre">good</span></code> and <code class="docutils literal notranslate"><span class="pre">bad</span></code>, depending on whether the input character is
<code class="docutils literal notranslate"><span class="pre">'G'</span></code> or <code class="docutils literal notranslate"><span class="pre">'B'</span></code>.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">BorG</span> <span class="k">=</span>
  <span class="k">First</span>
    <span class="n">good</span> <span class="k">=</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;G&#39;</span> <span class="p">]</span>
    <span class="n">bad</span>  <span class="k">=</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;B&#39;</span> <span class="p">]</span>
</pre></div>
</div>
<p>This parser works in a similar way to ordinary <code class="docutils literal notranslate"><span class="pre">First</span></code> except that if
an alternative succeeds, the resulting semantic value is <em>tagged</em> with
the given tag (e.g., <code class="docutils literal notranslate"><span class="pre">good</span></code> or <code class="docutils literal notranslate"><span class="pre">bad</span></code> and the previous example).  The type
of the semantic value is of a new user-defined type, derived from the name
of the declaration—in the previous example, the result of the parser would
of a newly defined union type called <code class="docutils literal notranslate"><span class="pre">BorG</span></code>.</p>
<p>It is also possible to construct a value if a tagged-union type using
the notation <code class="docutils literal notranslate"><span class="pre">{|</span> <span class="pre">good</span> <span class="pre">=</span> <span class="pre">'G'</span> <span class="pre">|}</span></code>.  For example, an alternative way
to write the previous example is like this:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">AnotherBorG</span> <span class="k">=</span>
  <span class="k">First</span>
    <span class="k">block</span>
      <span class="k">let</span> <span class="n">x</span> <span class="k">=</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;G&#39;</span> <span class="p">]</span>
      <span class="k">^</span> <span class="p">{|</span> <span class="n">good</span> <span class="k">=</span> <span class="n">x</span> <span class="k">|</span><span class="p">}</span>
    <span class="k">block</span>
      <span class="k">let</span> <span class="n">x</span> <span class="k">=</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;B&#39;</span> <span class="p">]</span>
      <span class="k">^</span> <span class="p">{|</span> <span class="n">bad</span> <span class="k">=</span> <span class="n">x</span> <span class="k">|</span><span class="p">}</span>
</pre></div>
</div>
<p>Note that when using the <code class="docutils literal notranslate"><span class="pre">{|</span> <span class="pre">tag</span> <span class="pre">=</span> <span class="pre">value</span> <span class="pre">|}</span></code> notation, DaeDaLus will try
to infer the type of the tagged union.  If it cannot infer it, it will generate
a new user defined type:  this is the case in the previous example, and so
parser <code class="docutils literal notranslate"><span class="pre">AnotherBorG</span></code> will return values of a newly generated type also
called <code class="docutils literal notranslate"><span class="pre">AnotherBorG</span></code>.</p>
<p>It is important to note that even though <code class="docutils literal notranslate"><span class="pre">BorG</span></code> and <code class="docutils literal notranslate"><span class="pre">AnotherBorG</span></code> have
essentially the same values, these values have distinct types and <strong>cannot</strong>
be freely interchanged.</p>
<p>If we want to make a tagged union value of an existing type, we’d have to
provide a <em>type annotation</em>, unless the type can already be inferred from
the context.   For example:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">YetAnotherBorG</span> <span class="k">=</span>
  <span class="k">Choose</span>
    <span class="k">block</span>
      <span class="k">let</span> <span class="n">x</span> <span class="k">=</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;G&#39;</span> <span class="p">]</span>
      <span class="k">^</span> <span class="p">{|</span> <span class="n">good</span> <span class="k">=</span> <span class="n">x</span> <span class="k">|</span><span class="p">}</span> <span class="p">:</span> <span class="n">BorG</span>
    <span class="k">block</span>
      <span class="k">let</span> <span class="n">x</span> <span class="k">=</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;B&#39;</span> <span class="p">]</span>
      <span class="k">^</span> <span class="p">{|</span> <span class="n">bad</span> <span class="k">=</span> <span class="n">x</span> <span class="k">|</span><span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">BorG</span></code> in the first alternative specifies that we are making a value
of type <code class="docutils literal notranslate"><span class="pre">BorG</span></code>.  Note that we do not need to provide the annotation on the
second alternative because all alternatives in (untagged) <code class="docutils literal notranslate"><span class="pre">Choose</span></code> have
the same type, so DaeDaLus can infer that we are also making a value of
type <code class="docutils literal notranslate"><span class="pre">BorG</span></code>.</p>
</section>
</section>
<section id="repetition">
<h2>Repetition<a class="headerlink" href="#repetition" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Many</span></code> construct allows the same parser to be run multiple times
in sequence on an incoming data stream, and it returns an array containing
the resulting semantic values.</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">block</span>
  <span class="k">$$</span> <span class="k">=</span> <span class="k">Many</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;7&#39;</span> <span class="p">]</span>
  <span class="n">$</span><span class="p">[</span> <span class="s">&#39;0&#39;</span> <span class="p">]</span>
  <span class="k">END</span>
</pre></div>
</div>
<p>This code will successfully parse any stream consisting of multiple <code class="docutils literal notranslate"><span class="pre">7</span></code>
characters, terminated by the <code class="docutils literal notranslate"><span class="pre">0</span></code> character at the end of the stream. For
example, the stream <code class="docutils literal notranslate"><span class="pre">&quot;7770&quot;</span></code> will return the array <code class="docutils literal notranslate"><span class="pre">['7',</span> <span class="pre">'7',</span> <span class="pre">'7']</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Many</span></code> construct optionally takes either a <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">64</span></code> value or an
interval bounded by two <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">64</span></code> values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Many</span> <span class="pre">n</span> <span class="pre">P</span></code> succeeds if it executes parser <code class="docutils literal notranslate"><span class="pre">P</span></code> exactly <code class="docutils literal notranslate"><span class="pre">n</span></code> times.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Many</span> <span class="pre">(i..j)</span> <span class="pre">P</span></code> succeeds if it executes parser <code class="docutils literal notranslate"><span class="pre">P</span></code> at least <code class="docutils literal notranslate"><span class="pre">i</span></code> and
at most <code class="docutils literal notranslate"><span class="pre">j</span></code> times.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Many</span></code> also supports lower-bounded intervals <code class="docutils literal notranslate"><span class="pre">Many</span> <span class="pre">(i..)</span> <span class="pre">P</span></code>, and
likewise upper-bounded intervals <code class="docutils literal notranslate"><span class="pre">Many</span> <span class="pre">(..j)</span> <span class="pre">P</span></code>.</p></li>
</ul>
<p>To avoid spurious backtracking, <code class="docutils literal notranslate"><span class="pre">Many</span></code> will parse any input maximally.
This can have counter-intuitive consequences! For example, the following
code will never succeed:</p>
<div class="highlight-DaeDaLus notranslate"><div class="highlight"><pre><span></span><span class="k">block</span>
  <span class="k">Many</span> <span class="n">$</span><span class="p">[</span> <span class="s">&#39;7&#39;</span> <span class="p">]</span>
  <span class="n">$</span><span class="p">[</span> <span class="s">&#39;7&#39;</span> <span class="p">]</span>
</pre></div>
</div>
<p>The call to <code class="docutils literal notranslate"><span class="pre">Many</span></code> will consume all the input characters matching <code class="docutils literal notranslate"><span class="pre">7</span></code>,
meaning that the following <code class="docutils literal notranslate"><span class="pre">$[</span> <span class="pre">'7'</span> <span class="pre">]</span></code> will always fail. This may be difficult
to spot in situations where two more complex parsers are run in sequence,
the first of which contains an unbounded call to <code class="docutils literal notranslate"><span class="pre">Many</span></code>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="declarations.html" class="btn btn-neutral float-left" title="Declarations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="control-structures.html" class="btn btn-neutral float-right" title="Control Structures" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, The Daedalus Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>